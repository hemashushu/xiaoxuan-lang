<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>变量 - The XiaoXuan Language Reference</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">介绍</a></li><li class="chapter-item expanded "><a href="data-types.html"><strong aria-hidden="true">1.</strong> 数据类型</a></li><li class="chapter-item expanded "><a href="variables.html" class="active"><strong aria-hidden="true">2.</strong> 变量</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">3.</strong> 函数</a></li><li class="chapter-item expanded "><a href="collection.html"><strong aria-hidden="true">4.</strong> 数据容器</a></li><li class="chapter-item expanded "><a href="structs-and-unions.html"><strong aria-hidden="true">5.</strong> 结构体和联合体</a></li><li class="chapter-item expanded "><a href="control-flow.html"><strong aria-hidden="true">6.</strong> 流程控制</a></li><li class="chapter-item expanded "><a href="pattern.html"><strong aria-hidden="true">7.</strong> 模式</a></li><li class="chapter-item expanded "><a href="method-and-generic-and-trait.html"><strong aria-hidden="true">8.</strong> 方法、范型和特性</a></li><li class="chapter-item expanded "><a href="error-handing.html"><strong aria-hidden="true">9.</strong> 错误处理</a></li><li class="chapter-item expanded "><a href="chain.html"><strong aria-hidden="true">10.</strong> 链式调用</a></li><li class="chapter-item expanded "><a href="interface-and-components.html"><strong aria-hidden="true">11.</strong> 接口和元组件</a></li><li class="chapter-item expanded "><a href="package-and-modules.html"><strong aria-hidden="true">12.</strong> 包和模块</a></li><li class="chapter-item expanded "><a href="stream.html"><strong aria-hidden="true">13.</strong> 流</a></li><li class="chapter-item expanded "><a href="io.html"><strong aria-hidden="true">14.</strong> I/O</a></li><li class="chapter-item expanded "><a href="mutable.html"><strong aria-hidden="true">15.</strong> 可变性</a></li><li class="chapter-item expanded "><a href="parallel-and-concurrency.html"><strong aria-hidden="true">16.</strong> 并行和并发</a></li><li class="chapter-item expanded "><a href="annonations.html"><strong aria-hidden="true">17.</strong> 标注</a></li><li class="chapter-item expanded "><a href="unit-test.html"><strong aria-hidden="true">18.</strong> 单元测试</a></li><li class="chapter-item expanded "><a href="comments-and-documents.html"><strong aria-hidden="true">19.</strong> 注释和文档</a></li><li class="chapter-item expanded "><a href="cn-spec.html"><strong aria-hidden="true">20.</strong> 中文文法</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The XiaoXuan Language Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a>
<ul>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B5%8B%E5%80%BC">变量的声明和赋值</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a>
<ul>
<li><a href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">类型推导</a></li>
<li><a href="#%E5%88%97%E8%A1%A8list">列表（List）</a></li>
<li><a href="#%E6%98%A0%E5%B0%84%E8%A1%A8map">映射表（Map）</a></li>
<li><a href="#%E5%85%83%E7%BB%84">元组</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E7%B1%BB%E5%9E%8B%E7%AE%80%E5%86%99%E8%80%83%E8%99%91%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%87%BD%E6%95%B0%E4%B8%80%E7%AB%A0">类型简写（考虑移动到函数一章）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D">定义数据类型别名</a></li>
<li><a href="#%E5%AD%97%E9%9D%A2%E4%B8%A4%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2">字面两类型的自动（隐式）转换</a></li>
</ul>
</li>
<li><a href="#%E5%80%BC%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">值的不可变性</a></li>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">变量的不可变性</a></li>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%AF%E5%8F%98%E6%80%A7%E4%B8%8D%E6%94%AF%E6%8C%81">变量的可变性（::不支持）</a>
<ul>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">变量的作用域</a></li>
<li><a href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8D%E6%94%AF%E6%8C%81">全局变量（::不支持）</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE">枚举</a></li>
<li><a href="#%E5%80%BC%E7%9A%84%E5%A4%8D%E5%88%B6">值的复制</a></li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->
<h2 id="变量的声明和赋值"><a class="header" href="#变量的声明和赋值">变量的声明和赋值</a></h2>
<p>变量的声明和赋值需要同时进行，语法如下：</p>
<ul>
<li><code>让 数据类型 变量名称 = 值</code></li>
<li><code>let DataType name = value</code></li>
</ul>
<p>示例：</p>
<ul>
<li><code>让 整数 a = 123</code></li>
<li><code>let Int a = 123</code></li>
</ul>
<p>在 XiaoXuan 语言里，基本类型的数据是值，结构体、联合体也是值，一个函数也可以作为一个值，所以它们都可以赋值给一个变量。</p>
<p>变量名可以是大小写字母、中文（严格来说代码点大于 u{00A0} 的 Unicode 字符均可）、数字和下划线的组合，但第一个字不能是数字，变量名区分大小写。</p>
<p>::TODO</p>
<p><code>assign</code> 赋值语句：
<code>assign&lt;Int&gt;(a, 123)</code></p>
<p><code>赋予变量甲,真</code>
<code>赋予&lt;逻辑&gt;变量甲,真</code>
<code>赋予变量乙,一二三</code>
<code>赋予(整数)变量乙,一二三</code></p>
<pre><code class="language-js">赋予&lt;逻辑&gt;变量甲,真
如果变量甲:等于:真那么书写行 &quot;文本一&quot; 否则书写行 &quot;文本二&quot;
若甲:同:真则书 &quot;文一&quot; 否则书 &quot;文二&quot;
</code></pre>
<h3 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h3>
<h4 id="类型推导"><a class="header" href="#类型推导">类型推导</a></h4>
<p>XiaoXuan 有类型推导机制，当值的类型可以确定的情况下，可以省略变量的数据类型声明，示例：</p>
<ul>
<li><code>让 a = 123</code></li>
<li><code>let a = 123</code></li>
</ul>
<p>变量 <code>a</code> 的数据类型会自动推导为 <code>整数</code>（<code>Int</code>）。</p>
<p>类型推导还具有传导性，函数的嵌套调用、函数的连续调用都会尽可能地推导出正确的数据类型。</p>
<p>一般情况下，对于变量声明及赋值语句：</p>
<ul>
<li>如果是字面值赋值，<strong>建议省略</strong> 变量的数据类型声明，因为数据类型显而易见，省略数据类型声明不妨碍阅读理解且会更简洁；</li>
<li>如果是接收某个函数的返回值，<strong>不建议省略</strong> 变量的数据类型声明，因为调用其他模块的函数，其返回值的数据类型不明显，加上数据类型声明能让代码更清晰。</li>
<li>如果是接收范型的函数的返回值，当范型作用在返回值类型时，可以省略变量的数据类型声明，当范型是作用在参数时，如果是实例化一个联合体，则可以省略，其他情况则不建议省略。比如 <code>Option&lt;T&gt;</code>，语句 <code>let a = Some(123)</code> 可省略类型。</li>
</ul>
<h4 id="列表list"><a class="header" href="#列表list">列表（List）</a></h4>
<p>列表字面量的数据类型由第一个元素决定，比如：</p>
<ul>
<li><code>让 a = [1, 2, 3]</code></li>
<li><code>let a = [1, 2, 3]</code></li>
</ul>
<p>列表的数据类型为 <code>列表&lt;整数&gt;</code>（<code>List&lt;Int&gt;</code>）。</p>
<ul>
<li><code>让 b = [&quot;你好&quot;, &quot;世界&quot;]</code></li>
<li><code>let b = [&quot;Hello&quot;, &quot;World&quot;]</code></li>
</ul>
<p>列表的数据类型为 <code>列表&lt;字符串&gt;</code>（<code>List&lt;String&gt;</code>）。</p>
<p>因为空列表无法进行类型推导，所以要赋值一个空列表给变量，则需要声明变量的数据类型：</p>
<ul>
<li><code>让 列表&lt;字符串&gt; b = []</code></li>
<li><code>let List&lt;String&gt; b = []</code></li>
</ul>
<p>当然这种情况下一般使用列表的构造函数来实例化一个空列表。</p>
<ul>
<li><code>让 c = 列表&lt;字符串&gt; ()</code></li>
<li><code>let c = List&lt;String&gt; ()</code></li>
</ul>
<h4 id="映射表map"><a class="header" href="#映射表map">映射表（Map）</a></h4>
<p>映射表的数据类型由第一个映射对的数据类型决定，比如：</p>
<ul>
<li><code>让 a = {姓: &quot;张&quot;, 名: &quot;三&quot;}</code></li>
<li><code>let a = {firstName: &quot;San&quot;, lastName: &quot;Zhang&quot;}</code></li>
</ul>
<p>因为第一对映射对是：<code>姓: &quot;张&quot;</code>，映射表的数据类型为 <code>映射表&lt;字符串, 字符串&gt;</code>（<code>Map&lt;String, String&gt;</code>）。</p>
<p>注意当映射表的字面量当中的键名是字符串时，是可以省略包围字符串的双引号的，所以上例实际上是下面语句的简写：</p>
<ul>
<li><code>让 a = {&quot;姓&quot;: &quot;张&quot;, &quot;名&quot;: &quot;三&quot;}</code></li>
<li><code>let a = {&quot;firstName&quot;: &quot;San&quot;, &quot;lastName&quot;: &quot;Zhang&quot;}</code></li>
</ul>
<h4 id="元组"><a class="header" href="#元组">元组</a></h4>
<p>元组可视为一个匿名成员的结构体，元组的数据类型由其中的各个元素决定，即，元组的数据类型是其各个成员的顺序和数据类型的组合。比如：</p>
<ul>
<li><code>让 a = (123, &quot;你好&quot;, 真)</code></li>
<li><code>let a = (123, &quot;Hello&quot;, true)</code></li>
</ul>
<p>则这个元组的数据类型是 <code>(整数, 字符串, 逻辑)</code>（<code>(Int, String, Boolean)</code>）</p>
<p>元组一般作为函数的参数列表，也可以作为函数的返回值。</p>
<p>作为函数的参数时，可以为元组的字面量的成员添加名称，运行环境会根据名称来找到对应的参数然后传值。示例：</p>
<ul>
<li><code>让 p = (id = 123, name = &quot;张三&quot;)</code></li>
<li><code>let p = (id = 123, name = &quot;foo&quot;)</code></li>
</ul>
<p>但语法不支持根据名称获取成员值，简单来说，元组成员的名称是只写的。</p>
<p>当一个函数的返回值不止一个数据，但又不想单独创建一个结构体来存储这个返回值时，可以简单地使用元组 &quot;封装&quot; 这些值，然后一次返回给函数的调用者。</p>
<p>有些函数可能没有任何具有意义返回值，所以专门有一个叫做 <code>单元</code>（<code>Unit</code>）的联合体（数据类型），其值有且只有一个 <code>空值</code>（<code>void</code>）。XiaoXuan 规定空元组 &quot;()&quot; 的数据类型为 <code>单元</code>，其值等于 <code>空值</code>。</p>
<h4 id="函数"><a class="header" href="#函数">函数</a></h4>
<p>函数的签名就是该函数的数据类型，比如下面的函数：</p>
<ul>
<li><code>函数 整数 增加(整数 number, 整数 amount) = number + amount</code></li>
<li><code>function Int increase(Int number, Int amount) = number + amount</code></li>
</ul>
<p>它的签名是：</p>
<ul>
<li><code>整数 &lt;- (整数, 整数)</code></li>
<li><code>Int &lt;- (Int, Int)</code></li>
</ul>
<p>其中 <code>&lt;-</code> 符号用于分隔函数返回值的数据类型以及函数的参数列表，也表示这个表达式是一个函数签名。</p>
<p>在字面上，函数的签名如同把函数的名称、参数的名称、函数主体通通全部移除之后的骨架，也就是说，函数签名只包含：</p>
<ul>
<li>函数返回值的数据类型</li>
<li>各参数的数据类型的列表</li>
</ul>
<p>有时为了便于阅读理解，也可以保留函数的签名的参数名称，比如:</p>
<ul>
<li><code>整数 &lt;- (整数 number, 整数 amount)</code></li>
<li><code>Int &lt;- (Int number, Int amount)</code></li>
</ul>
<p>对于范型（即类型参数化）函数，参数的数据类型就是范型参数，比如：</p>
<ul>
<li><code>函数 甲型 增加(甲型 source, 乙型 amount) =  source + amount</code></li>
<li><code>function T increase(T source, E amount) =  source + amount</code></li>
</ul>
<p>它的签名是：</p>
<ul>
<li><code>甲型 &lt;- (甲型, 乙型)</code></li>
<li><code>T &lt;- (T, E)</code></li>
</ul>
<p>如果一个函数的参数的数据类型是函数，则该函数的定义语句可能会很长以至于影响阅读，比如：</p>
<pre><code class="language-js">函数 返回值的数据类型 函数名称 (整数 &lt;- (整数 a, 整数 b) 参数1, ..., 字符串 &lt;- (字符串 s, 字符 c) 参数N)
    ...
以上
</code></pre>
<pre><code class="language-js">function DataType function_name (Int &lt;- (Int a, Int b) param1, ..., String &lt;- (String s, Char c) paramN)
    ...
end
</code></pre>
<h4 id="结构体"><a class="header" href="#结构体">结构体</a></h4>
<p>::TODO</p>
<pre><code class="language-js">struct User
    Int number
    String name
end

List&lt;User&gt; users = [User::new(1,&quot;foo&quot;), User::new(2, &quot;bar&quot;)]

// 可以省略列表内元素的类型，由变量声明的类型自动推导

List&lt;User&gt; users = [{1, &quot;foo&quot;}, {2, &quot;bar&quot;}]
</code></pre>
<h5 id="类型简写考虑移动到函数一章"><a class="header" href="#类型简写考虑移动到函数一章">类型简写（考虑移动到函数一章）</a></h5>
<p>XiaoXuan 语法支持 <code>类型</code>（<code>type</code>） 关键字，以允许在函数的主体之前将函数的签名定义成一个单独的名称，语法如下：</p>
<pre><code class="language-js">函数 返回值的数据类型 函数名称 (签名名称1 参数1, ..., 签名名称N 参数N) 类型
    签名名称1 = 整数 &lt;- (整数 a, 整数 b),
    签名名称N = 字符串 &lt;- (字符串 s, 字符 c)
    ...
以上
</code></pre>
<pre><code class="language-js">function DataType function_name (type1 param1, ..., typeN paramN) type
    type1 = Int &lt;- (Int a, Int b),
    typeN = String &lt;- (String s, Char c)
    ...
end
</code></pre>
<p>语法当中的 <code>类型</code>（<code>type</code>） 关键字接着一系列参数类型的声明，多个类型声明之间使用<strong>逗号分隔</strong>，最后一个类型声明之后则是函数的主体开始。</p>
<blockquote>
<p>如果有多个类型声明，类型声明之间的逗号<strong>不能省略</strong>，因为这是表示类型声明部分，当最后一个声明后面没有逗号时，语法解析器会认为是函数主体的开始。</p>
</blockquote>
<h3 id="定义数据类型别名"><a class="header" href="#定义数据类型别名">定义数据类型别名</a></h3>
<p>可以为名字较长的数据类型（如某个组合的元组，或者某个函数签名）定义一个别名，使用别名可以让代码更简洁清晰，定义数据类型别名的语法：</p>
<ul>
<li><code>类型 名称 = 数据类型</code></li>
<li><code>type Name = DataType</code></li>
</ul>
<p>示例：</p>
<pre><code class="language-js">类型 字符串 = 列表&lt;字符&gt;
类型 空型 = 结果&lt;单元, 错误&gt;
类型 排队令牌 = (整数, 字符串)
类型 整数过滤函数 = 逻辑 &lt;- (整数)
类型 过滤函数&lt;T&gt; = 逻辑 &lt;- (T)
</code></pre>
<pre><code class="language-js">type String = List&lt;Char&gt;
type Void = Result&lt;Unit, Error&gt;
type Token = (Int, String)
type IntFilterFunc = Boolean &lt;- (Int)
type FilterFunc&lt;T&gt; = Boolean &lt;- (T)
</code></pre>
<p>使用类型别名可以缩短函数的定义语句，比如下面几个函数的定义的结果是一样的。</p>
<pre><code class="language-js">## 直列式

函数 列表&lt;整数&gt; 筛选合格者(列表&lt;整数&gt; items, 逻辑 &lt;- (整数) f)
    ...
以上

## 使用 `其中` 关键字

函数 列表&lt;整数&gt; 筛选合格者(列表&lt;整数&gt; items, 整数过滤函数 f) 其中
    整数过滤函数 = 逻辑 &lt;- (整数)
    ...
以上

## 使用 `类型` 定义别名

类型 整数过滤函数 = 逻辑 &lt;- (整数)
函数 列表&lt;整数&gt; 筛选合格者(列表&lt;整数&gt; items, 整数过滤函数 f)
    ...
以上
</code></pre>
<pre><code class="language-js">## flat list

function List&lt;Int&gt; passFilter(List&lt;Int&gt; items, Boolean &lt;- (Int) f)
    ...
end

## using 'where` keyword

function List&lt;Int&gt; passFilter(List&lt;Int&gt; items, IntFilterFunc f) where
    IntFilterFunc = Boolean &lt;- (Int)
    ...
end

## using 'type' define alias name

type IntFilterFunc = Boolean &lt;- (Int)
function List&lt;Int&gt; passFilter(List&lt;Int&gt; items, IntFilterFunc f)
    ...
end
</code></pre>
<h3 id="字面两类型的自动隐式转换"><a class="header" href="#字面两类型的自动隐式转换">字面两类型的自动（隐式）转换</a></h3>
<p>当将一个能表示范围较小的数值的字面量赋值给一个范围较大的变量时，运行环境（的解析器）会进行类型的隐式转换（有些语言也叫类型提升）。</p>
<p>比如将一个整数（默认是 <code>Int</code>）的字面量赋值给 <code>Float</code> 类型的变量时，该字面量会被提升为 <code>Float</code> 类型。</p>
<p>示例：</p>
<p><code>let Real r = 3</code></p>
<p>会被自动替换为：</p>
<p><code>let Real r = 3.0</code></p>
<p>注意，如果将一个整数字面量（默认为 <code>Int64</code> 类型）赋值给诸如 <code>Int32</code>、或者 <code>Int8</code> 等类型的变量时，解析器也会事先进行检查，然后再赋值正确的数值给变量。</p>
<p>类型隠式转换仅发生在字面量赋值语句里，下面情况不会进行类型转换：</p>
<ul>
<li>字面量之间的算术运算。</li>
<li>字面量作为参数传给函数；</li>
<li>不同类型变量的赋值；</li>
<li>字面量跟不同类型的变量之间的算术运算；</li>
<li>不同类型变量之间的算术运算。</li>
</ul>
<p>XiaoXuan 的类型转换是发生在语法分析阶段，而不是在运行时。</p>
<p>当两个不同类型的<strong>字面量</strong>进行算术运算时（比如整数和浮点数之间的加法、减法等），其实不存在类型的隠式转换。其运算过程是：</p>
<ol>
<li>首先运行环境会获取第一个字面量的数据类型；</li>
<li>然后查找该类型对应运算的函数；</li>
<li>然后根据第二个操作数的类型寻找相应的方法重载；</li>
<li>如果找到则调用该方法，如果找不到则抛出运行时错误。</li>
</ol>
<p>示例：</p>
<p><code>3 + 4.5</code></p>
<p>首先运行环境会找到 <code>Int64::add</code> 方法，然后继续查找是否存在该方法的重载 <code>Int64::add(Int64, Real64)</code> 并调用它，即该加法表达式实际上被翻译为：</p>
<p><code>Int64::add(3, 4.5)</code></p>
<h2 id="值的不可变性"><a class="header" href="#值的不可变性">值的不可变性</a></h2>
<p>XiaoXuan 的值（包括各种集合、结构体、联合体等）也是不可变的。比如：</p>
<ul>
<li>对于一个列表，直接修改它的元素是不允许的，增加或者删除元素都会返回一个新的列表；</li>
<li>对于一个结构体，无法修改它的成员的值，修改某个成员的值会返回一个新的结构体。</li>
</ul>
<p>值得不可变性使得数据可以放心传递给多线程，不会因为某个线程的修改而导致数据竞争。是 XiaoXuan 并行和并发工作模式的基础。</p>
<h2 id="变量的不可变性"><a class="header" href="#变量的不可变性">变量的不可变性</a></h2>
<p>变量定义并赋值之后，便无法再次赋值。也就是说，除了变量指向的值是不可变的，变量的 &quot;指向&quot; 本身也是不可变的。</p>
<p>比如下面的语句会引起运行时异常：</p>
<pre><code class="language-js">让 a = 123
a = 456  # 错误
</code></pre>
<pre><code class="language-js">let a = 123
a = 456  # Error
</code></pre>
<p>因为变量无法重新赋值，所以对于我们所熟悉的（在可变变量的语言里）常用数据处理方法，在 XiaoXuan 里需要稍微转换一下。</p>
<p>比如有一个程序：让用户多次输入数字，然后计算数字的总和，直到用户输入 &quot;Q&quot; 为止。下面的是 JavaScript 版本：</p>
<pre><code class="language-JavaScript">let sum = 0;
while(true) {
    let s = prompt('Enter a number:');
    if (s === 'Q') break;

    let i = parseInt(s);
    sum = sum + i;
}
console.log(sum)
</code></pre>
<p>下面是 XiaoXuan 版本：</p>
<pre><code class="language-js">function Int add(Int acc)
  let s = readLine()?
  if s == &quot;Q&quot; then return acc

  let i = parse&lt;Int&gt;(s)
  let c = acc + i

  # 以当前的累加值作为参数调用自己以
  # 再执行一遍当前这个过程
  add (c)
end

let sum = add (0)
writeLine(sum)
</code></pre>
<p>XiaoXuan 语言会对函数的尾调用进行优化，只要函数最后执行的表达式是调用函数自己本身，则不会创建新的调用栈，也就是说不会堆栈溢出。</p>
<p>XiaoXuan 也有自己的条件循环语句：<code>设有 让...</code>（<code>for let...</code>）语句，其实质是通过创建一个匿名函数及递归调用来实现的，这样可以省去自己手动创建函数。示例：</p>
<pre><code class="language-js">let sum =
    for let Int acc = 0
        let s = readLine()?
        if s == &quot;Q&quot; then return acc

        let i = parse&lt;Int&gt;(s)
        let c = acc + i
        loop c
    end

writeLine(c)
</code></pre>
<p><code>for let...</code> 语句实际上是创建了一个匿名函数，然后通过 loop 语句调用自己，以实现 &quot;循环&quot; 的效果。详细请见 <a href="control-flow.html">流程控制</a>。</p>
<h2 id="变量的可变性不支持"><a class="header" href="#变量的可变性不支持">变量的可变性（::不支持）</a></h2>
<p>某些 XiaoXuan 的衍生版本（语言）可能会支持可变变量，但其可变原理跟一般支持变量可变的语言仍不太相同。</p>
<p>比如，现有一个指向字符串的变量，在被重新赋值之后，该变量原先指向的那份（在内存堆中）字符串数据仍然被保留着，只是变量指向了一份新的字符串数据。当程序再次读取这个变量时，获取的是最新版本的数据。至于旧的版本，如果之前已经被其他程序读取且仍在使用中（比如已经传递给某一个线程正在处理），则这部分程序看到的仍然是旧版本的数据。如果旧版本没有其他程序引用，则它将被垃圾回收。</p>
<p>可见处理可变变量的方式总是 &quot;只增&quot; 新版本，然后让变量指向新版本，而不是直接修改（或覆盖，或抹除）原先的数据。这种处理方式类似某些版本控制工具（比如 Git）的工作方式，即默认情况下提交（commit，更新）仓库实际上是增加新版本，所有历史版本都会保留着。</p>
<h3 id="变量的作用域"><a class="header" href="#变量的作用域">变量的作用域</a></h3>
<p>每个变量都有其作用域，比如：</p>
<ul>
<li>在模块定义的变量，其作用域是其所在的模块（同一个模块可以分布在不同的源代码文件里）；</li>
<li>在函数里定义的变量，其作用域在其所在的函数里；</li>
<li>在语句块（包括条件语句、循环语句、匿名函数主体等）定义的变量，其作用域仅限其所在的语句块里。</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">module apple

function a ()
    let x = 22           # 定义函数级的变量 x
    # let x = 99         # 当前环境已存在名称为 x 的变量，这里无法再定义变量 x

    for d in [1..10]     # 变量 d 的作用域仅限当前 for 语句块之内
        writeLine(x)     # 能输出函数级的变量 x = 22
        # let x = 33     # 当前环境仍然存在名称为 x 的变量，这里无法再定义变量 x

        let y = 33       # 定义语句块级的变量 y

        if d&gt;0 then
            writeLine(x) # 能输出函数级的变量 x = 22
            writeLine(y) # 能输出语句块级的变量 y = 33

            let z = 44   # 定义内层语句块级的变量 z
        end

        # writeLine(z)   # 这里已经超出内层语句块级的变量 z 作用域

        let z = 55       # 当前环境不存在名称为 z 的变量，这里可以定义语句块级的变量 z
    end

    # writeLine(d)       # 这里已经超出 for 语句块变量 d 的作用域
end

function b ()
    # writeLine(x)       # 这里无法访问函数 a 里的变量 x
end
</code></pre>
<p>注意在有效作用域里不允许存在同名变量，比如下面的代码会引起运行时异常：</p>
<pre><code class="language-js">函数 空型 测试()
    让 n = 123
    让 n = 456        # 当前环境已存在名称为 n 的变量，这里无法再定义变量 n

    如果 n &gt; 100 那么 # 当前环境已存在名称为 n 的变量，这里无法再定义变量 n
      ...
    以上

    设有 i 取自 [1..10]
        ...
        让 n = 789    # 当前环境已存在名称为 n 的变量，这里无法再定义变量 n
        ...
    以上

    让 i = 666        # 这里已经超出循环语句块变量 i 的作用域，这里可以定义变量 i
以上
</code></pre>
<h3 id="全局变量不支持"><a class="header" href="#全局变量不支持">全局变量（::不支持）</a></h3>
<p>全局变量其实就是作用域为模块级的普通变量，即在模块范围里（而不是在某个函数、类型实现、模块实现里）定义的变量。全局变量使用关键字 <code>定义</code> 来定义，其语法除了关键字不同，其余跟 <code>让</code> 语句一样。示例：</p>
<pre><code class="language-js">模块 foo.bar

定义 整数 n = 123

@测试
函数 空型 第一个测试 ()
    书写行 (n) # 这里输出全局变量 n 的值
以上
</code></pre>
<pre><code class="language-js">module foo.bar

define Int n = 123

@test
function Void firstTest ()
    writeLine (n) # output the value of global variable n
end
</code></pre>
<p>在模块范围定义的变量能够被其他模块所读取，只要被导入即可，也就是说它能被程序的任何地方所读取，所以也可以称为 &quot;全局变量&quot;。</p>
<p>示例：</p>
<pre><code class="language-js">模块 hello.world

导入 foo.bar

@测试
函数 空型 第二个测试 ()
    书写行 (bar.n) # 这里输出 'foo.bar' 模块的变量 n 的值
以上
</code></pre>
<pre><code class="language-js">module hello.world

import foo.bar

@test
function Void secondTest ()
    writeLine (bar.n) # output the value of global variable n which exists in the module 'foo.bar'
end
</code></pre>
<p>全局变量的赋值语句（即右值，一个字面量或者一个表达式）会在模块被加载时运行。准确来说，加载应用程序时，会先加载所有模块所有定义性质的语句，比如函数、结构体、特性、接口、组件实现等等的定义，然后才执行全局变量的赋值语句。</p>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>因为 XiaoXuan 的变量的值不可变性，所以常量跟变量非常相近，不同的地方在于：</p>
<ul>
<li>常量即使在某些支持变量可变的衍生版本里，也是不能被重新赋值；</li>
<li>常量的名称可以用在模式匹配里当作字面量使用，而变量名称在模式匹配里会被当成新的变量。</li>
</ul>
<p>定义常量的语法是：</p>
<pre><code class="language-js">常量 数据类型 常量名称 = 值
</code></pre>
<p>也可以一次定义一组：</p>
<pre><code class="language-js">常量 数据类型 常量组名称
   成员名称1 = 值1
   成员名称2 = 值2
   ...
   成员名称N = 值N
以上
</code></pre>
<!-- XiaoXuan 规定常量必须一组一组地定义，不能单独地使用一个名称定义一个常量值，-->
<p>访问常量组的成员是，使用 <code>组名::成员名</code> 的格式。</p>
<p>示例：</p>
<pre><code class="language-js">名称空间 http::client
    常量 整数 ResponseCode
        Ok = 200
        Moved = 301
        Found = 302
        NotModified = 304
        BadRequest = 400
        Forbidden = 403
        NotFound = 404
        ServerError = 500
        ServiceUnavailable = 503
    以上

    函数 结果&lt;单元&gt; 第一个测试 ()
        书写行 (ResponseCode::Ok) # 输出常量的实际值 &quot;200&quot;
        书写行 (ResponseCode::NotFound) # 输出 &quot;404&quot;
    以上
以上
</code></pre>
<pre><code class="language-js">namespace http.client
    const Int ResponseCode
        Ok = 200
        Moved = 301
        Found = 302
        NotModified = 304
        BadRequest = 400
        Forbidden = 403
        NotFound = 404
        ServerError = 500
        ServiceUnavailable = 503
    end

    function Result&lt;Unit, Error&gt; firstTest ()
        writeLine (ResponseCode::Ok)       # output the actual value &quot;200&quot;
        writeLine (ResponseCode::NotFound) # output &quot;404&quot;
    end
end
</code></pre>
<p>在模块里定义的常量可以在程序的任何地方所读取，所以也称为 &quot;全局常量&quot;，示例：</p>
<pre><code class="language-js">名称空间 main
    函数 结果&lt;单元, 错误&gt; 第二个测试 ()
        导入 http::client::ResponseCode # 导入语句可以写在任何地方

        书写行 (ResponseCode::Ok) # 输出 &quot;200&quot;
        书写行 (ResponseCode::NotFound) # 输出 &quot;404&quot;
    以上
名称空间
</code></pre>
<pre><code class="language-js">namespace main
    function Result&lt;Unit, Error&gt; secondTest ()
        import http.client.ResponseCode # Import statements can be written anywhere

        writeLine (ResponseCode::Ok) # output &quot;200&quot;
        writeLine (ResponseCode::NotFound) # output &quot;404&quot;
    end
end
</code></pre>
<p>注意：</p>
<!--
* 导入全局常量时必须整组导入，不能只导入单独一个值，比如 `import http.client.ResponseCode` 是对的，但 `import http.client.ResponseCode.Ok` 是错误的。-->
<ul>
<li>常量组的组名不是一种数据类型，不能作为变量或者参数的数据类型，它仅仅是名称空间的一部分而已。</li>
</ul>
<!--
* 常量的值只能是基本的数据类型，或者结构体、联合体使用默认构造函数创建的实例，不能是一个表达式，即常量的右值不能是一表达式，比如一个函数的返回值。-->
<!--### 局部常量 -->
<p>常量也可以在函数范围内定义，<!--比如有时可能只想在某一个函数里要一个严格只读的值，而不是想定义全局常量，--> 比如想定义一个临时的常量（即在地方地方用不着的常量）给模式匹配使用，对于在函数范围内定义的常量，就不能定义常量组了 <!--，可以不需要定义为一个组，即支持使用一个名称定义一个常量，语法：--></p>
<p>示例：</p>
<pre><code class="language-js">function test()
    const Good = 100
    match s
        case Good: writeLine(&quot;Good&quot;)
        case _: writeLine(&quot;Other&quot;)
    end
end
</code></pre>
<p>注意在模式匹配中，不能使用变量来代替常量：</p>
<pre><code class="language-js">function test()
    let Good = 100
    match s
        case Good: writeLine(&quot;Good&quot;) # 这里的 Good 将会是一个新的变量，其值等于变量 s
        case _: writeLine(&quot;Other&quot;) # 这行永远不会被执行
    end
end
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="data-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="data-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
