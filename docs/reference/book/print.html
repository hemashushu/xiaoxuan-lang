<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The XiaoXuan Language Reference</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">介绍</a></li><li class="chapter-item expanded "><a href="data-types.html"><strong aria-hidden="true">1.</strong> 数据类型</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">2.</strong> 变量</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">3.</strong> 函数</a></li><li class="chapter-item expanded "><a href="collection.html"><strong aria-hidden="true">4.</strong> 数据容器</a></li><li class="chapter-item expanded "><a href="structs-and-unions.html"><strong aria-hidden="true">5.</strong> 结构体和联合体</a></li><li class="chapter-item expanded "><a href="control-flow.html"><strong aria-hidden="true">6.</strong> 流程控制</a></li><li class="chapter-item expanded "><a href="pattern.html"><strong aria-hidden="true">7.</strong> 模式</a></li><li class="chapter-item expanded "><a href="method-and-generic-and-trait.html"><strong aria-hidden="true">8.</strong> 方法、范型和特性</a></li><li class="chapter-item expanded "><a href="error-handing.html"><strong aria-hidden="true">9.</strong> 错误处理</a></li><li class="chapter-item expanded "><a href="chain.html"><strong aria-hidden="true">10.</strong> 链式调用</a></li><li class="chapter-item expanded "><a href="interface-and-components.html"><strong aria-hidden="true">11.</strong> 接口和元组件</a></li><li class="chapter-item expanded "><a href="package-and-modules.html"><strong aria-hidden="true">12.</strong> 包和模块</a></li><li class="chapter-item expanded "><a href="stream.html"><strong aria-hidden="true">13.</strong> 流</a></li><li class="chapter-item expanded "><a href="io.html"><strong aria-hidden="true">14.</strong> I/O</a></li><li class="chapter-item expanded "><a href="mutable.html"><strong aria-hidden="true">15.</strong> 可变性</a></li><li class="chapter-item expanded "><a href="parallel-and-concurrency.html"><strong aria-hidden="true">16.</strong> 并行和并发</a></li><li class="chapter-item expanded "><a href="annonations.html"><strong aria-hidden="true">17.</strong> 标注</a></li><li class="chapter-item expanded "><a href="unit-test.html"><strong aria-hidden="true">18.</strong> 单元测试</a></li><li class="chapter-item expanded "><a href="comments-and-documents.html"><strong aria-hidden="true">19.</strong> 注释和文档</a></li><li class="chapter-item expanded "><a href="cn-spec.html"><strong aria-hidden="true">20.</strong> 中文文法</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The XiaoXuan Language Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="data-types.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a>
<ul>
<li><a href="data-types.html#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基本数据类型</a>
<ul>
<li><a href="data-types.html#%E6%95%B4%E6%95%B0">整数</a></li>
<li><a href="data-types.html#%E8%87%AA%E7%84%B6%E6%95%B0">自然数</a></li>
<li><a href="data-types.html#%E5%AE%9E%E6%95%B0">实数</a></li>
<li><a href="data-types.html#%E9%80%BB%E8%BE%91">逻辑</a></li>
<li><a href="data-types.html#%E5%AD%97%E7%AC%A6">字符</a></li>
</ul>
</li>
<li><a href="data-types.html#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">内置数据类型</a>
<ul>
<li><a href="data-types.html#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>
<ul>
<li><a href="data-types.html#%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E8%A1%8C">长字符串分行</a></li>
<li><a href="data-types.html#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2">模板字符串</a>
<ul>
<li><a href="data-types.html#%E5%A4%9A%E8%A1%8C%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2">多行模板字符串</a></li>
<li><a href="data-types.html#%E8%87%AA%E5%8A%A8%E6%88%AA%E9%99%A4%E5%89%8D%E7%BC%80%E7%A9%BA%E7%99%BD">自动截除前缀空白</a></li>
</ul>
</li>
<li><a href="data-types.html#%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2raw-string">原始字符串（Raw String）</a>
<ul>
<li><a href="data-types.html#%E5%A4%9A%E8%A1%8C%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2">多行原始字符串</a></li>
<li><a href="data-types.html#%E8%87%AA%E5%8A%A8%E6%88%AA%E9%99%A4%E5%89%8D%E7%BC%80%E7%A9%BA%E7%99%BD-1">自动截除前缀空白</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="data-types.html#%E6%95%A3%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2">散列字符串</a></li>
<li><a href="data-types.html#%E6%AD%A3%E5%88%99">正则</a></li>
<li><a href="data-types.html#%E6%9C%89%E7%90%86%E6%95%B0">有理数</a></li>
<li><a href="data-types.html#%E5%A4%8D%E6%95%B0">复数</a></li>
<li><a href="data-types.html#%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a></li>
<li><a href="data-types.html#%E7%AC%A6%E5%8F%B7%E5%BE%85%E6%8C%AA%E8%B5%B0%E6%8C%AA%E5%88%B0-%E6%A0%87%E5%87%86%E5%BA%93-%E6%95%B0%E5%AD%A6%E5%BA%93-%E9%87%8C">符号(::待挪走，挪到 “标准库-数学库” 里)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->
<h2 id="基本数据类型"><a class="header" href="#基本数据类型">基本数据类型</a></h2>
<p>基本数据类型就是虚拟机（VM）能直接处理的数据类型。XiaoXuan 虚拟机只支持整型和浮点型两种，具体类型有：i8,i16,i32,i64,u8,u16,u32,u64 以及 f32, f64，XiaoXuan 的数据类型系统都是建筑于这些数据类型基础之上。</p>
<h3 id="整数"><a class="header" href="#整数">整数</a></h3>
<p>整数的数据类型有：</p>
<ul>
<li><code>整数64</code>（<code>Int64</code>）</li>
<li><code>整数32</code>（<code>Int32</code>）</li>
<li><code>整数16</code>（<code>Int16</code>）</li>
<li><code>整数8</code>（<code>Int8</code>）</li>
<li><code>整数</code>（<code>Int</code>），为 <code>整数64</code> 的别名。</li>
</ul>
<p>类型后面的数字表示位宽，位宽决定能存储数字的范围，整数类型的比特（bit）最高有效位（MSB）用于表示符号（正负号），所以有一半用于表示负数，有一半表示正数。另外所有位全 1 表示 -1，所以负数的个数会比整数多 1 个，另外所有位全 0 表示 0 一般会跟正数一起用于表达无符号整数（即自然数）。</p>
<p>比如 8 位整数 <code>整数8</code> 能表示：</p>
<ul>
<li>(-2^7) 到 (-1) 共 128 个数；</li>
<li>(0) 到 (+2^7 - 1) 共 128 个数。</li>
</ul>
<p>加在一起总共能表示 (2^8) 即 256 个数。</p>
<p>整数的字面量（literals，即直接写在源码里的数据，硬编码数据）如 <code>123</code>，<code>1000</code> 等，默认类型是 <code>整数64</code>，为了方便书写，XiaoXuan 为 <code>整数64</code> 起了一个别名 <code>整数</code>。</p>
<p>XiaoXuan 支持的整数字面量写法如下：</p>
<ul>
<li>支持在<strong>数字之间</strong>任意位置或者<strong>末尾</strong>插入任意数量下划线以表示分组，如 <code>123_000</code>，<code>4_56_7</code>，<code>12_34__56___</code> 等都是有效的整数字面量，但 <code>_123</code> 不是有效的整数字面量。</li>
<li>支持添加前缀 <code>0x</code>, <code>0b</code>，分别表示 16 进制和 2 进制，如 <code>0xff0011</code>，<code>0b1010</code>，<code>0b0000_1111</code>、<code>0x_a__b___c</code>。</li>
<li>支持汉字数字，包括“正负零一二三四五六七八九十点”，比如 <code>三点一四</code>，<code>一二三四</code>。</li>
</ul>
<h3 id="自然数"><a class="header" href="#自然数">自然数</a></h3>
<p>除了能表示正负数的整数类型（即有符号整数），还有只能表示正整数和零的，这种类型叫做无符号整数（Unsigned Integer），为简单起见 XiaoXuan 把该数据类型命名为 <code>自然数</code>（<code>Natural</code>）：</p>
<ul>
<li><code>自然数64</code>（<code>Natural64</code>）</li>
<li><code>自然数32</code>（<code>Natural32</code>）</li>
<li><code>自然数16</code>（<code>Natural16</code>）</li>
<li><code>自然数8</code>（<code>Natural8</code>）</li>
<li><code>自然数</code>（<code>Natural</code>），为 <code>自然数64</code> 的别名。</li>
</ul>
<p>自然数的所有比特位都用于表示数值，所以能表示 (2^N) （N 为位宽） 个数字。比如 8 位自然数 <code>自然数8</code> 能表示 0 到 (2^8) 即 256 共 256 个数字。</p>
<p>XiaoXuan 有一个动态的别名 <code>字宽</code>（<code>WordWidth</code>），它会根据机器的环境自动选择 <code>自然数64</code> 或者 <code>自然数32</code>。</p>
<h3 id="实数"><a class="header" href="#实数">实数</a></h3>
<p>在 XiaoXuan 中，实数是指一定有小数部分的实数，一般也称为浮点数（Float）。实数的数据类型有：</p>
<ul>
<li><code>实数64</code>（<code>Real64</code>）</li>
<li><code>实数32</code>（<code>Real32</code>）</li>
<li><code>实数</code>（<code>Real</code>） （为 <code>实数64</code> 的别名）。</li>
</ul>
<p>实数字面量如 <code>3.14159</code>、<code>2.71828</code>、<code>123.4</code>、<code>1.23e4</code>、<code>-1.23e4</code>、<code>1.23e-4</code>，默认类型为 <code>实数</code>，即 <code>实数64</code>。</p>
<p>可以在字面量前面添加括号和类型名称以指定数据的类型，比如 <code>(Real32)321</code> 表示 <code>实数32</code> 类型。</p>
<p>XiaoXuan 支持的实数字面量写法如下：</p>
<ul>
<li>支持在<strong>数字之间</strong>任意位置或者<strong>末尾</strong>插入任意数量下划线以表示分组，如 <code>1_234.56</code>、<code>12_.34__</code> 都是有效的实数字面量，但 <code>_12.34</code>、<code>12._34</code> 都不是有效的实数字面量。</li>
<li>支持 <a href="https://en.wikipedia.org/wiki/IEEE_754-2008_revision">IEEE 745-2008 标准</a>，实数包含正无穷、负无穷、正零、负零、还有一个 NaN（非数字）。正无穷 == 正无穷，负无穷 == 负无穷，NaN 跟任何数比较都不相等，包括跟自己比较也是不相等，即 NaN != NaN，而 (NaN != x) 总是返回 true。详细见 <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 745</a> 和 <a href="https://en.wikipedia.org/wiki/NaN">NaN</a>。</li>
</ul>
<h3 id="逻辑"><a class="header" href="#逻辑">逻辑</a></h3>
<p>逻辑数据只有两个值：<code>真</code>（<code>true</code>）和 <code>假</code>（<code>false</code>），逻辑数据的数据类型是 <code>逻辑</code>（<code>Boolean</code>）。逻辑数据一般用在条件语句，用于判断条件是否成立。</p>
<p>XiaoXuan 不支持逻辑数据跟数字（整数、自然数、实数等）相互转换，也不支持跟字符、字符串、列表等等任何数据类型相互转换。有些编程语言用 0 表示 <code>假</code>，用非 0 表示 <code>真</code>，或者空字符串、空列表表示 <code>假</code>，非空字符串、非空列表表示 <code>真</code> 等等，XiaoXuan 皆不支持，也就是说条件语句只接受逻辑类型的值。</p>
<p>示例：</p>
<pre><code class="language-julia">让 i = 123
如果 i 那么 # 这行会引起运行时错误
    ...
以上
</code></pre>
<p>在运行环境内部使用 <code>整数</code> 表示逻辑型数值，其中整数 <code>0</code> 表示 <code>false</code>，整数 <code>1</code> 表示 <code>true</code>。</p>
<p>逻辑数据类型是一种枚举类型，完整的值是 <code>Boolean::True</code> 和 <code>Boolean::False</code>，而 <code>true</code> 和 <code>false</code> 是关键字，在编译时会被自动替换为完整的值。</p>
<h3 id="字节"><a class="header" href="#字节">字节</a></h3>
<p><code>字节</code>（<code>Byte</code>） 是 <code>Natural8</code> 类型的别称。</p>
<h3 id="字符"><a class="header" href="#字符">字符</a></h3>
<p>字符是用于存储单个字母、数字或者汉字等一个单独的 Unicode 码点，字符的数据类型是 <code>字符</code>（<code>Char</code>），<!-- 字符字面量使用一对单引号包围一个字符（TODO::考虑使用 `\C"` 格式），比如 `'a'`, `'8'`, `'中'` 等。--> 字符字面量使用 <code>\</code> 符号前导表示，比如：<code>\a</code>, <code>\8</code>, <code>\中</code></p>
<p>有些字符无法用直接字面量表示，需要使用特殊的方式来表示，具体来说是使用一个反斜杠加一个字符的方式来转义。这些字符有：</p>
<ul>
<li><code>\t</code>：制表符 ASCII 9</li>
<li><code>\n</code>：换行符 ASCII 10</li>
<li><code>\r</code>：回车符 ASCII 13</li>
<li><code>\\</code>：反斜杠</li>
</ul>
<!-- * `'\''`：单引号 -->
<p>字符在运行环境内部使用 <code>自然数32</code>（<code>Natural32</code>） 来处理（即，在内存中的表示方式），但不是 <code>自然数32</code> 类型的别称，因为部分整数不是有效的 Unicode 码点，有效的 Unicode 码点范围是从 U+0000 到 U+D7FF 以及从 U+E0000 到 U+10FFFF。字符类型不能跟 <code>自然数32</code> 或者其他整数类型直接相互参与运算或者转换。</p>
<p>字符字面量也支持使用 8 bit 字符编码和 16 进制的 Unicode 码点表示：</p>
<ul>
<li><code>\xHH</code>（H 不区分大小写）：用于表示从 U+0000 到 U+007F 之间的字符，比如 <code>\x3A</code>；</li>
<li><code>\u{H}</code> ~ <code>\u{HHHHHH}</code>（H 不区分大小写）：用于表示从 U+0000 到 U+D7FF 以及从 U+E0000 到 U+10FFFF 之间的字符，比如 <code>\u{42}</code>。</li>
</ul>
<p>注意不支持类似 JavaScript 的 <code>\uHHHH</code> 表示方法。</p>
<p>字符字面量还支持希腊字母，比如：</p>
<ul>
<li><code>\alpha</code> 表示 α</li>
<li><code>\beta</code> 表示 β</li>
<li><code>\psi</code> 表示 ψ</li>
<li><code>\omega</code> 表示 ω</li>
</ul>
<p>希腊字符也可以通过常量 <code>希腊字母</code>（<code>GreekLetter</code>） 获取，比如 <code>GreekLetter.alpha</code> 的值为 (\alpha)，即字符 'α'，<code>GreekLetter.omega</code> 的值为 (\omega)，即字符 'ω'。详细可以参见<a href="https://en.wikipedia.org/wiki/Greek_alphabet">希腊字母列表</a>，以及希腊字母对应的<a href="https://zh.wikipedia.org/zh-cn/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D">中文读音</a>。</p>
<p>需要注意的是，一个 <code>字符</code> 类型数值只能表示 Unicode 上的一个码点，但视觉上的 &quot;一个字&quot; （有时也称为 <code>符文</code>、<code>rune</code>，或者称为 <code>字素</code>、<code>Grapheme</code>） 有时是由多个 <code>字符</code> 类型数值合在一起表示的，比如国旗符号 🇨🇳，它由 2 个 Unicode 码点 （U+1F1E8 U+1F1F3） 表示，又比如家庭符号 👨‍👩‍👧‍👦，它由 7 个 Unicode 码点（U+1F468 U+200D U+1F469 U+200D U+1F467 U+200D U+1F466）表示。在显示、编辑（比如移动光标）及打印文本时，应该以 <code>字素</code> 而不是一个 Unicode 码点作为 &quot;一个字&quot; 的单位，具体见 <a href="https://en.wikipedia.org/wiki/Unicode">Unicode 标准</a>。</p>
<blockquote>
<p>错误的 Unicode 码点将以符文 U+FFFD 来代替。</p>
</blockquote>
<h2 id="内置数据类型"><a class="header" href="#内置数据类型">内置数据类型</a></h2>
<p>内置数据类型即标准库里一部分数据类型，它们建筑在基本数据类型基础之上，是 XiaoXuan 语言层级直接支持的数据类型。</p>
<h3 id="字符串"><a class="header" href="#字符串">字符串</a></h3>
<p>字符串即一系列字符，也就是常说的文本，字符串类型为 <code>字符串</code>（<code>String</code>），字符串字面量使用双引号（&quot;）包围一串字符，如 <code>&quot;abc&quot;</code>，<code>&quot;你好&quot;</code>。字符串字面量必须在一行之内写完，不能分成多行。</p>
<p>在字符串字面量里，有些字符也是需要转义，这些字符有：</p>
<ul>
<li><code>&quot;\t&quot;</code>：制表符</li>
<li><code>&quot;\n&quot;</code>：换行符</li>
<li><code>&quot;\r&quot;</code>：回车符</li>
<li><code>&quot;\\&quot;</code>：反斜杠</li>
<li><code>&quot;\&quot;&quot;</code>：双引号（单引号不需要转义）</li>
</ul>
<p>在运行环境内部，<code>字符串</code> 使用 <code>数组&lt;字节&gt;</code> （<code>Array&lt;Byte&gt;</code>）存储，也就是说 <code>字符串</code> 类型实际上是对 <code>数组&lt;字节&gt;</code> 做了一层薄薄的包装（之所以需要包装，是因为在诸如 first(), each 等运算时，必须以 Unicode 码点作为单位）。一个字符串会使用 UTF-8 编码为一系列的 Byte 数组，跟一般 C 的字符串不同，XiaoXuan Lang 的字符串最末尾不包含 <code>\0</code> 字符。</p>
<h4 id="长字符串分行"><a class="header" href="#长字符串分行">长字符串分行</a></h4>
<p>当字符串比较长时，可以通过在行末写单独一个反斜杠符号 <code>\</code> （作分行符），表示下一行仍然是当前字符串的组成部分。注意分行符下一行的所有前缀空格符（包括制表符、换行符等）会被忽略，直到第一个非空格字符。注意这跟 JavaScript 不完全相同，JavaScript 里分行符的下一行字符串的前面空格会被包含进来。</p>
<pre><code class="language-js">let s = &quot;hello \
         world \
           foo\
           bar&quot;

s == &quot;hello world foobar&quot;
</code></pre>
<h4 id="模板字符串"><a class="header" href="#模板字符串">模板字符串</a></h4>
<p>模板字符串是指允许在字符串中间插入其他数据的字符串，模板字符串同样使用 &quot;<code>...</code>&quot; 符号（即一对反单斜杠）包围。</p>
<p>示例：</p>
<pre><code class="language-js">让 name = &quot;张三&quot;
让 s1 = `你好, {name}`
</code></pre>
<pre><code class="language-js">let name = &quot;foo&quot;
let s1 = `hello, {name}`
</code></pre>
<p>其中 <code>{...}</code> 为模板字符串占位符，占位符里面可以是其他数据的字面量，可以是一个上下文存在的变量，<!-- ::TODO:: 暂时不考虑表达式，实现起来有难度:: 也可以是一个表达式，甚至可以是一段有返回值的语句 只要返回一个字符串即可。--></p>
<p>模板占位符支持格式化，在数据之后添加一个冒号 <code>:</code>，然后加上格式表达式。</p>
<p>示例：</p>
<ul>
<li><code>{name:15}</code>：name 是一个字符串变量，表示字符串最小宽度为 15 个字符（不足 15 个字符会在右侧补空格）；</li>
<li><code>{name:.6}</code>：name 是一个字符串变量，表示限制字符串最大宽度为 6 个字符，超出 6 个的字符直接被截除。</li>
</ul>
<p>XiaoXuan 支持大部分 Rust 字符串格式化格式，可以参考《Programming Rust》 P337 &quot;格式化值&quot; 一节。（同时也参考 https://docs.python.org/3/library/string.html#format-string-syntax）</p>
<p>在模板字符串字面量里，有些字符也是需要转义，这些字符有：</p>
<ul>
<li><code>&quot;\t&quot;</code>：制表符</li>
<li><code>&quot;\n&quot;</code>：换行符</li>
<li><code>&quot;\r&quot;</code>：回车符</li>
<li><code>&quot;\\&quot;</code>：反斜杠</li>
<li><code>&quot;\</code>&quot;`：反单引号（双引号、单引号不需要转义）</li>
<li><code>&quot;\{&quot;</code>：左花括号</li>
<li><code>&quot;\}&quot;</code>：右花括号</li>
</ul>
<h5 id="多行模板字符串"><a class="header" href="#多行模板字符串">多行模板字符串</a></h5>
<p>模板字符串跟普通字符串一样，也允许使用分行符（即位于行末的单独一个反斜杠符号 <code>\</code>）写成多行。不过模板字符串还支持直接写成多行，直到遇到一个没有转义的反单引号才表示模板字符串结束。</p>
<p>示例：</p>
<pre><code class="language-js">let html =
    `&lt;div class=&quot;item&quot; data-id=&quot;{item.id}&quot;&gt;
       &lt;div class=&quot;id&quot;&gt;{item.id}&lt;/div&gt;
       &lt;div class=&quot;name&quot;&gt;{item.name}&lt;/div&gt;
     &lt;/div&gt;`
</code></pre>
<blockquote>
<p>模板字符串会保留所有换行符和空白字符。</p>
</blockquote>
<h5 id="自动截除前缀空白"><a class="header" href="#自动截除前缀空白">自动截除前缀空白</a></h5>
<p>在第一个单反斜杠后面换行，则第一行正文前缀的空白将会被截除（trim），正文其他行的前缀空白将会按照第一行的前缀空白数量自动截除。</p>
<p>示例：</p>
<pre><code class="language-js">01  let html =`
02      &lt;div class=&quot;item&quot; data-id=&quot;{item.id}&quot;&gt;
03        &lt;div class=&quot;id&quot;&gt;{item.id}&lt;/div&gt;
04        &lt;div class=&quot;name&quot;&gt;{item.name}&lt;/div&gt;
05      &lt;/div&gt;`
</code></pre>
<p>上面 02 行为正文开始行，它前面的 4 个空白将会被截除，从第 03 行开始到 05 行都是正文，每行前面都会被截除 4 个空白。</p>
<h5 id="自定义处理模板字符串的函数"><a class="header" href="#自定义处理模板字符串的函数">自定义处理模板字符串的函数</a></h5>
<p>模板字符串默认返回的是模板字面量和其中的占位符的值所连接起来的字符串，其实也可以指定处理的函数，只需在模板字符串字面量前面加上函数名称即可。模板字符串字面量实际上返回的是两个数组：一个是字符串字面量，另一个是占位符表达式。如果字面量没有指定处理字符串，则默认处理函数为 <code>std::String::template</code>。</p>
<p>示例：</p>
<pre><code class="language-js">let foo = &quot;cat&quot;
let bar = &quot;dog&quot;
let s = someFunc `hello {foo} world {dog:5}`
</code></pre>
<p>会转换为：</p>
<pre><code class="language-js">let foo = &quot;cat&quot;
let bar = &quot;dog&quot;
let s = someFunc ([&quot;hello &quot;, &quot; world&quot;],[foo, String::paddingRight(dog, 5)])
</code></pre>
<p>上例中的 <code>someFunc</code> 为自定义的模板字符串处理函数，只要参数是两个 <code>String</code> 数组类型的函数都可以作为处理函数，函数的功能和返回值没有限制。</p>
<p>可以在模板字符串后面加入一个值，用于向模板处理函数传入数据，这种情况下 XiaoXuan 将不会解析模板字符串的内容，而是完全由模板字符串自己处理，比如 <code>handlebars</code> 函数：</p>
<pre><code class="language-js">let data = JsonMap {
    user: [&quot;foo&quot;,&quot;bar&quot;]
    };

let s = handlebars `
    &lt;ul class=&quot;people_list&quot;&gt;
      {{#each people}}
          &lt;li&gt;{{this}}&lt;/li&gt;
      {{/each}}
    &lt;/ul&gt;` data
}
</code></pre>
<p>XiaoXuan 运行时调用 handlebars 如下：</p>
<pre><code class="language-js">let s = handlebars(text, data)
</code></pre>
<p>其中 <code>text</code> 是在处理转义字符和截除前缀空白后的字符串，它将会连同 <code>data</code> 参数传递给 handlebars 函数。</p>
<p>更多的 Handlebars 语法请参阅：<a href="https://handlebarsjs.com/">handlebarsjs</a></p>
<h4 id="原始字符串raw-string"><a class="header" href="#原始字符串raw-string">原始字符串（Raw String）</a></h4>
<p>原始字符串即原样表示的字符串，在源码当中原始字符串是怎样的呈现，其值就是怎样。即原始字符串不会对其中的内容进行转义。</p>
<p>原始字符串字面量使用三个双引号包围一串字符。</p>
<p>示例：</p>
<ul>
<li><code>&quot;&quot;&quot;你好\😄/&quot;&quot;&quot;</code></li>
<li><code>&quot;&quot;&quot;hello\😄/&quot;&quot;&quot;</code></li>
</ul>
<p>在书写正则表达式时，使用原始字符串能避免频繁转义表达式内部的特殊字符。</p>
<p>示例：</p>
<pre><code class="language-js">01  # 为了匹配类似 `\&quot;123&quot;/` 这样的字符串
02  let s1 = Regex(&quot;^\\\\\\&quot;\\d{3}\\&quot;\/$&quot;)
03  let s2 = Regex(&quot;&quot;&quot;^\\&quot;\d{3}&quot;\/$&quot;&quot;&quot;)
</code></pre>
<p>上面例子中 02 行使用普通字符串格式，03 行使用原始字符串格式，它们的值相同。</p>
<h5 id="多行原始字符串"><a class="header" href="#多行原始字符串">多行原始字符串</a></h5>
<p>原始字符串允许直接写成多行，直到遇到连续的三个双引号才表示结束。</p>
<p>示例：</p>
<pre><code class="language-js">01  让 s = &quot;&quot;&quot;第一行
02      第二行
03      第三行&quot;&quot;&quot;
</code></pre>
<pre><code class="language-js">01  let s = &quot;&quot;&quot;line one
02      line two
03      line three&quot;&quot;&quot;
</code></pre>
<p>其值为 <code>&quot;第一行\n🈳🈳🈳🈳第二行\n🈳🈳🈳🈳第三行&quot;</code></p>
<h5 id="自动截除前缀空白-1"><a class="header" href="#自动截除前缀空白-1">自动截除前缀空白</a></h5>
<p>在第一个三双引号后面换行，则正文部分的第一行（即上面例子的 02 行）的第一个非空白字符表示正文的开始，正文部分其他行的前缀空白字符会根据正文第一行的前缀空白个数<strong>自动截除</strong>（空白字符不足的话则只截除实际个数空白）。</p>
<pre><code class="language-js">01  让 s = &quot;&quot;&quot;
02      世界
03        你好&quot;&quot;&quot;
</code></pre>
<pre><code class="language-js">01  let s = &quot;&quot;&quot;
02      hello
03        world&quot;&quot;&quot;
</code></pre>
<p>上面示例的字符串的值为 <code>世界\n🈳🈳你好</code>（<code>&quot;hello\n🈳🈳world&quot;</code>）。</p>
<h4 id="文本-text"><a class="header" href="#文本-text">文本 <code>Text</code></a></h4>
<p>为了方便索引访问字符，标准库还内置了一个叫 <code>文本</code>（<code>Text</code>） 的字符串类型，它其实是 <code>数组&lt;字符&gt;</code>（<code>Array&lt;Char&gt;</code>）的别称，它有跟 <code>String</code> 一样的接口，两者可以相互转换。</p>
<h3 id="散列字符串"><a class="header" href="#散列字符串">散列字符串</a></h3>
<p>因为字符串常用于映射表的键，但 <code>字符串</code> 类型 <!-- 只是 `数组<字符>`（`Array<Char>`）的别称，--> 缺少散列值，所以使用字符串作为映射表的键时，可以使用 <code>散列字符串</code>（<code>HashString</code>）。<code>散列字符串</code> 基本上跟 <code>字符串</code> 一模一样，只不过在构造时自动计算了一个散列值。</p>
<p>示例：</p>
<pre><code class="language-js">让 map1 = 新建 映射表&lt;HashString, Int&gt;()
让 key1 = 新建 HashString(&quot;abc&quot;)
让 map2 = map1.添加(key1, 100)
让 value1 = map2[key1]  // value1 == 100
</code></pre>
<p>散列字符串的字面量是使用 <code>#</code> 前导的一个字符串组成。</p>
<p>示例：</p>
<pre><code class="language-js">让 key1 = #abc
让 key2 = #foo
让 key3 = #abc

断定(key1 != key2)
断定(key1 == key3)
</code></pre>
<p>如果字符串里面含有诸如空格，标点符号等，则可以使用双引号包围起来。</p>
<p>示例：</p>
<pre><code class="language-js">let key1 = #&quot;foo bar&quot;
let key2 = #&quot;hello \&quot; world!&quot;
</code></pre>
<p>散列字符串依据其字符串本身所计算的散列值进行相等或者大小比较，使用散列字符串字面量时，无需事先赋值给一个变量，可以直接使用。</p>
<p>下面使用散列字符串重写前一个示例：</p>
<pre><code class="language-js">让 map1 = 新建 映射表&lt;HashString, Int&gt;()
让 map2 = map1.添加(#abc, 100)
让 value1 = map2[#abc]
</code></pre>
<h3 id="正则"><a class="header" href="#正则">正则</a></h3>
<p>字面量格式 <code>/正则表达式/</code></p>
<pre><code class="language-js">let r1 = /[a-zA-Z]+/
let m1 = r1.match(&quot;hello world&quot;);
</code></pre>
<p>正则构造函数 <code>Regex(String, Options)</code> 和 <code>Regex(Regex, Options)</code>，用于构造带有选项的正则对象。</p>
<p>// TODO::</p>
<p>也可以使用正则表达式生成器构造正则对象，示例：</p>
<pre><code class="language-js">use RegBuilder::new as rb

let r1 = rb()
    .startOfLine()
    .then(\[)
    .or(
        rb(&quot;http&quot;),
        rb(&quot;https&quot;)
    )
    .then(&quot;://&quot;)
    .group(
        rb()
            .oneOrMore(RegBuilder::notSpace)
    )
    .maybe(
        rb(RegBuilder::space)
            .then(\&quot;)
            .oneOrMore(RegBuilder::Any)
            then(\&quot;)
    )
    .then(\])
    .endOfLine()
    .build()

// equals to:

let r2 = /^\[(http|https):\/\/(\S+)( &quot;.+&quot;)?\]$/
</code></pre>
<p>类似的工具：
https://github.com/VerbalExpressions/JSVerbalExpressions</p>
<h3 id="有理数"><a class="header" href="#有理数">有理数</a></h3>
<p>有理数的数据类型是 <code>有理数</code>（<code>Rational</code>）。字面量使用符号 <code>'/</code> 分隔分子和分母，分子和分母必须是整数（对应 XiaoXuan 的 <code>整数</code> 和 <code>自然数</code> 这两种类型）。</p>
<p>::TODO
可以考虑 数字+r 的表示方法，类似：2r / 3，与复数的表示方法一致（如 2 + 3i）</p>
<p>示例：</p>
<pre><code class="language-julia">让 i = 2r / 3
让 j = 1r / 2
让 k = i + j        # k == 7r / 6
</code></pre>
<pre><code class="language-julia">let i = 2r / 3
let j = 1r / 2
let k = i + j        # k == 7r / 6
</code></pre>
<p>符号 <code>\</code> 前后的空格可有可无。</p>
<p>有理数也可以使用构造函数构建：</p>
<pre><code class="language-julia">让 i = 有理数(2, 3)  # 2r / 3
让 j = 有理数(1, 2)  # 1r / 2
让 k = i + j        # k == 7r / 6
</code></pre>
<pre><code class="language-julia">let i = Rational(2, 3)  # 2r / 3
let j = Rational(1, 2)  # 1r / 2
let k = i + j        # k == 7r / 6
</code></pre>
<p>为了避免分子分母跟表达式的其他数据混淆，可以使用一对括号把有理数包围起来。</p>
<p>示例：</p>
<p><code>let i = (2r / 3) / 2</code></p>
<p>实际上符号 <code>/</code> 是运算符，所以该符号前后可以是字面量，也可以是变量。</p>
<p>示例：</p>
<pre><code class="language-julia">let i = 123
let j = 456
let k = i \ j  # k == 123\456
</code></pre>
<h3 id="复数"><a class="header" href="#复数">复数</a></h3>
<p>复数的数据类型是 <code>复数</code>（<code>Complex</code>），字面量使用格式 <code>X + Yi</code> 的格式表示，其中的 <code>+</code> 和 <code>i</code> 是固定格式，<code>X</code> 和 <code>Y</code> 是实数，分别表示复数的实部和虚部，对于 XiaoXuan 来说，<code>X</code> 和 <code>Y</code> 可以是 <code>整数</code>、<code>自然数</code> 或者 <code>实数</code> 的字面量。</p>
<p>示例：</p>
<pre><code class="language-julia">let i = 3+4i
let j = 1+4i
let k = i+j     # k == 4+8i
</code></pre>
<p>其中实部可以省略，表示实部为 0 的纯虚数。</p>
<p>示例：</p>
<pre><code class="language-julia">let i = 4i
let j = 3.45i
</code></pre>
<p>需要注意的是，复数字面量当中的符号 <code>+</code> 不表示加法，而是固定的格式，也就是说实部和虚部的数字都必须是字面量，而不能是变量。</p>
<p>示例：</p>
<pre><code class="language-julia">let n = 123
let i = n + 4i  # `+` 号前面不是数字字面量
let j = 4 + ni  # `i` 前面不是数字字面量
</code></pre>
<p>上面例子都无法构建出复数。</p>
<p>复数也可以使用构造函数构建。</p>
<p>示例：</p>
<pre><code class="language-julia">let i = Complex(3, 4) # 3+4i
let j = Complex(1, 4) # 1+4i
let k = i+j           # k == 4+8i
</code></pre>
<p>为了避免复数的实部跟表达式的其他数据混淆，可以使用一对括号把复数字面量包围起来。</p>
<p>示例：</p>
<p><code>let i = 2 * (3+4i)</code></p>
<p>注意复数只能作相等比较而不能作大小比较，参见<a href="https://en.wikipedia.org/wiki/Complex_number">复数的介绍</a>。</p>
<h3 id="二进制"><a class="header" href="#二进制">二进制</a></h3>
<p>二进制数据类型是 <code>二进制</code>（<code>Binary</code>）。跟 <code>整数</code> 类型的二进制字面量不一样，<code>二进制</code> 是单独的一种数据类型，而 <code>整数</code> 的二进制字面量仍然是 <code>整数</code> 类型。</p>
<p><code>二进制</code> 字面量使用 <code>位宽 + 数制符号 + 数值</code> 的格式表示。</p>
<p>示例：</p>
<pre><code class="language-js">let a = 8b0000_1111 // 等同 8b1111
let b = 8h0F
let c = 8d15
</code></pre>
<p>二进制值可以使用 <code>获取</code>（<code>get</code>）函数读取每一位的值。</p>
<p>示例：</p>
<pre><code>let a = 8b0000_1111
let b1 = a.get(1)
let b2 = a.get(5)
</code></pre>
<p><code>获取</code> 函数的参数是指定比特位的位置值，二进制字面量最右边为第 1 位，即最低有效位，从 1 开始数（不是从 0 开始数）。注意位置值不能超出该二进制数值的有效范围，否则会引起运行时异常。</p>
<p>上例变量 <code>b1</code> 的值为 <code>1b0</code>，变量 <code>b2</code> 的值为 <code>1b1</code>。</p>
<p>二进制值还可以通过 <code>选取</code>（<code>slice</code>） 函数读取其中的部分值。</p>
<p>示例：</p>
<pre><code class="language-js">let a = 8'b0000_1111
let b = a.slice(3, 6)
</code></pre>
<p><code>选取</code> 函数的两个参数分别表示选择范围的开始位置值以及选取比特的数量。上例表示从二进制变量 <code>a</code> 的第 3 位开始，取 6 位比特，结果变量 <code>b</code> 的值为 <code>6'000011</code>。</p>
<p>也可以使用一对中括号 <code>[...]</code> 替代调用 <code>选取</code> 函数。</p>
<p>示例：</p>
<ul>
<li><code>让 b = a[3:6]</code></li>
<li><code>let b = a[3:6]</code></li>
</ul>
<p>结果跟上例是一样的。</p>
<p>需注意，开始位置和数量不能超出有效范围，否则会引起运行时异常。</p>
<p>二进制数还支持位运算、连接等函数，详细见语言参考手册。</p>
<h3 id="bitflag-位标记"><a class="header" href="#bitflag-位标记">BitFlag 位标记</a></h3>
<p>示例：</p>
<pre><code>bitflag OpenFlags type Int {
    Create,     // = 0b00001
    Open,       // = 0b00010
    Read,       // = 0b00100
    Write,      // = 0b01000
    Append,     // = 0b10000
}
</code></pre>
<p>除了自动编排数值，也可以手动指定</p>
<pre><code>bitflag OpenFlags type Int {
    Create = 1,
    Open, // 自动编排数值 2（即 1 &lt;&lt; 1）
    Read = 4,
    Write = 8,
    Append = 16
    ReadWrite = Read + Write, // 手动指定值为 12
    Truncate = 32, // 这里无法自动编排数值，因为上一个成员的值位数（值为 1 的比特数）不唯一
    Transite, // 自动编排数值 64
}
</code></pre>
<p>bitflag 支持 <code>+</code> 和 <code>-</code> 运算符重载，表示 <code>a :bitOr: b</code> 和 <code>a :bitAnd: (bitInvert(b))</code> 的意思。</p>
<p>跟 enum 类似，bitflag 也是一种类型，而非一种常量，bitflag 只能跟自己类型作 <code>+</code>、 <code>-</code> 和 <code>:in</code> 等二元运算。</p>
<h3 id="符号待挪走挪到-标准库-数学库-里"><a class="header" href="#符号待挪走挪到-标准库-数学库-里">符号(::待挪走，挪到 “标准库-数学库” 里)</a></h3>
<p><code>符号</code>（<code>Symbol</code>）类型的数据用于生成一个代号，代号可以用作代数的变量。符号类型数据没有字面量，只能通过构造函数构建。</p>
<p>示例：</p>
<pre><code class="language-js">让 x = 符号('x')
让 x_alt = 符号(&quot;x'&quot;)
让 x1 = 符号(&quot;x1&quot;)
让 y = 符号('y')
</code></pre>
<pre><code class="language-js">let x = Symbol('x')
let x_alt = Symbol(&quot;x'&quot;)
let x1 = Symbol(&quot;x1&quot;)
let y = Symbol('y')
</code></pre>
<p><code>符号</code> 构造函数接受一个字符或者一个字符串，上面代码分别生成了符号 (x)，(x')，(x1) 和 (y)。</p>
<p>常数 <code>希腊字母符号</code>（<code>GreekLetterSymbol</code>） 列出了从 α 到 ω 的 <code>符号</code> 实例。比如 <code>GreekLetterSymbol.beta</code> 的值为 <code>Symbol('β')</code>。</p>
<p>符号实例可以通过 <code>下标</code>（<code>subscript</code>）方法添加下标。</p>
<p>示例：</p>
<pre><code class="language-js">let a = Symbol('a')
let a1 = a.subscript('1')
</code></pre>
<p>变量 <code>a1</code> 的值就是 (a_1)，注意它的值跟由字符串 <code>a1</code> 构成的符号实例是不相同的。</p>
<p>构造时传入相同的字符或者字符串而产生的两个符号数据的值相等，符号数据的值可以用其包含的字符串表示，但不能跟字符串直接比较，也无法排序。</p>
<p>符号数据可以用于产生算式对象。</p>
<p>示例：</p>
<pre><code class="language-js">let z = x^2 + 2*x*y + y^2
</code></pre>
<p>上面例子的变量 <code>z</code> 的值为一个算式，其值为：</p>
<p>$$
z = x^2 + 2xy + y^2
$$</p>
<p>示例：</p>
<pre><code class="language-js">let x = Symbol('x')
let N = 100
let y = sum([1..N].map(fn (n) x ^ n / n))
</code></pre>
<p>上面的代码会产生如下算式：</p>
<p>$$
y = \frac{x^1}{1} + \frac{x^2}{2} + \frac{x^3}{3} + \cdots + \frac{x^n}{n}
$$</p>
<p>算式对象可以用于计算值，也可以用于解方程，求微分和积分等，可以参考 <a href="https://www.sympy.org/en/">SymPy 函数库</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="variables.html#%E5%8F%98%E9%87%8F">变量</a>
<ul>
<li><a href="variables.html#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B5%8B%E5%80%BC">变量的声明和赋值</a>
<ul>
<li><a href="variables.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a>
<ul>
<li><a href="variables.html#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">类型推导</a></li>
<li><a href="variables.html#%E5%88%97%E8%A1%A8list">列表（List）</a></li>
<li><a href="variables.html#%E6%98%A0%E5%B0%84%E8%A1%A8map">映射表（Map）</a></li>
<li><a href="variables.html#%E5%85%83%E7%BB%84">元组</a></li>
<li><a href="variables.html#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="variables.html#%E7%B1%BB%E5%9E%8B%E7%AE%80%E5%86%99%E8%80%83%E8%99%91%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%87%BD%E6%95%B0%E4%B8%80%E7%AB%A0">类型简写（考虑移动到函数一章）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="variables.html#%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D">定义数据类型别名</a></li>
<li><a href="variables.html#%E5%AD%97%E9%9D%A2%E4%B8%A4%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2">字面两类型的自动（隐式）转换</a></li>
</ul>
</li>
<li><a href="variables.html#%E5%80%BC%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">值的不可变性</a></li>
<li><a href="variables.html#%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">变量的不可变性</a></li>
<li><a href="variables.html#%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%AF%E5%8F%98%E6%80%A7%E4%B8%8D%E6%94%AF%E6%8C%81">变量的可变性（::不支持）</a>
<ul>
<li><a href="variables.html#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">变量的作用域</a></li>
<li><a href="variables.html#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8D%E6%94%AF%E6%8C%81">全局变量（::不支持）</a></li>
</ul>
</li>
<li><a href="variables.html#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="variables.html#%E6%9E%9A%E4%B8%BE">枚举</a></li>
<li><a href="variables.html#%E5%80%BC%E7%9A%84%E5%A4%8D%E5%88%B6">值的复制</a></li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->
<h2 id="变量的声明和赋值"><a class="header" href="#变量的声明和赋值">变量的声明和赋值</a></h2>
<p>变量的声明和赋值需要同时进行，语法如下：</p>
<ul>
<li><code>让 数据类型 变量名称 = 值</code></li>
<li><code>let DataType name = value</code></li>
</ul>
<p>示例：</p>
<ul>
<li><code>让 整数 a = 123</code></li>
<li><code>let Int a = 123</code></li>
</ul>
<p>在 XiaoXuan 语言里，基本类型的数据是值，结构体、联合体也是值，一个函数也可以作为一个值，所以它们都可以赋值给一个变量。</p>
<p>变量名可以是大小写字母、中文（严格来说代码点大于 u{00A0} 的 Unicode 字符均可）、数字和下划线的组合，但第一个字不能是数字，变量名区分大小写。</p>
<p>::TODO</p>
<p><code>assign</code> 赋值语句：
<code>assign&lt;Int&gt;(a, 123)</code></p>
<p><code>赋予变量甲,真</code>
<code>赋予&lt;逻辑&gt;变量甲,真</code>
<code>赋予变量乙,一二三</code>
<code>赋予(整数)变量乙,一二三</code></p>
<pre><code class="language-js">赋予&lt;逻辑&gt;变量甲,真
如果变量甲:等于:真那么书写行 &quot;文本一&quot; 否则书写行 &quot;文本二&quot;
若甲:同:真则书 &quot;文一&quot; 否则书 &quot;文二&quot;
</code></pre>
<h3 id="数据类型-1"><a class="header" href="#数据类型-1">数据类型</a></h3>
<h4 id="类型推导"><a class="header" href="#类型推导">类型推导</a></h4>
<p>XiaoXuan 有类型推导机制，当值的类型可以确定的情况下，可以省略变量的数据类型声明，示例：</p>
<ul>
<li><code>让 a = 123</code></li>
<li><code>let a = 123</code></li>
</ul>
<p>变量 <code>a</code> 的数据类型会自动推导为 <code>整数</code>（<code>Int</code>）。</p>
<p>类型推导还具有传导性，函数的嵌套调用、函数的连续调用都会尽可能地推导出正确的数据类型。</p>
<p>一般情况下，对于变量声明及赋值语句：</p>
<ul>
<li>如果是字面值赋值，<strong>建议省略</strong> 变量的数据类型声明，因为数据类型显而易见，省略数据类型声明不妨碍阅读理解且会更简洁；</li>
<li>如果是接收某个函数的返回值，<strong>不建议省略</strong> 变量的数据类型声明，因为调用其他模块的函数，其返回值的数据类型不明显，加上数据类型声明能让代码更清晰。</li>
<li>如果是接收范型的函数的返回值，当范型作用在返回值类型时，可以省略变量的数据类型声明，当范型是作用在参数时，如果是实例化一个联合体，则可以省略，其他情况则不建议省略。比如 <code>Option&lt;T&gt;</code>，语句 <code>let a = Some(123)</code> 可省略类型。</li>
</ul>
<h4 id="列表list"><a class="header" href="#列表list">列表（List）</a></h4>
<p>列表字面量的数据类型由第一个元素决定，比如：</p>
<ul>
<li><code>让 a = [1, 2, 3]</code></li>
<li><code>let a = [1, 2, 3]</code></li>
</ul>
<p>列表的数据类型为 <code>列表&lt;整数&gt;</code>（<code>List&lt;Int&gt;</code>）。</p>
<ul>
<li><code>让 b = [&quot;你好&quot;, &quot;世界&quot;]</code></li>
<li><code>let b = [&quot;Hello&quot;, &quot;World&quot;]</code></li>
</ul>
<p>列表的数据类型为 <code>列表&lt;字符串&gt;</code>（<code>List&lt;String&gt;</code>）。</p>
<p>因为空列表无法进行类型推导，所以要赋值一个空列表给变量，则需要声明变量的数据类型：</p>
<ul>
<li><code>让 列表&lt;字符串&gt; b = []</code></li>
<li><code>let List&lt;String&gt; b = []</code></li>
</ul>
<p>当然这种情况下一般使用列表的构造函数来实例化一个空列表。</p>
<ul>
<li><code>让 c = 列表&lt;字符串&gt; ()</code></li>
<li><code>let c = List&lt;String&gt; ()</code></li>
</ul>
<h4 id="映射表map"><a class="header" href="#映射表map">映射表（Map）</a></h4>
<p>映射表的数据类型由第一个映射对的数据类型决定，比如：</p>
<ul>
<li><code>让 a = {姓: &quot;张&quot;, 名: &quot;三&quot;}</code></li>
<li><code>let a = {firstName: &quot;San&quot;, lastName: &quot;Zhang&quot;}</code></li>
</ul>
<p>因为第一对映射对是：<code>姓: &quot;张&quot;</code>，映射表的数据类型为 <code>映射表&lt;字符串, 字符串&gt;</code>（<code>Map&lt;String, String&gt;</code>）。</p>
<p>注意当映射表的字面量当中的键名是字符串时，是可以省略包围字符串的双引号的，所以上例实际上是下面语句的简写：</p>
<ul>
<li><code>让 a = {&quot;姓&quot;: &quot;张&quot;, &quot;名&quot;: &quot;三&quot;}</code></li>
<li><code>let a = {&quot;firstName&quot;: &quot;San&quot;, &quot;lastName&quot;: &quot;Zhang&quot;}</code></li>
</ul>
<h4 id="元组"><a class="header" href="#元组">元组</a></h4>
<p>元组可视为一个匿名成员的结构体，元组的数据类型由其中的各个元素决定，即，元组的数据类型是其各个成员的顺序和数据类型的组合。比如：</p>
<ul>
<li><code>让 a = (123, &quot;你好&quot;, 真)</code></li>
<li><code>let a = (123, &quot;Hello&quot;, true)</code></li>
</ul>
<p>则这个元组的数据类型是 <code>(整数, 字符串, 逻辑)</code>（<code>(Int, String, Boolean)</code>）</p>
<p>元组一般作为函数的参数列表，也可以作为函数的返回值。</p>
<p>作为函数的参数时，可以为元组的字面量的成员添加名称，运行环境会根据名称来找到对应的参数然后传值。示例：</p>
<ul>
<li><code>让 p = (id = 123, name = &quot;张三&quot;)</code></li>
<li><code>let p = (id = 123, name = &quot;foo&quot;)</code></li>
</ul>
<p>但语法不支持根据名称获取成员值，简单来说，元组成员的名称是只写的。</p>
<p>当一个函数的返回值不止一个数据，但又不想单独创建一个结构体来存储这个返回值时，可以简单地使用元组 &quot;封装&quot; 这些值，然后一次返回给函数的调用者。</p>
<p>有些函数可能没有任何具有意义返回值，所以专门有一个叫做 <code>单元</code>（<code>Unit</code>）的联合体（数据类型），其值有且只有一个 <code>空值</code>（<code>void</code>）。XiaoXuan 规定空元组 &quot;()&quot; 的数据类型为 <code>单元</code>，其值等于 <code>空值</code>。</p>
<h4 id="函数"><a class="header" href="#函数">函数</a></h4>
<p>函数的签名就是该函数的数据类型，比如下面的函数：</p>
<ul>
<li><code>函数 整数 增加(整数 number, 整数 amount) = number + amount</code></li>
<li><code>function Int increase(Int number, Int amount) = number + amount</code></li>
</ul>
<p>它的签名是：</p>
<ul>
<li><code>整数 &lt;- (整数, 整数)</code></li>
<li><code>Int &lt;- (Int, Int)</code></li>
</ul>
<p>其中 <code>&lt;-</code> 符号用于分隔函数返回值的数据类型以及函数的参数列表，也表示这个表达式是一个函数签名。</p>
<p>在字面上，函数的签名如同把函数的名称、参数的名称、函数主体通通全部移除之后的骨架，也就是说，函数签名只包含：</p>
<ul>
<li>函数返回值的数据类型</li>
<li>各参数的数据类型的列表</li>
</ul>
<p>有时为了便于阅读理解，也可以保留函数的签名的参数名称，比如:</p>
<ul>
<li><code>整数 &lt;- (整数 number, 整数 amount)</code></li>
<li><code>Int &lt;- (Int number, Int amount)</code></li>
</ul>
<p>对于范型（即类型参数化）函数，参数的数据类型就是范型参数，比如：</p>
<ul>
<li><code>函数 甲型 增加(甲型 source, 乙型 amount) =  source + amount</code></li>
<li><code>function T increase(T source, E amount) =  source + amount</code></li>
</ul>
<p>它的签名是：</p>
<ul>
<li><code>甲型 &lt;- (甲型, 乙型)</code></li>
<li><code>T &lt;- (T, E)</code></li>
</ul>
<p>如果一个函数的参数的数据类型是函数，则该函数的定义语句可能会很长以至于影响阅读，比如：</p>
<pre><code class="language-js">函数 返回值的数据类型 函数名称 (整数 &lt;- (整数 a, 整数 b) 参数1, ..., 字符串 &lt;- (字符串 s, 字符 c) 参数N)
    ...
以上
</code></pre>
<pre><code class="language-js">function DataType function_name (Int &lt;- (Int a, Int b) param1, ..., String &lt;- (String s, Char c) paramN)
    ...
end
</code></pre>
<h4 id="结构体"><a class="header" href="#结构体">结构体</a></h4>
<p>::TODO</p>
<pre><code class="language-js">struct User
    Int number
    String name
end

List&lt;User&gt; users = [User::new(1,&quot;foo&quot;), User::new(2, &quot;bar&quot;)]

// 可以省略列表内元素的类型，由变量声明的类型自动推导

List&lt;User&gt; users = [{1, &quot;foo&quot;}, {2, &quot;bar&quot;}]
</code></pre>
<h5 id="类型简写考虑移动到函数一章"><a class="header" href="#类型简写考虑移动到函数一章">类型简写（考虑移动到函数一章）</a></h5>
<p>XiaoXuan 语法支持 <code>类型</code>（<code>type</code>） 关键字，以允许在函数的主体之前将函数的签名定义成一个单独的名称，语法如下：</p>
<pre><code class="language-js">函数 返回值的数据类型 函数名称 (签名名称1 参数1, ..., 签名名称N 参数N) 类型
    签名名称1 = 整数 &lt;- (整数 a, 整数 b),
    签名名称N = 字符串 &lt;- (字符串 s, 字符 c)
    ...
以上
</code></pre>
<pre><code class="language-js">function DataType function_name (type1 param1, ..., typeN paramN) type
    type1 = Int &lt;- (Int a, Int b),
    typeN = String &lt;- (String s, Char c)
    ...
end
</code></pre>
<p>语法当中的 <code>类型</code>（<code>type</code>） 关键字接着一系列参数类型的声明，多个类型声明之间使用<strong>逗号分隔</strong>，最后一个类型声明之后则是函数的主体开始。</p>
<blockquote>
<p>如果有多个类型声明，类型声明之间的逗号<strong>不能省略</strong>，因为这是表示类型声明部分，当最后一个声明后面没有逗号时，语法解析器会认为是函数主体的开始。</p>
</blockquote>
<h3 id="定义数据类型别名"><a class="header" href="#定义数据类型别名">定义数据类型别名</a></h3>
<p>可以为名字较长的数据类型（如某个组合的元组，或者某个函数签名）定义一个别名，使用别名可以让代码更简洁清晰，定义数据类型别名的语法：</p>
<ul>
<li><code>类型 名称 = 数据类型</code></li>
<li><code>type Name = DataType</code></li>
</ul>
<p>示例：</p>
<pre><code class="language-js">类型 字符串 = 列表&lt;字符&gt;
类型 空型 = 结果&lt;单元, 错误&gt;
类型 排队令牌 = (整数, 字符串)
类型 整数过滤函数 = 逻辑 &lt;- (整数)
类型 过滤函数&lt;T&gt; = 逻辑 &lt;- (T)
</code></pre>
<pre><code class="language-js">type String = List&lt;Char&gt;
type Void = Result&lt;Unit, Error&gt;
type Token = (Int, String)
type IntFilterFunc = Boolean &lt;- (Int)
type FilterFunc&lt;T&gt; = Boolean &lt;- (T)
</code></pre>
<p>使用类型别名可以缩短函数的定义语句，比如下面几个函数的定义的结果是一样的。</p>
<pre><code class="language-js">## 直列式

函数 列表&lt;整数&gt; 筛选合格者(列表&lt;整数&gt; items, 逻辑 &lt;- (整数) f)
    ...
以上

## 使用 `其中` 关键字

函数 列表&lt;整数&gt; 筛选合格者(列表&lt;整数&gt; items, 整数过滤函数 f) 其中
    整数过滤函数 = 逻辑 &lt;- (整数)
    ...
以上

## 使用 `类型` 定义别名

类型 整数过滤函数 = 逻辑 &lt;- (整数)
函数 列表&lt;整数&gt; 筛选合格者(列表&lt;整数&gt; items, 整数过滤函数 f)
    ...
以上
</code></pre>
<pre><code class="language-js">## flat list

function List&lt;Int&gt; passFilter(List&lt;Int&gt; items, Boolean &lt;- (Int) f)
    ...
end

## using 'where` keyword

function List&lt;Int&gt; passFilter(List&lt;Int&gt; items, IntFilterFunc f) where
    IntFilterFunc = Boolean &lt;- (Int)
    ...
end

## using 'type' define alias name

type IntFilterFunc = Boolean &lt;- (Int)
function List&lt;Int&gt; passFilter(List&lt;Int&gt; items, IntFilterFunc f)
    ...
end
</code></pre>
<h3 id="字面两类型的自动隐式转换"><a class="header" href="#字面两类型的自动隐式转换">字面两类型的自动（隐式）转换</a></h3>
<p>当将一个能表示范围较小的数值的字面量赋值给一个范围较大的变量时，运行环境（的解析器）会进行类型的隐式转换（有些语言也叫类型提升）。</p>
<p>比如将一个整数（默认是 <code>Int</code>）的字面量赋值给 <code>Float</code> 类型的变量时，该字面量会被提升为 <code>Float</code> 类型。</p>
<p>示例：</p>
<p><code>let Real r = 3</code></p>
<p>会被自动替换为：</p>
<p><code>let Real r = 3.0</code></p>
<p>注意，如果将一个整数字面量（默认为 <code>Int64</code> 类型）赋值给诸如 <code>Int32</code>、或者 <code>Int8</code> 等类型的变量时，解析器也会事先进行检查，然后再赋值正确的数值给变量。</p>
<p>类型隠式转换仅发生在字面量赋值语句里，下面情况不会进行类型转换：</p>
<ul>
<li>字面量之间的算术运算。</li>
<li>字面量作为参数传给函数；</li>
<li>不同类型变量的赋值；</li>
<li>字面量跟不同类型的变量之间的算术运算；</li>
<li>不同类型变量之间的算术运算。</li>
</ul>
<p>XiaoXuan 的类型转换是发生在语法分析阶段，而不是在运行时。</p>
<p>当两个不同类型的<strong>字面量</strong>进行算术运算时（比如整数和浮点数之间的加法、减法等），其实不存在类型的隠式转换。其运算过程是：</p>
<ol>
<li>首先运行环境会获取第一个字面量的数据类型；</li>
<li>然后查找该类型对应运算的函数；</li>
<li>然后根据第二个操作数的类型寻找相应的方法重载；</li>
<li>如果找到则调用该方法，如果找不到则抛出运行时错误。</li>
</ol>
<p>示例：</p>
<p><code>3 + 4.5</code></p>
<p>首先运行环境会找到 <code>Int64::add</code> 方法，然后继续查找是否存在该方法的重载 <code>Int64::add(Int64, Real64)</code> 并调用它，即该加法表达式实际上被翻译为：</p>
<p><code>Int64::add(3, 4.5)</code></p>
<h2 id="值的不可变性"><a class="header" href="#值的不可变性">值的不可变性</a></h2>
<p>XiaoXuan 的值（包括各种集合、结构体、联合体等）也是不可变的。比如：</p>
<ul>
<li>对于一个列表，直接修改它的元素是不允许的，增加或者删除元素都会返回一个新的列表；</li>
<li>对于一个结构体，无法修改它的成员的值，修改某个成员的值会返回一个新的结构体。</li>
</ul>
<p>值得不可变性使得数据可以放心传递给多线程，不会因为某个线程的修改而导致数据竞争。是 XiaoXuan 并行和并发工作模式的基础。</p>
<h2 id="变量的不可变性"><a class="header" href="#变量的不可变性">变量的不可变性</a></h2>
<p>变量定义并赋值之后，便无法再次赋值。也就是说，除了变量指向的值是不可变的，变量的 &quot;指向&quot; 本身也是不可变的。</p>
<p>比如下面的语句会引起运行时异常：</p>
<pre><code class="language-js">让 a = 123
a = 456  # 错误
</code></pre>
<pre><code class="language-js">let a = 123
a = 456  # Error
</code></pre>
<p>因为变量无法重新赋值，所以对于我们所熟悉的（在可变变量的语言里）常用数据处理方法，在 XiaoXuan 里需要稍微转换一下。</p>
<p>比如有一个程序：让用户多次输入数字，然后计算数字的总和，直到用户输入 &quot;Q&quot; 为止。下面的是 JavaScript 版本：</p>
<pre><code class="language-JavaScript">let sum = 0;
while(true) {
    let s = prompt('Enter a number:');
    if (s === 'Q') break;

    let i = parseInt(s);
    sum = sum + i;
}
console.log(sum)
</code></pre>
<p>下面是 XiaoXuan 版本：</p>
<pre><code class="language-js">function Int add(Int acc)
  let s = readLine()?
  if s == &quot;Q&quot; then return acc

  let i = parse&lt;Int&gt;(s)
  let c = acc + i

  # 以当前的累加值作为参数调用自己以
  # 再执行一遍当前这个过程
  add (c)
end

let sum = add (0)
writeLine(sum)
</code></pre>
<p>XiaoXuan 语言会对函数的尾调用进行优化，只要函数最后执行的表达式是调用函数自己本身，则不会创建新的调用栈，也就是说不会堆栈溢出。</p>
<p>XiaoXuan 也有自己的条件循环语句：<code>设有 让...</code>（<code>for let...</code>）语句，其实质是通过创建一个匿名函数及递归调用来实现的，这样可以省去自己手动创建函数。示例：</p>
<pre><code class="language-js">let sum =
    for let Int acc = 0
        let s = readLine()?
        if s == &quot;Q&quot; then return acc

        let i = parse&lt;Int&gt;(s)
        let c = acc + i
        loop c
    end

writeLine(c)
</code></pre>
<p><code>for let...</code> 语句实际上是创建了一个匿名函数，然后通过 loop 语句调用自己，以实现 &quot;循环&quot; 的效果。详细请见 <a href="control-flow.html">流程控制</a>。</p>
<h2 id="变量的可变性不支持"><a class="header" href="#变量的可变性不支持">变量的可变性（::不支持）</a></h2>
<p>某些 XiaoXuan 的衍生版本（语言）可能会支持可变变量，但其可变原理跟一般支持变量可变的语言仍不太相同。</p>
<p>比如，现有一个指向字符串的变量，在被重新赋值之后，该变量原先指向的那份（在内存堆中）字符串数据仍然被保留着，只是变量指向了一份新的字符串数据。当程序再次读取这个变量时，获取的是最新版本的数据。至于旧的版本，如果之前已经被其他程序读取且仍在使用中（比如已经传递给某一个线程正在处理），则这部分程序看到的仍然是旧版本的数据。如果旧版本没有其他程序引用，则它将被垃圾回收。</p>
<p>可见处理可变变量的方式总是 &quot;只增&quot; 新版本，然后让变量指向新版本，而不是直接修改（或覆盖，或抹除）原先的数据。这种处理方式类似某些版本控制工具（比如 Git）的工作方式，即默认情况下提交（commit，更新）仓库实际上是增加新版本，所有历史版本都会保留着。</p>
<h3 id="变量的作用域"><a class="header" href="#变量的作用域">变量的作用域</a></h3>
<p>每个变量都有其作用域，比如：</p>
<ul>
<li>在模块定义的变量，其作用域是其所在的模块（同一个模块可以分布在不同的源代码文件里）；</li>
<li>在函数里定义的变量，其作用域在其所在的函数里；</li>
<li>在语句块（包括条件语句、循环语句、匿名函数主体等）定义的变量，其作用域仅限其所在的语句块里。</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">module apple

function a ()
    let x = 22           # 定义函数级的变量 x
    # let x = 99         # 当前环境已存在名称为 x 的变量，这里无法再定义变量 x

    for d in [1..10]     # 变量 d 的作用域仅限当前 for 语句块之内
        writeLine(x)     # 能输出函数级的变量 x = 22
        # let x = 33     # 当前环境仍然存在名称为 x 的变量，这里无法再定义变量 x

        let y = 33       # 定义语句块级的变量 y

        if d&gt;0 then
            writeLine(x) # 能输出函数级的变量 x = 22
            writeLine(y) # 能输出语句块级的变量 y = 33

            let z = 44   # 定义内层语句块级的变量 z
        end

        # writeLine(z)   # 这里已经超出内层语句块级的变量 z 作用域

        let z = 55       # 当前环境不存在名称为 z 的变量，这里可以定义语句块级的变量 z
    end

    # writeLine(d)       # 这里已经超出 for 语句块变量 d 的作用域
end

function b ()
    # writeLine(x)       # 这里无法访问函数 a 里的变量 x
end
</code></pre>
<p>注意在有效作用域里不允许存在同名变量，比如下面的代码会引起运行时异常：</p>
<pre><code class="language-js">函数 空型 测试()
    让 n = 123
    让 n = 456        # 当前环境已存在名称为 n 的变量，这里无法再定义变量 n

    如果 n &gt; 100 那么 # 当前环境已存在名称为 n 的变量，这里无法再定义变量 n
      ...
    以上

    设有 i 取自 [1..10]
        ...
        让 n = 789    # 当前环境已存在名称为 n 的变量，这里无法再定义变量 n
        ...
    以上

    让 i = 666        # 这里已经超出循环语句块变量 i 的作用域，这里可以定义变量 i
以上
</code></pre>
<h3 id="全局变量不支持"><a class="header" href="#全局变量不支持">全局变量（::不支持）</a></h3>
<p>全局变量其实就是作用域为模块级的普通变量，即在模块范围里（而不是在某个函数、类型实现、模块实现里）定义的变量。全局变量使用关键字 <code>定义</code> 来定义，其语法除了关键字不同，其余跟 <code>让</code> 语句一样。示例：</p>
<pre><code class="language-js">模块 foo.bar

定义 整数 n = 123

@测试
函数 空型 第一个测试 ()
    书写行 (n) # 这里输出全局变量 n 的值
以上
</code></pre>
<pre><code class="language-js">module foo.bar

define Int n = 123

@test
function Void firstTest ()
    writeLine (n) # output the value of global variable n
end
</code></pre>
<p>在模块范围定义的变量能够被其他模块所读取，只要被导入即可，也就是说它能被程序的任何地方所读取，所以也可以称为 &quot;全局变量&quot;。</p>
<p>示例：</p>
<pre><code class="language-js">模块 hello.world

导入 foo.bar

@测试
函数 空型 第二个测试 ()
    书写行 (bar.n) # 这里输出 'foo.bar' 模块的变量 n 的值
以上
</code></pre>
<pre><code class="language-js">module hello.world

import foo.bar

@test
function Void secondTest ()
    writeLine (bar.n) # output the value of global variable n which exists in the module 'foo.bar'
end
</code></pre>
<p>全局变量的赋值语句（即右值，一个字面量或者一个表达式）会在模块被加载时运行。准确来说，加载应用程序时，会先加载所有模块所有定义性质的语句，比如函数、结构体、特性、接口、组件实现等等的定义，然后才执行全局变量的赋值语句。</p>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>因为 XiaoXuan 的变量的值不可变性，所以常量跟变量非常相近，不同的地方在于：</p>
<ul>
<li>常量即使在某些支持变量可变的衍生版本里，也是不能被重新赋值；</li>
<li>常量的名称可以用在模式匹配里当作字面量使用，而变量名称在模式匹配里会被当成新的变量。</li>
</ul>
<p>定义常量的语法是：</p>
<pre><code class="language-js">常量 数据类型 常量名称 = 值
</code></pre>
<p>也可以一次定义一组：</p>
<pre><code class="language-js">常量 数据类型 常量组名称
   成员名称1 = 值1
   成员名称2 = 值2
   ...
   成员名称N = 值N
以上
</code></pre>
<!-- XiaoXuan 规定常量必须一组一组地定义，不能单独地使用一个名称定义一个常量值，-->
<p>访问常量组的成员是，使用 <code>组名::成员名</code> 的格式。</p>
<p>示例：</p>
<pre><code class="language-js">名称空间 http::client
    常量 整数 ResponseCode
        Ok = 200
        Moved = 301
        Found = 302
        NotModified = 304
        BadRequest = 400
        Forbidden = 403
        NotFound = 404
        ServerError = 500
        ServiceUnavailable = 503
    以上

    函数 结果&lt;单元&gt; 第一个测试 ()
        书写行 (ResponseCode::Ok) # 输出常量的实际值 &quot;200&quot;
        书写行 (ResponseCode::NotFound) # 输出 &quot;404&quot;
    以上
以上
</code></pre>
<pre><code class="language-js">namespace http.client
    const Int ResponseCode
        Ok = 200
        Moved = 301
        Found = 302
        NotModified = 304
        BadRequest = 400
        Forbidden = 403
        NotFound = 404
        ServerError = 500
        ServiceUnavailable = 503
    end

    function Result&lt;Unit, Error&gt; firstTest ()
        writeLine (ResponseCode::Ok)       # output the actual value &quot;200&quot;
        writeLine (ResponseCode::NotFound) # output &quot;404&quot;
    end
end
</code></pre>
<p>在模块里定义的常量可以在程序的任何地方所读取，所以也称为 &quot;全局常量&quot;，示例：</p>
<pre><code class="language-js">名称空间 main
    函数 结果&lt;单元, 错误&gt; 第二个测试 ()
        导入 http::client::ResponseCode # 导入语句可以写在任何地方

        书写行 (ResponseCode::Ok) # 输出 &quot;200&quot;
        书写行 (ResponseCode::NotFound) # 输出 &quot;404&quot;
    以上
名称空间
</code></pre>
<pre><code class="language-js">namespace main
    function Result&lt;Unit, Error&gt; secondTest ()
        import http.client.ResponseCode # Import statements can be written anywhere

        writeLine (ResponseCode::Ok) # output &quot;200&quot;
        writeLine (ResponseCode::NotFound) # output &quot;404&quot;
    end
end
</code></pre>
<p>注意：</p>
<!--
* 导入全局常量时必须整组导入，不能只导入单独一个值，比如 `import http.client.ResponseCode` 是对的，但 `import http.client.ResponseCode.Ok` 是错误的。-->
<ul>
<li>常量组的组名不是一种数据类型，不能作为变量或者参数的数据类型，它仅仅是名称空间的一部分而已。</li>
</ul>
<!--
* 常量的值只能是基本的数据类型，或者结构体、联合体使用默认构造函数创建的实例，不能是一个表达式，即常量的右值不能是一表达式，比如一个函数的返回值。-->
<!--### 局部常量 -->
<p>常量也可以在函数范围内定义，<!--比如有时可能只想在某一个函数里要一个严格只读的值，而不是想定义全局常量，--> 比如想定义一个临时的常量（即在地方地方用不着的常量）给模式匹配使用，对于在函数范围内定义的常量，就不能定义常量组了 <!--，可以不需要定义为一个组，即支持使用一个名称定义一个常量，语法：--></p>
<p>示例：</p>
<pre><code class="language-js">function test()
    const Good = 100
    match s
        case Good: writeLine(&quot;Good&quot;)
        case _: writeLine(&quot;Other&quot;)
    end
end
</code></pre>
<p>注意在模式匹配中，不能使用变量来代替常量：</p>
<pre><code class="language-js">function test()
    let Good = 100
    match s
        case Good: writeLine(&quot;Good&quot;) # 这里的 Good 将会是一个新的变量，其值等于变量 s
        case _: writeLine(&quot;Other&quot;) # 这行永远不会被执行
    end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数-1"><a class="header" href="#函数-1">函数</a></h1>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="functions.html#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="functions.html#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8">函数的调用</a>
<ul>
<li><a href="functions.html#%E8%AF%AD%E6%B3%95">语法</a>
<ul>
<li><a href="functions.html#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">函数的返回值</a></li>
<li><a href="functions.html#%E6%8C%89%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0%E4%BC%A0%E5%8F%82">按参数名称传参</a></li>
<li><a href="functions.html#%E8%B0%83%E7%94%A8%E5%86%B2%E7%AA%81">调用冲突</a></li>
<li><a href="functions.html#%E8%B0%83%E7%94%A8%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0">调用没有参数的函数</a></li>
<li><a href="functions.html#%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8">嵌套调用</a></li>
<li><a href="functions.html#%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E6%8D%A2%E8%A1%8C">参数列表换行</a></li>
<li><a href="functions.html#%E5%B0%BE%E9%83%A8%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96">尾部调用优化</a></li>
</ul>
</li>
<li><a href="functions.html#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E7%89%B9%E6%80%A7%E5%87%BD%E6%95%B0-%E8%80%83%E8%99%91%E7%A7%BB%E5%8A%A8">实例方法和特性函数 （::考虑移动）</a></li>
<li><a href="functions.html#%E5%87%BD%E6%95%B0%E7%9A%84%E7%82%B9%E5%8F%B7%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F-%E8%80%83%E8%99%91%E7%A7%BB%E5%8A%A8">函数的点号调用方式 （::考虑移动）</a>
<ul>
<li><a href="functions.html#%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0%E4%B8%8D%E6%94%AF%E6%8C%81">一般函数（::不支持）</a></li>
<li><a href="functions.html#%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%82%B9%E5%8F%B7%E8%B0%83%E7%94%A8%E4%B8%8D%E6%94%AF%E6%8C%81">连续的函数点号调用（::不支持）</a></li>
</ul>
</li>
<li><a href="functions.html#%E6%8B%86%E5%B0%81-%E8%80%83%E8%99%91%E7%A7%BB%E5%8A%A8">拆封 （::考虑移动）</a>
<ul>
<li><a href="functions.html#%E6%8C%87%E5%AE%9A%E6%8B%86%E5%B0%81%E7%9A%84%E5%90%8E%E5%A4%87%E5%80%BC-%E6%9B%BF%E6%8D%A2%E5%80%BC-%E8%80%83%E8%99%91%E7%A7%BB%E5%8A%A8">指定拆封的后备值 <!--替换值--> （::考虑移动）</a></li>
<li><a href="functions.html#%E6%8C%87%E5%AE%9A%E6%8B%86%E5%B0%81%E7%9A%84%E6%9B%BF%E6%8D%A2%E5%80%BC%E4%B8%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%80%83%E8%99%91%E7%A7%BB%E5%8A%A8">指定拆封的替换值为表达式 （::考虑移动）</a></li>
<li><a href="functions.html#%E6%8C%87%E5%AE%9A%E6%8B%86%E5%B0%81%E7%9A%84%E6%9B%BF%E6%8D%A2%E4%B8%BA%E8%AF%AD%E5%8F%A5%E5%9D%97-%E8%80%83%E8%99%91%E7%A7%BB%E5%8A%A8">指定拆封的替换为语句块 （::考虑移动）</a></li>
<li><a href="functions.html#%E6%8C%87%E5%AE%9A%E6%8B%86%E5%B0%81%E7%9A%84%E5%90%8E%E5%A4%87%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">指定拆封的后备匿名函数</a></li>
<li><a href="functions.html#%E4%BC%9A%E8%87%AA%E5%8A%A8%E9%80%80%E5%87%BA%E5%87%BD%E6%95%B0%E7%9A%84%E6%8B%86%E5%B0%81-%E8%80%83%E8%99%91%E7%A7%BB%E5%8A%A8">会自动退出函数的拆封 （::考虑移动）</a></li>
</ul>
</li>
<li><a href="functions.html#%E9%83%A8%E5%88%86%E8%B0%83%E7%94%A8">部分调用</a></li>
<li><a href="functions.html#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8-%E8%80%83%E8%99%91%E7%A7%BB%E5%8A%A8">链式调用 （::考虑移动）</a></li>
<li><a href="functions.html#%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%84%E5%90%88">函数的组合</a></li>
<li><a href="functions.html#%E4%BD%BF%E7%94%A8-%E8%B0%83%E7%94%A8-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E4%B8%8D%E6%94%AF%E6%8C%81">使用 <code>调用</code> 函数调用函数（::不支持）</a></li>
<li><a href="functions.html#%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%AD%E7%BD%AE%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F">函数的中置调用方式</a></li>
<li><a href="functions.html#%E4%B8%AD%E7%BD%AE%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86">中置调用的原理</a></li>
<li><a href="functions.html#%E8%BF%9E%E7%BB%AD%E4%B8%AD%E7%BD%AE%E8%B0%83%E7%94%A8">连续中置调用</a></li>
<li><a href="functions.html#-%E5%86%85%E7%BD%AE%E7%9A%84%E4%B8%AD%E7%BD%AE%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7-%E8%BF%90%E7%AE%97%E7%AC%A6"><!-- 内置的中置函数的优先级 --> 运算符</a></li>
<li><a href="functions.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">表达式的执行顺序</a></li>
</ul>
</li>
<li><a href="functions.html#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">函数的定义</a>
<ul>
<li><a href="functions.html#%E8%AF%AD%E6%B3%95-1">语法</a>
<ul>
<li><a href="functions.html#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0">无返回值函数</a></li>
<li><a href="functions.html#%E7%AE%80%E5%86%99%E5%BD%A2%E5%BC%8F">简写形式</a></li>
</ul>
</li>
<li><a href="functions.html#%E5%87%BD%E6%95%B0%E5%88%AB%E5%90%8D">函数别名</a></li>
<li><a href="functions.html#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数</a></li>
<li><a href="functions.html#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F%E5%80%BC%E9%97%AD%E5%8C%85">匿名函数捕获变量值（闭包）</a></li>
<li><a href="functions.html#%E7%AE%80%E5%8C%96%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">简化形式的匿名函数</a></li>
<li><a href="functions.html#%E8%BF%94%E5%9B%9E-%E5%85%B3%E9%94%AE%E5%AD%97"><code>返回</code> 关键字</a>
<ul>
<li><a href="functions.html#%E7%9C%81%E7%95%A5-%E8%BF%94%E5%9B%9E-%E5%85%B3%E9%94%AE%E5%AD%97">省略 <code>返回</code> 关键字</a></li>
<li><a href="functions.html#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%BD%93%E4%B8%AD%E7%9A%84-%E8%BF%94%E5%9B%9E-%E5%85%B3%E9%94%AE%E5%AD%97">匿名函数当中的 <code>返回</code> 关键字</a></li>
<li><a href="functions.html#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E5%BD%93%E4%B8%AD%E7%9A%84-%E8%BF%94%E5%9B%9E-%E5%85%B3%E9%94%AE%E5%AD%97">流程控制语句当中的 <code>返回</code> 关键字</a></li>
<li><a href="functions.html#%E5%B0%BE%E9%83%A8%E8%B0%83%E7%94%A8">尾部调用</a></li>
</ul>
</li>
<li><a href="functions.html#%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD">函数的重载</a>
<ul>
<li><a href="functions.html#%E8%B7%A8%E6%A8%A1%E5%9D%97%E9%87%8D%E8%BD%BD%E4%B8%8D%E6%94%AF%E6%8C%81">跨模块重载（::不支持）</a></li>
<li><a href="functions.html#%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0">参数的默认值和可选参数</a></li>
</ul>
</li>
<li><a href="functions.html#%E9%87%8D%E8%BD%BD%E5%86%B2%E7%AA%81">重载冲突</a></li>
<li><a href="functions.html#%E5%88%86%E6%94%AF%E5%87%BD%E6%95%B0">分支函数</a>
<ul>
<li><a href="functions.html#%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8E%E6%95%B0%E5%AD%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89">函数的分支与数学的函数定义</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="functions.html#%E7%BA%AF%E5%87%BD%E6%95%B0">纯函数</a></li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->
<h2 id="函数的调用"><a class="header" href="#函数的调用">函数的调用</a></h2>
<h3 id="语法"><a class="header" href="#语法">语法</a></h3>
<p>调用函数时，写上函数的名称，然后使用一对括号把所有实参包围起来：</p>
<ul>
<li><code>函数名称 (参数值1, 参数值2, ... , 参数值N)</code></li>
<li><code>functionName (value1, value2, ... , valueN)</code></li>
</ul>
<p>示例：</p>
<pre><code class="language-js">加 (1, 2)
行输出 (&quot;你好&quot;)
</code></pre>
<pre><code class="language-js">add (1, 2)
writeLine (&quot;Hello&quot;)
</code></pre>
<h4 id="函数的返回值"><a class="header" href="#函数的返回值">函数的返回值</a></h4>
<p>可以定义一个变量接收函数的返回值：</p>
<ul>
<li><code>让 变量名 = 函数名称 (参数值1, 参数值2, ..., 参数值N)</code></li>
<li><code>let variableName = functionName (value1, value2, ..., valueN)</code></li>
</ul>
<p>示例：</p>
<pre><code class="language-js">让 a = 平方根 (4)
让 b = 加 (1, 2)
</code></pre>
<pre><code class="language-js">let a = sqrt (4)
let b = add (1, 2)
</code></pre>
<p>如果对函数的返回值不感兴趣，也可以直接调用函数，不一定需要定义一个变量来接收它的返回值。</p>
<h4 id="按参数名称传参"><a class="header" href="#按参数名称传参">按参数名称传参</a></h4>
<p>调用函数时，一般是把各个参数值（即实参）按顺序（或者说 &quot;位置&quot;）传入函数，当一个函数的参数较多，可以考虑按参数名称传入参数值，这样在阅读时会更明确各个实参的意义。</p>
<p>按参数名称传参的格式：</p>
<ul>
<li><code>函数名称 (参数名称1=参数值1, 参数名称2=参数值2, ..., 参数名称N=参数值N)</code></li>
<li><code>functionName (param1=value1, param2=value2, ..., paramN=valueN)</code></li>
</ul>
<p>也可以混合按位置和按名称两种传参方式，不过必须先写完所有按位置传参的参数值，然后才可以开始写按名称传参的 &quot;名称-数值&quot; 对，格式：</p>
<ul>
<li><code>函数名称 (参数值1, ..., 参数值N, 参数名称a=参数值a, ..., 参数名称z=参数值z)</code></li>
<li><code>functionName (value1, ..., valueN, paramA=valueA, ..., paramZ=参数值Z)</code></li>
</ul>
<p>示例：</p>
<pre><code class="language-js"># 按名称传参
绘图.直线 (x1=0, y1=0, x2=100, y2=100, 颜色=颜色常数.红色, 线条宽度=3)

# 混合按位置和按名称传参
绘图.直线 (0, 0, 100, 100, 颜色=颜色常数.红色, 线条宽度=3)
</code></pre>
<pre><code class="language-js"># passing parameters by name
draw.line (x1=0, y1=0, x2=100, y2=100, color=ColorConstant.Red, lineWidth=3)

# mixing per-position and per-name passing
draw.line (0, 0, 100, 100, color=ColorConstant.Red, lineWidth=3)
</code></pre>
<blockquote>
<p>无论函数当中的参数是否为可选参数，均可按照名称方式传参。</p>
</blockquote>
<h4 id="调用冲突"><a class="header" href="#调用冲突">调用冲突</a></h4>
<blockquote>
<p>XiaoXuan 的每个函数调用，在编译时就已经确定其应该调用的是哪一个函数定义，而不是在运行的过程中确定。</p>
</blockquote>
<p>因为运行环境会在源码解和析验证阶段已经排除有参数位置冲突的情况（具体排除方法见下面函数定义章节），所以当按照参数位置调用函数时，总能找到正确的对应的函数。不过当按照参数名称或者按照参数位置加名称的方式调用函数时，则有可能存在冲突的可能。</p>
<p>示例：</p>
<pre><code class="language-js">function Int test (Int a [, String b = &quot;foo&quot;]) = ...
function Int test (String b [, Int a = 99]) = ...
</code></pre>
<p>注：参数列表中的中括号是为了突出表示当中的是可选参数，实际上不存在中括号。</p>
<p>在源码解析验证的阶段，因为上面两个函数的位置参数的数据类型不同，因此不存在冲突。但如果按照参数名称调用，运行环境会逐个重载进行匹配。具体的步骤如下：</p>
<ol>
<li>先按照调用语句当中的位置参数筛选重载，此时无视函数定义当中参数的名称以及是否可选参数，即仅按照参数的数据类型和顺序来匹配；</li>
<li>然后按照调用语句当中的名称参数，在上一步得出的候选重载中的剩余参数里，根据名称进行匹配，最后筛选出符合的重载。</li>
<li>如果最后匹配的函数重载超过一个，则会引起运行时异常。</li>
</ol>
<p>示例：</p>
<pre><code class="language-js">let i = test(a = 55, b = &quot;bar&quot;)
</code></pre>
<p>上面的调用语句与 <code>test</code> 函数的两个重载均可匹配，所以会引起运行时异常，这时需要更改调用语句，比如：</p>
<p><code>let i = test(55, b = &quot;bar&quot;)</code></p>
<p>或者</p>
<p><code>let j = test(&quot;bar&quot;, a = 55)</code></p>
<h4 id="调用没有参数的函数"><a class="header" href="#调用没有参数的函数">调用没有参数的函数</a></h4>
<p>调用一个没有参数的函数（一般称之为过程）时，需要在函数名称后面加上一对空括号：</p>
<ul>
<li><code>函数名称 ()</code></li>
<li><code>functionName ()</code></li>
</ul>
<h4 id="嵌套调用"><a class="header" href="#嵌套调用">嵌套调用</a></h4>
<p>函数也可以嵌套调用，即：将一个函数的返回值作为另一个函数的参数的值。严格来说任何有返回值的表达式或者语句块，都可以作为参数值传给另一个函数。</p>
<p>嵌套调用的格式：</p>
<ul>
<li><code>函数1 (参数值1, 函数2 (参数值a, 参数值z), 任意有返回值的表达式, ...)</code></li>
<li><code>function1 (value1, function2 (valueA, valueZ), any_expression, ...)</code></li>
</ul>
<p>示例：</p>
<pre><code class="language-js">让 弦 = 平方根 (平方 (3), 平方 (4))
让 弦 = 平方根 (3 ^ 2 + 4 ^ 2)
</code></pre>
<pre><code class="language-js">let dist = sqrt (square (3), square (4))
let dist = sqrt (3 ^ 2 + 4 ^ 2)
</code></pre>
<ul>
<li>尽量避免多层函数嵌套调用，可以先把表达式的值求出来并赋值给变量，然后再把变量作为参数值传入函数。</li>
<li>在语法上，允许省略函数名称和参数列表之间的空格，允许省略参数值之间的空格，不过为了规范起见尽量保留这些空格。</li>
</ul>
<h4 id="参数列表换行"><a class="header" href="#参数列表换行">参数列表换行</a></h4>
<p>当参数列表过长时，可以换行书写，但参数列表的第一个括号（即开始括号）必须保留在函数名称后面，示例：</p>
<pre><code class="language-js">01  让 标准差 =
02      平方根 (
03          加 (
04              (x1-μ)^2,
05              (x2-μ)^2
06          )
07      )
</code></pre>
<pre><code class="language-js">01  let std_deviation =
02      sqrt (
03          add (
04              (x1-μ)^2,
05              (x2-μ)^2
06          )
07      )
</code></pre>
<p>注意上面示例的第 02 和 03 行的末尾的左括号 &quot;(&quot; 必须跟在函数名称后面。</p>
<h4 id="尾部调用优化"><a class="header" href="#尾部调用优化">尾部调用优化</a></h4>
<p>当一个函数内部有语句调用自身时，且该语句位于函数的最后一句（注意这一句必须是单纯地调用函数自身的语句，而不能是一个表达式语句），或者这句后面只有 <code>如果</code> 语句的 <code>以上</code> 语句。这时运行环境会对这语句进行尾部调用优化。</p>
<p>尾部调用优化即不会创建新的调用栈，而是更改函数的参数值直接再运行一次函数体的代码。</p>
<p>实际上语法解析器在满足尾部调用优化的情况下，会把调用函数自身的语句替换成 <code>回到</code>（<code>recur</code>）语句。</p>
<h3 id="实例方法和特性函数-考虑移动"><a class="header" href="#实例方法和特性函数-考虑移动">实例方法和特性函数 （::考虑移动）</a></h3>
<p>如果某个数据类型（包括结构体和联合体）具备了某个<code>特性</code>（<code>Trait</code>，又叫做类型类、TypeClass），或者被赋予了实例方法，则可以在这个数据类型的实例上使用点号（&quot;.&quot;）来调用特性当中的函数或者实例方法。</p>
<p>比如有一个 &quot;可显示&quot;（&quot;Display&quot;）特性，其中有一个 &quot;转为字符串&quot;（&quot;toString&quot;） 的函数。现有赋予该特性给结构体 &quot;用户&quot;，则有 3 种方式调用 &quot;转为字符串&quot; 函数：</p>
<pre><code class="language-js">01  让 a = 可显示&lt;用户&gt;.转为字符串 (用户甲)    # 普通的函数调用方式
02  让 b = 转为字符串 (用户甲)                # 根据第一个参数自动推导对应的函数
03  让 c = 用户甲.转为字符串 ()               # 点号调用方式
</code></pre>
<pre><code class="language-js">01  let a = Display&lt;User&gt;.toString (userA)
02  let b = toString (userA)
03  let c = userA.toString ()
</code></pre>
<p>上面代码当中：</p>
<ul>
<li>01 行是标准的函数调用方式；</li>
<li>02 行是运行环境先在当前上下文是否存在 &quot;转为字符串&quot; 函数，如果没有则根据第一个参数查找是否存在对应的特性函数或者数据实例方法，如果存在则使用相应的函数（上例中运行环境找到了特性函数 &quot;可显示&lt;用户&gt;.转为字符串&quot;）；</li>
<li>03 行是使用了特性函数点号的调用方式。</li>
</ul>
<p>实际上点号调用方式是一个语法糖。即，对于如下格式的函数调用：</p>
<ul>
<li><code>特性名称.函数名 (数据实例, 参数值1, 参数值2, ... 参数值N)</code></li>
<li><code>TraitName.functionName (dataInstance, value1, value2, ... valueN)</code></li>
</ul>
<p>可以简写如下：</p>
<ul>
<li><code>数据实例.函数名 (参数值1, 参数值2, ... 参数值N)</code></li>
<li><code>dataInstance.functionName (value1, value2, ... valueN)</code></li>
</ul>
<p>需注意仅当特性函数或者实例方法的第一个参数为数据实例的类型时才能使用点号调用方式，有些特性函数和实例方法的第一个参数未必恰好是当前数据实例的类型。</p>
<p>使用省略特性名称或者数据类型名称的调用方式（也叫做隐式方法调用）比较接近动态脚本语言的风格，但存在名称冲突的风险（编译时会显示警告信息）。</p>
<p>使用点号调用函数比较接近一般面向对象编程语言的对象实例的方法（method）调用风格和习惯，例如：</p>
<pre><code class="language-java"># Java
User userA = ...;
int id = userA.id;             # 访问对象的属性
String text = userA.toString() # 访问对象的方法
</code></pre>
<pre><code class="language-js"># XiaoXuan
let userA = ...
let id = userA.id  # 访问结构体的成员
let text = userA.toString() # 调用类 &quot;Display&quot; 的 &quot;toString()&quot; 方法
</code></pre>
<p>在条件允许的情况下推荐使用第 3 种调用方式。</p>
<p>如果要在数字（整数和浮点数）字面量后面使用点号调用函数，需要使用括号把数字包围起来，示例：</p>
<pre><code class="language-js">让 a = (123).平方()
</code></pre>
<p>直接在数字后面写上点号和函数名称会引起运行时异常。</p>
<h3 id="函数的点号调用方式-考虑移动"><a class="header" href="#函数的点号调用方式-考虑移动">函数的点号调用方式 （::考虑移动）</a></h3>
<h4 id="一般函数不支持"><a class="header" href="#一般函数不支持">一般函数（::不支持）</a></h4>
<blockquote>
<p>已经弃用该特性，因为容易会跟特性函数调用混淆</p>
</blockquote>
<p>如果一个值的数据类型跟一个函数的第一个参数的数据类型一致，也可以使用点号（&quot;.&quot;）来调用该函数。</p>
<p>示例：</p>
<pre><code class="language-js">函数 整数 平方 (整数 i) = ...
让 i = 12
让 s = i.平方()
</code></pre>
<pre><code class="language-js">function Int square (Int i) = ...
let i = 12
let s = i.square()
</code></pre>
<p>跟特性函数的点号调用不同，特性函数只需导入了目标数据类型即可。而一般函数的点号调用需要将该函数导入到当前的模块当中。</p>
<h4 id="连续的函数点号调用不支持"><a class="header" href="#连续的函数点号调用不支持">连续的函数点号调用（::不支持）</a></h4>
<blockquote>
<p>已经弃用该特性，因为容易会跟特性函数调用混淆</p>
</blockquote>
<p>只要符合点号调用的要求，则可以使用 &quot;.&quot; 符号连续调用这两个或多个函数。比如有如下 3 个函数：</p>
<pre><code class="language-js">函数 整数 加 (整数 i, 整数 i) = ...
函数 整数 平方 (整数 i) = ...
函数 显示 (整数 i) = ...
</code></pre>
<pre><code class="language-js">function Int add (Int i, Int i) = ...
function Int square (Int i) = ...
function show (Int i) = ...
</code></pre>
<p>现在想 &quot;求 (3 + 4) 的平方，并把结果输出到标准输出&quot;，每次单独调用一个函数的写法如下：</p>
<pre><code class="language-js">让 i = 加 (3, 4)
让 j = 平方 (i)
显示 (j)
</code></pre>
<pre><code class="language-js">let i = add (3, 4)
let j = square (i)
show (j)
</code></pre>
<p>或者写成一行：</p>
<ul>
<li><code>显示 (平方 (加 (3, 4)))</code></li>
<li><code>show (square (add (3, 4)))</code></li>
</ul>
<p>如果使用点号连续调用，则代码可以写成：</p>
<ul>
<li><code>加 (3, 4) .平方 () .显示 ()</code></li>
<li><code>add (3, 4) .square () .show ()</code></li>
</ul>
<p>使用点号连续调用比 &quot;连续多行的单独函数调用&quot; 或者 &quot;嵌套调用&quot; 更直观。</p>
<p>如果要换行，可以把点号 &quot;.&quot; 另起一行，示例：</p>
<pre><code class="language-js">让 a = 加(3,4)
    .平方()
    .显示()
</code></pre>
<p>点号连续调用的结合方向是从左到右的。</p>
<h3 id="拆封-考虑移动"><a class="header" href="#拆封-考虑移动">拆封 （::考虑移动）</a></h3>
<p>如果一个值的类型为 <code>Result</code> 或者 <code>Option</code>，除了可以使用模式解构获取其有效值，还能通过拆封关键字 &quot;||&quot; 进行读取。</p>
<p>设有变量 <code>a</code> 为 <code>Option&lt;Int&gt;</code> 类型，如果当前值为 <code>Some(123)</code>，则语句</p>
<p><code>let b = a || 0</code></p>
<p>会让变量 <code>b</code> 的值为 <code>123</code>。</p>
<p>拆封关键字只可以作用在实现了 <code>封装</code>（<code>Wrapper</code>） 类列的数据，否则会引起运行时异常。</p>
<h4 id="指定拆封的后备值--考虑移动"><a class="header" href="#指定拆封的后备值--考虑移动">指定拆封的后备值 <!--替换值--> （::考虑移动）</a></h4>
<p>拆封关键字 &quot;||&quot; 的右侧用于指定拆封失败后的替换值（也可以称为默认值）。</p>
<p>继续上面的例子，假如这时变量 <code>a</code> 的值为 <code>None</code>，则下面的语句：</p>
<p><code>let b = a || 456</code></p>
<p>会让变量 <code>b</code> 的值为 <code>456</code>。</p>
<p>也就是说：</p>
<ul>
<li>当 <code>a</code> 的值为 <code>Some(123)</code> 时，变量 <code>b</code> 的值为 <code>123</code>，</li>
<li>当 <code>a</code> 的值为 <code>Nothing</code> 时，变量 <code>b</code> 的值为 <code>456</code>。</li>
</ul>
<h4 id="指定拆封的替换值为表达式-考虑移动"><a class="header" href="#指定拆封的替换值为表达式-考虑移动">指定拆封的替换值为表达式 （::考虑移动）</a></h4>
<p>拆封关键字 <code>||</code> 的右侧除了可以是基本的数值，也可以是任意返回类型相符合的表达式。</p>
<p>下面是使用拆封关键字串联几个函数的例子：</p>
<pre><code class="language-js">let s = &quot;0b1010&quot;
let x = parseDec(s) || parseHex(s) || parseBin(s) || 0
</code></pre>
<p>上面的语句会依次尝试对字符串 <code>s</code> 解析为十进制、十六进制和二进制数，只要中途任何一个成功，都会立即返回值给变量 <code>x</code>，当全部都解析都失败时，则返回最后指定的默认值 0。</p>
<p>拆封默认值关键字的结合顺序是从左到右。</p>
<h4 id="指定拆封的替换为语句块-考虑移动"><a class="header" href="#指定拆封的替换为语句块-考虑移动">指定拆封的替换为语句块 （::考虑移动）</a></h4>
<p>拆封关键字 &quot;||&quot; 的右侧还可以是一个语句块，只要该语句块的返回类型相符合即可。如果该语句块由多个语句组成，需要使用一对括号把它们包围起来，</p>
<h4 id="指定拆封的后备匿名函数"><a class="header" href="#指定拆封的后备匿名函数">指定拆封的后备匿名函数</a></h4>
<p>可以使用一个匿名函数获取拆封失败的详细情况。</p>
<p>比如对于打开文件的函数 <code>open</code>，其返回值为 <code>Result&lt;File, IO.Error&gt;</code>，当文件打开成功时返回 <code>Ok(File)</code>。</p>
<p>当文件打开失败时返回 <code>Err(Error)</code>，我们可以通过这个 <code>Error</code> 实例进一步了解文件打开失败的原因，比如，如果是 <code>Error.kind() === ErrorKind.NotFound</code>，我们可以创建一个新文件，然后返回打开这个新文件的 <code>File</code> 数据实例。</p>
<p>代码如下：</p>
<pre><code class="language-js">let file = File.open(&quot;hello.txt&quot;) || e =&gt;
    if e.kind() == ErrorKind.NotFound then
        File.create(&quot;hello.txt&quot;) ?
    else
        return Err(e)
    end
</code></pre>
<p>如果不使用拆箱关键字，则上面的代码等同于：</p>
<pre><code class="language-js">let file = match File.open(&quot;hello.txt&quot;)
    case Ok(file):
        file
    case Err(e):
        if e.kind() == ErrorKind.NotFound then
            match File.create(&quot;hello.txt&quot;)
                case Ok(file):
                    file
                case Err(e):
                    Err(e)
            end
        else
            Err(e)
        end
    end
</code></pre>
<h4 id="会自动退出函数的拆封-考虑移动"><a class="header" href="#会自动退出函数的拆封-考虑移动">会自动退出函数的拆封 （::考虑移动）</a></h4>
<p>有时候希望在拆封失败时直接让函数返回失败值，即退出函数，而不是抛出运行时异常，这样可以使用 &quot;?&quot; 关键字拆封。</p>
<p>示例：</p>
<pre><code class="language-js">01  function Result&lt;String, IO.Error&gt; read(String filePath)
02      let f = openFile(filePath) ?
03      ...
04  end
</code></pre>
<p>在上面的示例中，如果 02 行拆封失败，则直接让函数返回 <code>Err()</code> 而不是抛出运行时异常。在写 I/O 密集的代码时，因为大部分 I/O 函数都是返回 <code>Result</code> 类型的数据，使用 &quot;?&quot; 可以避免频繁处理 I/O 异常，直接返回 <code>Err</code> 给更上一级的模块处理异常。</p>
<p>如果不使用拆箱关键字，则上面的代码等同于：</p>
<pre><code class="language-js">function Result&lt;String, IO.Error&gt; read(String filePath)
    let f = match openFile(filePath)
        case Ok(f):
            f
        case Err(error):
            return Err(error)
    end
    ...
end
</code></pre>
<h3 id="部分调用"><a class="header" href="#部分调用">部分调用</a></h3>
<p>部分调用用于代替一般函数式语言的柯里化。</p>
<p>XiaoXuan Lang 的函数习惯把需要处理的数据作为第一个参数（为了跟结构体的方法函数一致），将参数、函数作为第二及后续的参数。而柯里化则习惯把需要处理的数据作为最后一个参数，且会因为参数有多个而导致有多个重载。所以 XiaoXuan Lang 不采用柯里化来实现函数的部分调用，而是采用明文定义的方式实现部分调用。</p>
<p>XiaoXuan Lang 支持使用关键字 <code>var</code> 作为函数的参数来调用一个普通函数，这样返回值并不是函数的计算结果，而是一个部分调用的函数。</p>
<p>::todo 考虑使用 <code>?</code> 符号作为占位符</p>
<p>示例：</p>
<pre><code class="language-js">add(2, 3)                   // 返回 2+3=5
let addOne = add(var, 1)    // 返回一个部分调用的函数
addOne(4)                   // 返回 4+1=5
</code></pre>
<p>上面的变量 <code>add(var, 1)</code> 实际上是一个语法糖，它的实际代码是：</p>
<pre><code class="language-js">//let addOne = add(var, 1)
let addOne = x =&gt; add(x,1)
</code></pre>
<p><code>var</code> 也关键字也支持指定其生成的匿名函数的参数名称，比如 <code>let addOne = add(var i, 1)</code>，它产生的代码是：</p>
<pre><code class="language-js">let addOne = i =&gt; add(i, 1)
</code></pre>
<p>当需要生成一个有多个参数的部分调用函数时，指定参数的名称可以为调用者使用参数名称来传参。</p>
<p>示例：</p>
<pre><code class="language-js">let myFunc = someFunc(var color, var width, ...)
let v1 = myFunc(Red, 3)
let v2 = myFunc(width=3, color=Red)
</code></pre>
<p>下面代码演示使用 map 函数实现将列表里所有元素的值翻倍的函数：</p>
<pre><code class="language-js">// 已有的 Map 函数
// List map(List data, Int &lt;- (Int) func)
let doubleAll = map(var, x=&gt;x*2)
let v1 = doubleAll([1,2,3]) // 返回 [2,4,6]
</code></pre>
<h3 id="链式调用-考虑移动"><a class="header" href="#链式调用-考虑移动">链式调用 （::考虑移动）</a></h3>
<p>跟 &quot;连续函数点号调用&quot; 类似，关键字 &quot;&gt;&gt;&quot; 也能连续调用函数，只需第二个函数的首个参数的数据类型跟第一个函数的返回值拆封后的数据类型一致即可。可以粗略地认为 &quot;&gt;&gt;&quot; 关键字是 &quot;??&quot; 关键字和函数点号调用的结合体。</p>
<p>即链式调用会自动拆封 <code>Result</code> 和 <code>Option</code> 等实现了 <code>Wrap</code> 特性的数据，当拆封成功则把其值作为第一个参数传递给第二个函数，如果拆封失败则根据预先定义的值直接传递给下一个节点。</p>
<p>假设有三个函数 <code>fa</code>、<code>fb</code> 和 <code>fc</code>，其参数都有且只有一个 <code>Int</code>，返回值都是 <code>Option&lt;Int&gt;</code>，现假设有如下语句：</p>
<p><code>let a = fa (100) &gt;&gt; fb () &gt;&gt; fc ()</code></p>
<p>如果三个函数的返回值都是 <code>Some(Int)</code>，则 <code>a</code> 的值也是 <code>Some(Int)</code>，如果中间任何一个函数值返回的是 <code>None</code>，则 <code>a</code> 的值都会为 <code>None</code>。</p>
<p>注意链式调用当中的节点可能会转换返回类型，比如第一节点返回的是 <code>Result</code>，第二节点返回的是 <code>Option</code>，则最终返回的数据就是 <code>Option</code> 类型。</p>
<p>关于链式调用的详细情况请参见 <a href="chain.html">链式调用</a>。</p>
<h3 id="函数的组合"><a class="header" href="#函数的组合">函数的组合</a></h3>
<p>如果一个函数的返回值的数据类型符合另一个函数的第一个参数（有且只有一个参数）的数据类型，则可以使用函数组合符号（<code>&amp;</code>）将两个或多个函数组合起来形成一个新的函数，例如：</p>
<ul>
<li><code>让 a = 负 (平方根 (加 (2, 3)))</code></li>
<li><code>let a = neg (sqrt (add (2, 3)))</code></li>
</ul>
<p>可以写成：</p>
<pre><code class="language-js">让 我的组合函数 = 负 &amp; 平方根 &amp; 加
让 a = 我的组合函数 (2, 3)
</code></pre>
<pre><code class="language-js">let myCombFunc = neg &amp; sqrt &amp; add
let a = myCombFunc (2, 3)
</code></pre>
<p>当然也可以把函数的组合、函数的调用一次过进行：</p>
<ul>
<li><code>让 a = 负 &amp; 平方根 &amp; 加 (2, 3)</code></li>
<li><code>let a = neg &amp; sqrt &amp; add (2, 3)</code></li>
</ul>
<p>函数组合的结合方向是<strong>从右到左</strong>的，即先从右侧的函数开始计算，然依次计算到最左侧的函数。</p>
<p>如果一个函数有多个参数，可以使用部分调用（假如函数支持部分调用，即有柯里化的重载，诸如 <code>map</code>、<code>fold</code>、<code>filter</code>、<code>sort</code>、<code>match</code> 等常用函数具有柯里化重载）后再组合，比如：</p>
<pre><code class="language-js">让 加十分 = 加 (10)  # &quot;加 (10)&quot; 的返回值是一个部分函数： fn (b) = 10 + b
让 我的组合函数 = 平方根 &amp; 加十分 &amp; 平方
让 a = 我的组合函数 (60)
</code></pre>
<pre><code class="language-js">let addTen = add (10)  # &quot;add (10)&quot; return a partial function： fn (b) = 10 + b
let myCombFunc = sqrt &amp; addTen &amp; square
让 a = myCombFunc (60)
</code></pre>
<p>也可以写成一行：</p>
<ul>
<li><code>让 a = 平方根 &amp; 加 (10) &amp; 平方 (30)</code></li>
<li><code>let a = sqrt &amp; add (10) &amp; square (30)</code></li>
</ul>
<p>根据函数结合律，多个输入输出类型相同的函数在组合时，函数顺序不重要，最终结果都相同，不过因为在执行时是从最右边的函数开始（即从右向左结合），一般来说可以把能减少数据的函数先执行，比如要实现 “取字符串第一个字母并转为大写” 的函数，先取数组第一个元素再转换为大写，比先转为大写再取第一个字母的效率要高。</p>
<p>函数组合也并非一定是平铺结构的，有时需要 &quot;层次型&quot; 结构，示例：</p>
<pre><code class="language-js">let toParamCase = join('_') &amp; map(Char::toLowerCase) &amp; split(&quot; &quot;)
</code></pre>
<h3 id="使用-调用-函数调用函数不支持"><a class="header" href="#使用-调用-函数调用函数不支持">使用 <code>调用</code> 函数调用函数（::不支持）</a></h3>
<p>使用 <code>调用</code> 函数调用一个函数的格式是：<code>调用 (函数名, 参数元组)</code></p>
<p>示例：</p>
<pre><code class="language-js"># 函数的一般调用方式
让 s1 = 测试 (123, &quot;Hello&quot;)

# 使用 `调用` 语句来调用
让 args = (123, &quot;Hello&quot;)
让 s2 = 调用 (测试, args)
</code></pre>
<pre><code class="language-js"># normal call
lets1 = test (123, &quot;Hello&quot;)

# call by 'call' statement
let args = (123, &quot;Hello&quot;)
let s2 = call (test, args)
</code></pre>
<p>每个函数内部都有一个名为 &quot;<em>参数值表</em>&quot;（&quot;<em>arguments</em>&quot;） 的元组，其中记录者该函数被调用时所传入的所有参数值。</p>
<pre><code class="language-js">函数 浮点数 测试 (整数 a, 整数 b)
  让 和 = 调用 (加, _参数值表_)
  让 差 = 调用 (减, _参数值表_)
  平方根 (和^2 + 差^2)
以上
</code></pre>
<pre><code class="language-js">function Float test (Int a, Int b)
  let a = call (add, _arguments_)
  let b = call (sub, _arguments_)
  sqrt (a^2 + b^2)
end
</code></pre>
<h3 id="函数的中置调用方式"><a class="header" href="#函数的中置调用方式">函数的中置调用方式</a></h3>
<p>如果一个函数只有两个参数，则在调用时可以使用中置格式，<!-- 即：使用反单引号（"`"）将函数名包围起来--></p>
<p>方法是在函数名前面和后面加上冒号，然后将两个参数分别写在函数的左右两边，最后还需要一对括号把它们包围起来。</p>
<p>比如函数：</p>
<ul>
<li><code>让 a = 加 (11, 55)</code></li>
<li><code>let a = add (11, 55)</code></li>
</ul>
<p>其中置调用的写法是：</p>
<pre><code class="language-js">让 a = (11 :加: 55)
</code></pre>
<pre><code class="language-js">let a = (11 :add: 55)
</code></pre>
<!-- 所有名称由**纯符号**构成的函数都使用中置格式调用，如函数 "+" 和 "*" （它们分别是函数 "加" 和 "乘" 的别名）等等。 -->
<p>示例，下面 3 句的作用完全相同：</p>
<pre><code class="language-js">让 a = 加 (11, 55)
让 b = (11 :加: 55)
让 c = 11 + 55
</code></pre>
<pre><code class="language-js">let a = add (11, 55)
let b = (11 :add: 55)
let c = 11 + 55
</code></pre>
<!-- XiaoXuan 语言里没有运算符，所有运算符实际上都是函数的别名。 -->
<blockquote>
<p>函数的中置调用格式，只是函数一般调用格式的特殊写法，所以括号不能省略。</p>
</blockquote>
<blockquote>
<p>XiaoXuan 通过把一些不太好判断优先级的运算符（比如逻辑运算符、一元运算符等）移除，使用相应的函数的中置调用来取而代之，以消除优先级混乱问题。</p>
</blockquote>
<h3 id="中置调用的原理"><a class="header" href="#中置调用的原理">中置调用的原理</a></h3>
<p>中置符号使用 <code>运算符</code> 语句定义，<code>运算符</code> 语句定义了符号所对应的函数名称、运算优先级别、结合顺序。</p>
<p>示例：</p>
<pre><code class="language-js">运算符 (&quot;+&quot;, &quot;加&quot;, 优先级 = 99, 结合顺序值 = 结合顺序.左)
</code></pre>
<p><code>运算符</code> 语句必须写在模块级作用范围内。</p>
<p>运算符定义之后，当解析器遇到存在运算符（即纯符号组成的标识符）的表达式时，则会查找运算符对照表，然后根据运算优先级和结合顺序，将表达式当中的运算符解析成第一个参数数据的方法调用。</p>
<p>示例：</p>
<p><code>2 + 3</code></p>
<p>解析器通过查表找到 <code>+</code> 符号对应的函数名为 <code>加</code>，然后将表达式解析为：</p>
<p><code>(2).加(3)</code> （因为 <code>2</code> 是数字，所以被加上了一对括号）</p>
<p>由于 <code>2</code> 是整数，所以方法调用语句被进一步解析为数据的静态方法以及找到函数的原型：</p>
<p><code>整数::加 (2, 3)</code>
<code>整数::加 (Int, Int)</code></p>
<p>下面列举一个有两个 <code>+</code> 符号的表达式的解析过程：</p>
<p><code>a + b + c</code></p>
<p>解析过程：</p>
<ol>
<li>a.加(b + c)</li>
<li>a.加(b.加(c))</li>
<li>a.加(整数::加(b, c))</li>
<li>整数::加(a, 整数::加(b, c))</li>
</ol>
<h3 id="连续中置调用"><a class="header" href="#连续中置调用">连续中置调用</a></h3>
<p>同一个中置函数可以连续调用，比如：</p>
<pre><code class="language-js">let a = 1 :add: 2 :add: 3 :add: 4
</code></pre>
<p>中置函数连续调用时，运算顺序（即结合性）是从左向右方向，即先运算 <code>1 :add: 2</code>，得出结果 <code>3</code> 后再运算 <code>3 :add: 3</code>，如此类推。</p>
<p>但不同的中置函数不能连续调用，比如：</p>
<pre><code class="language-js">let b = 1 :add: 2 :greater_than: 3
</code></pre>
<p>必须使用括号把优先运算的包围起来，比如：</p>
<pre><code class="language-js">let b = (1 :add: 2) :greater_than: 3
</code></pre>
<p>但四则运算是一个例外，即 <code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code> 它们可以连续调用，且 <code>mul</code> 和 <code>div</code> 的优先级会比 <code>add</code> 和 <code>sub</code> 高。</p>
<!-- ### 优先级和结合性 -->
<!--
::TODO(移除函数中置调用法的优先级和结合性定义，不允许 "中置调用" 连续调用，即不允许诸如 `(A :and: B :or: C)` ，必须使用括号两个参数两个参数地分组，即 `((A :and: B) :or: C)`。)
-->
<!--
当**多个中置函数连续调用**时，不同的中置函数可以有不同的优先级别（即有不同的执行先后顺序），相同优先级别的又有 "从左到右" 和 "从右到左" 两种不同的结合方向。优先级和结合方向是由定义函数时定义的。

默认情况下，所以中置函数的优先级别一样，且都遵循 "从左到右" 的结合方向。比如：

* `让 a = 1 + 8 - 3`
* `let a = 1 + 8 - 3`

在求值时，首先会执行表达式 `1 + 8`，得出值 `9` 之后再执行表达式 `9 - 3`，最后得出结果 `6`。

有些函数有较高的优先级，比如：

* `让 b = 1 + 2 * 3`
* `let b = 1 + 2 * 3`

因为 `*` 函数定义的优先级别比 `+` 的要高，所以会先执行表达式 `2 * 3`，得出值 `6` 之后再执行表达式 `1 + 6`，最后得出结果为 `7`。

从右到左的结合方向的函数比较少，常见的有幂运算函数 `^`，比如：

* `让 c = 4 ^ 3 ^ 2`
* `let c = 4 ^ 3 ^ 2`

它会先执行表达式 `3 ^ 2`，得出值 `9` 之后再执行表达式 `4 ^ 9`。
-->
<h3 id="运算符"><a class="header" href="#运算符"><!-- 内置的中置函数的优先级 --> 运算符</a></h3>
<p>XiaoXuan Lang 支持一些常用的运算符，它们在编译时会被替换成中置函数：</p>
<ul>
<li><code>*</code>（<code>乘</code>，<code>mul</code>）</li>
<li><code>/</code>（<code>除</code>，<code>div</code>）</li>
<li><code>+</code>（<code>加</code>，<code>add</code>）</li>
<li><code>-</code>（<code>减</code>，<code>sub</code>)</li>
<li><code>&gt;</code>（<code>大于</code>，<code>greaterThan</code>）</li>
<li><code>&gt;=</code>（<code>大于等于</code>，<code>greaterThanOrEquals</code>）</li>
<li><code>&lt;</code>（<code>小于</code>，<code>lessThan</code>）</li>
<li><code>&lt;=</code>（<code>小于等于</code>，<code>lessThanOrEquals</code>）</li>
<li><code>==</code>（<code>等于</code>，<code>equals</code>）</li>
<li><code>!=</code>（<code>不等于</code>，<code>notEquals</code>）</li>
</ul>
<p>XiaoXuan Lang 不支持自定义运算符号。参考: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</p>
<p>还有一些常用的运算函数，但没有对应的运算符号：</p>
<ul>
<li><code>负</code>，<code>neg</code></li>
<li><code>余</code>，<code>rem</code></li>
<li><code>点乘</code>，<code>dotMul</code>，即两个结构相同的数组逐个元素相乘，或者其中一个是标量）</li>
<li><code>点除</code>，<code>dotDiv</code></li>
<li><code>与</code>，<code>:and</code></li>
<li><code>或</code>，<code>:or</code></li>
<li><code>非</code>，<code>not</code></li>
<li><code>位与</code>，<code>:bitAnd</code></li>
<li><code>位或</code>，<code>:bitOr</code></li>
<li><code>位非</code>，<code>bitNot</code></li>
<li><code>左移</code>，<code>shiftLeft</code></li>
<li><code>右移</code>，<code>shiftRight</code></li>
<li><code>逻辑右移</code>，<code>logicShiftRight</code></li>
</ul>
<p>XiaoXuan Lang 还有一些结构符号，它们不是函数：</p>
<ul>
<li>拆封（<code>?</code>）；</li>
<li>函数的组合（<code>&amp;</code>）；</li>
<li>链式调用表达式（<code>&gt;&gt;</code>）;</li>
<li>拆封表达式（<code>||</code>）；</li>
<li>函数的管道调用（<code>|</code>）；</li>
<li>赋值表达式 (<code>=</code>)；</li>
</ul>
<h3 id="表达式的执行顺序"><a class="header" href="#表达式的执行顺序">表达式的执行顺序</a></h3>
<p>下面列出各种表达式的执行顺序（优先级从高到低排列），如无单独指出，结合顺序默认都是从左到右：</p>
<ol>
<li>分组及语句块，即一对括号或者使用 <code>开始...以上</code>（<code>begin...end</code>）包围起来的部分。分组和语句块的结合顺序是从左到右，比如连续两个括号 <code>(...)()</code> 则先对前一个求值；分组和分组嵌套时，先求内部的再求外部的值 <code>(j+(i+(...)))</code> == <code>... + i + j</code>。</li>
</ol>
<!-- 2. `新建 N::T (...)`（`new N::T (...)`）新建数据实例语句，`新建 T.M.N (...)`（`new T.M.N (...)`）新建联合体成员实例语句；(::考虑取消 new 关键字，直接采用构造函数的普通函数调用即可) -->
<ol start="3">
<li>名称空间路径如 <code>std::collection::Array</code><!--，结合顺序为从左到右。-->
<code>function_name (...)</code> 函数的一般调用；</li>
<li>结构体（联合体、枚举、常量）成员访问（即点号）如 <code>user.name</code>、<code>user.addr.city</code>，列表的索引访问（即中括号加数字下标）如 <code>books[1]</code>、<code>table[1][2]</code>；映射表项目的访问（即中括号加字符串）<code>user[&quot;name&quot;]</code>、<code>user[&quot;name&quot;][&quot;first&quot;]</code>；</li>
<li><code>instance.function_name()</code> 数据实例方法的点号调用，</li>
<li>拆封（<code>?</code>）；</li>
<li>类型转换 （<code>^</code>）</li>
<li>函数的组合（<code>&amp;</code>）（因为有时需要先函数部分调用后再结合，所以函数组合运算符的优先级低于函数调用），结合顺序为从右到左；</li>
<li>算术运算符、比较运算符、函数的中置格式调用；</li>
<li>函数的链式调用（<code>&gt;&gt;</code>）;</li>
<li>带后备的拆封表达式（<code>||</code>）</li>
<li>函数的管道调用（<code>|</code>）；</li>
</ol>
<!-- 13. 线程变量赋值语句(`:=`)。 -->
<ol start="12">
<li>赋值、解构语句（<code>=</code>），结合顺序为从右到左。</li>
</ol>
<p>需要注意的是函数的一般调用方式要比函数的中置调用方式优先级要高，示例：</p>
<ul>
<li><code>让 a = 平方根 (9) + 平方根 (16)</code></li>
<li><code>let a = sqrt (9) + sqrt (16)</code></li>
</ul>
<p>在执行时会先计算两个 <code>平方根</code> 函数，得出值之后再计算 <code>+</code> 函数。</p>
<blockquote>
<p>如果一个结构体的成员是函数，则需要使用把这个数据实例和成员用括号包括起来才能正确调用，比如 <code>(user.func).(arg1, arg2, ...)</code>，如果写成 <code>user.func(arg1, arg2)</code> 会被认为是调用实例方法。一般不建议将函数作为结构体的成员。</p>
</blockquote>
<h2 id="函数的定义"><a class="header" href="#函数的定义">函数的定义</a></h2>
<h3 id="语法-1"><a class="header" href="#语法-1">语法</a></h3>
<p>使用 <code>函数</code>（<code>function</code>） 关键字定义一个函数，格式如下：</p>
<pre><code class="language-js">函数 返回值的数据类型 函数名称 (参数类型1 参数名称1, ..., 参数类型N 参数名称N)
    ...
    函数主体
    ...
以上
</code></pre>
<pre><code class="language-js">function DataType functionName (DataType1 param1, ..., DataTypeN paramN)
    ...
    function body
    ...
end
</code></pre>
<p>函数的主体是一个或多个语句或表达式，最后一个表达式的值将会作为函数的返回值。示例：</p>
<pre><code class="language-js">函数 浮点数 两点距离 (整数 x1, 整数 y1, 整数 x2, 整数 y2)
    让 a = (x2 - x1) ^ 2
    让 b = (y2 - y1) ^ 2
    平方根 (a + b)
以上
</code></pre>
<pre><code class="language-js">function Float distance (Float x1, Float y1, Float x2, Float y2)
    let a = (x2 - x1) ^ 2
    let b = (y2 - y1) ^ 2
    sqrt (a + b)
end
</code></pre>
<p>最后一行的 <code>平方根</code> 函数的结果将会作为函数的返回值。当然也可以加上 <code>return</code> 关键字，在函数主体最后一行的 <code>return</code> 关键字实际上在运行时会直接忽略。</p>
<h4 id="无返回值函数"><a class="header" href="#无返回值函数">无返回值函数</a></h4>
<!--
定义函数时，如果省略了返回值的数据类型：

* 对于普通定义的函数，会自动被认为返回值类型为 `结果<基元, 基元>`（`Result<Unit, Unit>`）（别名 `空型`，`Void`），如果 `返回`（`return`）关键字后面不加任何值，则会自动被认为是 `返回 好(空值)`（`return Ok(void)`），其中 `空值` 值等同于空元组 `()`。
* 对于匿名函数，会根据上下文环境自动推导，推导过程是先查找所处的环境所需要的数据类型，如果无从推导则由返回值来决定。
-->
<p>当一个函数无返回值时，可以使用数据类型 <code>空元型</code>（<code>Unit</code>）表示，空元型数据只有一个值 <code>空元</code>（<code>Empty</code>）。</p>
<p>比如</p>
<pre><code class="language-js">函数 空元型 测试(字符串 a， 字符串 b)
  书写行(`a: {a}, b: {b}`)
以上
</code></pre>
<pre><code class="language-js">function Unit test(String a, String b)
  writeLine(`a: {a}, b: {b}`)
end
</code></pre>
<p>函数的签名是：</p>
<p><code>Unit &lt;- functionName (param1, param2, ...)</code></p>
<blockquote>
<p>定义函数时，可以直接省略返回数据类型，解析器会为函数定义自动添加 <code>Unit</code> 类型作为返回值类型，<code>return</code> 语句也被自动解析为 <code>return Empty</code> 。</p>
</blockquote>
<p>示例：</p>
<pre><code class="language-js">函数 测试(字符串 a， 字符串 b)
  书写行(`a: {a}, b: {b}`)
以上
</code></pre>
<pre><code class="language-js">function test(String a, String b)
  writeLine(`a: {a}, b: {b}`)
end
</code></pre>
<p>注意函数的签名仍然不变：</p>
<p><code>Unit &lt;- functionName (param1, param2, ...)</code></p>
<h4 id="简写形式"><a class="header" href="#简写形式">简写形式</a></h4>
<p>如果函数的主体是一个表达式，则可以把函数的定义写成一行：</p>
<ul>
<li><code>函数 返回值的数据类型 函数名称 (参数类型1 参数名称1, ..., 参数类型n 参数名称n) = 表达式</code></li>
<li><code>function DataType functionName (DataType1 param1, ..., DataTypeN paramN) = expression</code></li>
</ul>
<p>示例：</p>
<ul>
<li><code>函数 整数 加十分 (整数 a) = a + 10</code></li>
<li><code>function Int addTen (Int a) = a + 10</code></li>
</ul>
<p>表达式不一定要求在一行内写完，只要是一个合法的表达式均可， 比较长的表达式也是可以换行的，示例：</p>
<pre><code class="language-js">函数 浮点数 距离 (整数 x1, 整数 y1, 整数 x2, 整数 y2) =
    平方根 (
        (x2 - x1) ^ 2 +
        (y2 - y1) ^ 2)
</code></pre>
<pre><code class="language-js">function Float distance (Int x1, Int y1, Int x2, Int y2) =
    sqrt (
        (x2 - x1) ^ 2 +
        (y2 - y1) ^ 2)
</code></pre>
<p>上例当中的 <code>=</code> 符号、<code>(</code> 符号， <code>+</code> 符号后面均表示语句尚未结束。</p>
<h3 id="函数别名"><a class="header" href="#函数别名">函数别名</a></h3>
<p>可以为一个函数设置另一个名称，使用 <code>别名</code>（<code>alias</code>） 关键字定义函数的别名，语法如下：</p>
<ul>
<li><code>别名 新函数名称 = 原函数名称</code></li>
<li><code>alias newName = originalFunctionName</code></li>
</ul>
<p>示例：</p>
<ul>
<li><code>别名 &quot;+&quot; = 加</code></li>
<li><code>alias &quot;+&quot; = add</code></li>
</ul>
<p>如果函数名称包含有符号，需要将函数名称使用双引号包围起来。</p>
<ul>
<li>别名对一个函数的所有重载均起效。即别名只跟函数的名称有关，跟函数的签名无关；</li>
<li>一般别名的定义跟原函数的定义在同一个作用域里。比如在某个模块里定义的函数，其别名也应该在这个模块里定义；在某个特性里定义的函数，其别名也应该在该特性里定义。</li>
</ul>
<h3 id="匿名函数"><a class="header" href="#匿名函数">匿名函数</a></h3>
<p>使用 <code>匿名函数</code>（<code>fn</code>） 关键字可以定义一个匿名函数，匿名函数没有名称，通常在一个函数内部定义及使用，或者作为参数传给另一个（高阶）函数。</p>
<p>定义匿名函数的语法：</p>
<pre><code class="language-js">让 变量名称 =
    匿名函数 返回值的数据类型 (参数类型1 参数名称1, ..., 参数类型N 参数名称N)
        ...
        # 函数主体
        ...
    以上
</code></pre>
<pre><code class="language-js">let variable =
    fn DataType (DataType1 param1, ..., DataTypeN paramN)
        ...
        # function body
        ...
    end
</code></pre>
<p>跟标准函数的定义一样，如果函数的主体是一个表达式，则可以把匿名函数的定义写成一行：</p>
<ul>
<li><code>让 变量名称 = 匿名函数 返回值的数据类型 (参数类型1 参数名称1, ..., 参数类型N 参数名称N) = 表达式</code></li>
<li><code>let variable = fn DataType (DataType1 param1, ..., DataTypeN paramN) = expression</code></li>
</ul>
<p>示例：</p>
<pre><code class="language-js">让 乘加 = 匿名函数 整数 (整数 a, 整数 x, 整数 b) = a * x + b
让 a = 乘加 (2, 3, 4)
</code></pre>
<pre><code class="language-js">let mulAdd = fn Int (Int a, Int x, Int b) = a * x + b
let a = mulAdd (2, 3, 4)
</code></pre>
<p>XiaoXuan 支持定义完立即调用，因为括号的结合顺序是从左到右，所以会先对第一对括号求值，如果返回值类型是函数，则将第二对括号的内容作为参数，调用该匿名函数。示例：</p>
<ul>
<li><code>让 a = (匿名函数 整数 (整数 a) = a * 2) (4)</code></li>
<li><code>let a = (fn Int (Int a) = a * 2) (4)</code></li>
</ul>
<p>如果一个匿名函数作为参数传给另一个函数，因为参数的类型包含了函数签名的信息，即类型推导能推导出匿名函数的返回值的数据类型及各个参数的数据类型，则可以省略书写返回值的数据类型以及各参数的数据类型。</p>
<p>示例：</p>
<pre><code class="language-js">function pick(List&lt;Int&gt; items, F f) where
    F = Boolean &lt;- (Int)
    ...
end

let numbers = [1, 2, 3, 4, 5]
let fav = pick(numbers, fn (i) = i &gt; 3 )
</code></pre>
<p>上例中的 <code>fn (i) = i &gt; 3</code> 匿名函数省略了返回值数据类型，也省略了参数的数据类型。</p>
<h3 id="匿名函数捕获变量值闭包"><a class="header" href="#匿名函数捕获变量值闭包">匿名函数捕获变量值（闭包）</a></h3>
<p>如果一个匿名函数的主体引用了匿名函数之外的变量，则变量的值会被捕获，即使匿名函数离开了其被定义的作用域，该被捕获的值仍然有效。示例：</p>
<pre><code class="language-js">函数 F 增长(整数 i) 其中
    F = 整数 &lt;- (整数)

    返回 匿名函数 (整数 x) = i + x
以上

让 f1 = 增长 (10)  # 函数 f1 绑定了值为 10 的变量 i
让 f2 = 增长 (20)  # 函数 f2 绑定了值为 20 的变量 i

书写行 (f1 (2)) # 输出 12
书写行 (f2 (2)) # 输出 22
</code></pre>
<pre><code class="language-js">function F inc(Int i) where
    F = Int &lt;- (Int)

    return fn (x) i + x
end

let f1 = inc (10)  # `f1` binds the variable i with value 10
let f2 = inc (20)  # `f2` binds the variable i with value 10

writeLine (f1 (2)) # output 12
writeLine (f2 (2)) # output 22
</code></pre>
<p>在支持可变变量的编程语言里，f1 和 f2 里引用了一个共同的变量 i，假如变量 i 的值（或者 i 的成员的值）被 f1 改变了，则该改变也会反映到 f2 所绑定的变量 i 里，有时这种改变并不是预想的，因此引起错误。示例：</p>
<pre><code class="language-JavaScript">function inc() {
    let fns = [];
    let step = 0;
    for(let i=0; i&lt;10; i++) {
        step +=1;
        let fn = x =&gt; x + step;
        fns.push(fn);
    }

    # fns 里包含 10 个匿名函数，其绑定的 step 的值都是 10，
    # 而不是 1 到 10。

    for(let fn of fns) {
        console.log(fn(5)); # 都输出 15
    }

    # 下面是修正版
    let ffs = [];
    for(let i=0; i&lt;10; i++) {
        let step = i; # 复制 i 值到变量 step
        let fn = x =&gt; x + i;
        ffs.push(fn);
    }

    for(let ff of ffs) {
        console.log(ff(5)); # 依次输出 5,6,7,8, ..., 15
    }
}
</code></pre>
<p>在 JavaScript 环境里，当匿名函数使用自身之外的变量时，变量（不是变量的值，而是变量本身，或者说标识符本身）会被该匿名函数所捕获，如果匿名函数被返回并被传递到其他地方，该捕获仍然存在，即该匿名函数能够一直访问到该变量的最新的值。</p>
<p>示例：</p>
<pre><code class="language-JavaScript">function makeCounter() {
    let n = 1;
    return [
        () =&gt; n = n + 1,
        () =&gt; n = n - 1,
        () =&gt; n
    ]
}

# makeCounter 函数返回一个数组，数组有三个匿名函数，
# 一个递增，一个递减，一个返回当前值

let [inc, dec, get] = makeCounter();
inc();  # 返回 2
inc();  # 返回 3
get();  # 返回 3
dec();  # 返回 2
dec();  # 返回 1
</code></pre>
<p>在 JavaScript 环境里，每个函数被执行时都有两个指针，一个指向父词法环境（即调用者 caller 的词法环境） ，一个指向当前的词法环境（即 callee 自己的词法环境），匿名函数也不例外。当匿名函数被当作返回值跳出所在的函数时，函数尚未被执行，所以没有自己的词法环境。但因为匿名函数有对其所在的环境的引用（即存在上述的第一个指针），所以所在的函数的词法环境不会被回收，会一直被保持者，直到匿名函数被回收为止。</p>
<p>参考《javascript info》的 &quot;作用域与闭包&quot; 一章:
https://zh.javascript.info/closure#step-4-fan-hui-han-shu</p>
<p>XiaoXuan 的变量值是不可变的，因此在匿名函数里引用的外部变量时，仅仅引用了一份该变量的值（对于复制类型的值，则是复制），匿名函数被当作返回值跳出所在的函数之后，如果所在的函数已经执行完毕，则它的词法环境可以放心被回收，XiaoXuan 的垃圾回收效率会更高一些。</p>
<h3 id="简化形式的匿名函数"><a class="header" href="#简化形式的匿名函数">简化形式的匿名函数</a></h3>
<p>正如前两节所说，如果一个匿名函数在一个函数签名确定的上下文环境里（比如作为一个参数传给另一个函数），那么匿名函数可以省略书写返回值数据类型以及参数的数据类型。在这种情况下，XiaoXuan 支持一种简化形式的匿名函数格式。语法是使用符号 <code>=&gt;</code> 分隔参数和函数主体部分，如果参数的只有一个，则连参数的括号都可以省略。</p>
<p>简化形式的匿名函数也可以称为 &quot;箭头函数&quot;。</p>
<p>示例：</p>
<pre><code class="language-js"># 假设函数签名为： Int &lt;- (Int)
匿名函数 Int (Int x) = x + 10 # 标准版匿名函数
匿名函数 (x) = x + 10         # 省略数据类型的匿名函数
x =&gt; x + 10                  # 简化版匿名函数

# 假设函数签名为：Int &lt;- (Int, Int)
匿名函数 Int (Int x, Int y) = sqrt(x^2 + y^2) # 标准版匿名函数
匿名函数 (x, y) = sqrt(x^2 + y^2)             # 省略数据类型的匿名函数
(x,y) =&gt; sqrt(x^2 + y^2)                     # 简化版匿名函数
</code></pre>
<pre><code class="language-js"># function signature: Int &lt;- (Int)
fn Int (Int x) = x + 10 # standard anonymous function
fn (x) = x + 10         # standard anonymous function without data types
x =&gt; x + 10               # simplified anonymous function

# function signature：Int &lt;- (Int, Int)
fn Int (Int x, Int y) = sqrt(x^2 + y^2) # standard anonymous function
fn (x, y) = sqrt(x^2 + y^2)             # standard anonymous function without data types
(x, y) =&gt; x^2 + y^2                    # simplified anonymous function
</code></pre>
<p>下面是一个实际的例子：</p>
<pre><code class="language-js">让 s = [1, 2, 3, 4, 5, 6];
让 翻倍s = s.映射(x =&gt; x * 2)
</code></pre>
<pre><code class="language-js">let s = [1, 2, 3, 4, 5, 6];
let double_s = s.map(x =&gt; x * 2)
</code></pre>
<p><code>映射</code>（<code>map</code>）的函数签名为 <code>List&lt;E&gt; map&lt;T, E=T&gt;(List&lt;T&gt;, E &lt;- (T))</code>，其中第 2 个参数接受一个函数，该函数的作用是从一个数 <code>T</code> 转换成另外一个数 <code>E</code>，它是一个转换函数，<code>map</code> 函数的作用就是将一列数根据你的需要转换得另外一列数。比如你的转换函数是将传入的整数乘于 2,那么输入 <code>[1,2,3]</code> 经过 <code>map</code> 转换得出 <code>[2,4,6]</code>。</p>
<p>上例中，变量 s 的数据类型是 <code>列表&lt;整数&gt;</code>（<code>List&lt;Int&gt;</code>）, 由类型推导出 <code>map</code> 函数个类型参数是 <code>List&lt;Int&gt; map(List&lt;Int&gt;, Int &lt;- (Int))</code>，其中转换函数的签名为：</p>
<ul>
<li><code>整数 &lt;- (整数)</code></li>
<li><code>Int &lt;- (Int)</code></li>
</ul>
<p>因此我们需要可以构造一个符合这个签名的匿名函数：</p>
<ul>
<li><code>匿名函数 整数 (整数 n) = n * 2</code></li>
<li><code>fn Int (Int n) = n * 2</code></li>
</ul>
<p>这个匿名函数的定义可以省略数据类型：</p>
<ul>
<li><code>匿名函数 (n) = n * 2</code></li>
<li><code>fn (n) = n * 2</code></li>
</ul>
<p>进一步简化该匿名函数：</p>
<ul>
<li><code>x =&gt; x * 2</code></li>
</ul>
<p>跟标准的匿名函数一样，简化版匿名函数也是支持多行的，只要在冒号 <code>:</code> 后面写上表示语句块的 <code>开始</code>（<code>begin</code>），然后写多行函数体，再以 <code>以上</code>（<code>end</code>）关键字表示结束，示例：</p>
<pre><code class="language-js">让 翻倍s = s.映射(x =&gt;
    开始
        x * 2
    以上)
</code></pre>
<pre><code class="language-js">let double_s = s.map(x =&gt;
    begin
        x * 2
    end)
</code></pre>
<h3 id="返回-关键字"><a class="header" href="#返回-关键字"><code>返回</code> 关键字</a></h3>
<p><code>返回</code>（<code>return</code>） 关键字用于立即退出当前的函数，可以带着一个返回值。</p>
<p>示例：</p>
<pre><code class="language-js">函数 整数 处理(整数 a)
    ...
    如果 ... 那么 返回 123
    ...
以上
</code></pre>
<p>当程序执行到 <code>返回</code> 语句时，不管当时正在执行到函数主体的哪条语句，都会立即返回一个值给调用者，并且放弃执行 <code>返回</code> 语句之后的语句。</p>
<h4 id="省略-返回-关键字"><a class="header" href="#省略-返回-关键字">省略 <code>返回</code> 关键字</a></h4>
<p>因为函数的最后一个表达式的值会自动成为函数的返回值，所以如果 <code>返回</code> 关键子位于函数的最后一行，则可以省略这个关键字。</p>
<h4 id="匿名函数当中的-返回-关键字"><a class="header" href="#匿名函数当中的-返回-关键字">匿名函数当中的 <code>返回</code> 关键字</a></h4>
<p>如果 <code>返回</code> 关键字位于匿名函数，包括简写版匿名函数 <code>:</code>，则它仅仅退出当前的匿名函数，而不会退出外部的函数。</p>
<p>示例：</p>
<pre><code class="language-js">函数 整数 处理(整数 a)
    ...
    让 整数 b = 匿名函数(整数 c)
        ...
        如果 ... 那么 返回 456
        ...
    以上
    ...
以上
</code></pre>
<p>上例当中的 <code>返回</code> 仅仅将 <code>456</code> 返回给变量 <code>b</code>，而不是返回给函数 <code>处理</code> 的调用者。</p>
<h4 id="流程控制语句当中的-返回-关键字"><a class="header" href="#流程控制语句当中的-返回-关键字">流程控制语句当中的 <code>返回</code> 关键字</a></h4>
<p>在诸如 <code>如果</code>，<code>分支</code>，<code>选择</code>，<code>条件</code>， <code>遍历</code> 等等语句里，<code>返回</code>（<code>退出</code>）关键字都是直接退出语句所在的函数。</p>
<h4 id="尾部调用"><a class="header" href="#尾部调用">尾部调用</a></h4>
<p>如果一个函数主体的最后一行是调用函数自己，则称之为 &quot;尾部调用&quot;。XiaoXuan 运行环境会对尾部调用进行优化，不创建调用栈，防止堆栈溢出。</p>
<p>示例：</p>
<pre><code class="language-js">01  函数 整数 累加(整数 i)
02      让 内循环 = 匿名函数(整数 current, 整数 total)
03          如果 current == 0 那么 返回 total
04          让 s = total + current
05          内循环 (current - 1, s)
06      以上
07
08      返回 内循环(i ,0)
09  以上
10
11  让 c = 累加(100)
</code></pre>
<p>上例中第 05 行调用了其所在的函数 &quot;内循环&quot;，且是最后一句，所以是尾部调用。</p>
<p>注意尾部调用必须是<strong>单纯的</strong>调用函数自身（返回值可以是任意符合参数要求的值），且必须位于函数主体的<strong>最后一句</strong>。</p>
<p>示例：</p>
<pre><code class="language-js">01  函数 整数 累加(整数 i)
02      让 内循环 = 匿名函数(整数 current, 整数 total)
03          如果 current == 0 那么
04              返回 total
05          否则
06              让 s = total + current
07              内循环 (current - 1, s)
08          以上
09      以上
</code></pre>
<p>上面的代码跟上一个示例的语义是完全一样的，但 XiaoXuan 仅简单地依据是否最后一句来判断是否尾部调用，因为 07 行之后还有 <code>以上</code> 一句，所以被运行时认为不是尾部调用。</p>
<h3 id="函数的重载"><a class="header" href="#函数的重载">函数的重载</a></h3>
<p>可以定义两个或以上名称相同、返回值的数据类型相同，但参数列表不同的函数，这种情况称为函数的重载。函数重载一般是为了让调用者可以有选择地灵活调用函数。</p>
<p>示例：</p>
<pre><code class="language-js">01  函数 说 (字符串 name) = 书写行 (name)
02  函数 说 (字符串 name, 字符串 sentence) = 格式化书写行 (&quot;{} 你好, {}&quot;, name, sentence)
03
04  说 (&quot;张三&quot;, &quot;吃饭了吗&quot;) # 调用 02 函数
05  说 (&quot;张三&quot;) # 调用 01 函数
</code></pre>
<pre><code class="language-js">01  function say (String name) = writeLine (name)
02  function say (String name, String sentence) = formatWriteLine (&quot;Hi {}, {}&quot;, name, sentence)
03
04  say (&quot;Foo&quot;, &quot;What's up&quot;) # call 02
05  say (&quot;Foo&quot;) # call 01
</code></pre>
<ul>
<li>函数重载要求参数列表必须<strong>不相同</strong>，可以是参数数量不相同，可以是参数的类型不相同，<!-- 可以是参数的模式不相同，--> 或者两者皆不相同。</li>
<li>函数重载要求返回值数据类型必须<strong>相同</strong>，实际上，在同一个模块里不允许同名但不同返回值类型的函数。</li>
</ul>
<h4 id="跨模块重载不支持"><a class="header" href="#跨模块重载不支持">跨模块重载（::不支持）</a></h4>
<p>函数重载也可以重载其他模块的函数，假设模块 &quot;a&quot; 有函数 &quot;Int calc(Int i)&quot;，则在模块 &quot;b&quot; 也能重载该函数，方法是先把模块 &quot;a&quot; 的目标函数导入到模块 &quot;b&quot;，然后在 &quot;b&quot; 的模块范围内定义一个参数不同的同名函数即可。</p>
<p>示例：</p>
<pre><code class="language-js">module b

# import a function from another module
import a.calc

# overload the function
function Int calc(Float i)
    # ...
end
</code></pre>
<h4 id="参数的默认值和可选参数"><a class="header" href="#参数的默认值和可选参数">参数的默认值和可选参数</a></h4>
<p>函数的参数支持指定默认值，带有默认值的参数在调用时可以省略，所以这种参数也叫做 &quot;可选参数&quot;。相对地，位置参数也可以叫做 &quot;必选参数&quot;。</p>
<p>一个函数的可选参数可以有零个或多个，但只能在排在必选参数之后，也就是可选参数必须排在参数列表的末尾。</p>
<p>示例：</p>
<pre><code class="language-js">function draw(Point p, Int width = 1, Color color = ColorConst::Black)
</code></pre>
<p>上面的后两个参数 <code>width</code> 和 <code>color</code> 即为可选参数。</p>
<p>跟常量的定义一样，默认值只能是基本的数据或者是结构体、联合体的默认构造函数所产生的值。</p>
<p>对于带有可选参数的函数，其签名的参数列表是所有参数。即无论是必选参数还是可选参数，都属于函数签名，且无视参数名和默认值。比如上例的函数其签名为：</p>
<pre><code class="language-js">void &lt;- (Point, Int, Color)
</code></pre>
<blockquote>
<p>可选参数只是函数调用的语法糖，当一个函数调用省略了某些参数的值时，运行时会从函数的定义里获取默认值，然后补齐缺少的参数值，再调用目标函数。</p>
</blockquote>
<h3 id="重载冲突"><a class="header" href="#重载冲突">重载冲突</a></h3>
<p>函数重载要求参数的类型或者个数不同，这条规则同样适用于带有可选参数的函数。即在判断一个重载是否有冲突时，<strong>无视参数名称</strong>，仅依据参数的数据类型和顺序来判断。</p>
<p>假设有如下两个函数重载：</p>
<pre><code class="language-js">function test(Int a, String b, Int c = 88) = ...
function test(Int a, String x = &quot;foo&quot;, Int y = 99) = ...
</code></pre>
<p>如果仅看必选参数部分，其函数签名似乎不存在冲突，如下：</p>
<pre><code class="language-js">void &lt;- (Int a, String b)
void &lt;- (Int a)
</code></pre>
<p>然而 XiaoXuan 的判断规则是无视是否可选参数、也无视参数名，所以它们的真正函数签名是存在冲突的，如下：</p>
<pre><code class="language-js">void &lt;- (Int, String, Int)
void &lt;- (Int, String, Int)
</code></pre>
<p>之所以如此判断，是因为 XiaoXuan 优先支持按位置传参，当一个函数调用仅使用位置传参时，显然它仅看参数的数据类型和顺序。</p>
<p>具体的判断重载是否有冲突的步骤如下：</p>
<ol>
<li>将所有重载的可选参数去除；</li>
<li>按照必选参数的数量从少到多排序；</li>
<li>然后挑选必选参数最少的那个重载，扫描一遍是否存在签名一样（仅看参数的数据类型和顺序）的重载，存在则说明存在冲突，判断结束；</li>
<li>逐个可选参数添加，每添加一个，都扫描一次是否存在签名一样的重载，存在则说明存在冲突，判断结束；</li>
<li>当所有可选参数都添加并且确定无冲突时，排除此重载，即将此重载从判断列表中移除。然后重复第 3 到第 5 步。</li>
<li>当所有的重载都不存在冲突时，则说明此函数的定义是语法正确的。</li>
</ol>
<!--
如果一个函数存在重载，且重载当中存在可选参数，则必须保证各个重载不存在歧义的参数列表，否则会引起运行时异常。

示例：

```js
function drawA(Point p)
  ...
end

function drawA(Point p, Int width = 1)
  # Invalid
end

function drawB(Point p, Color c)
  ...
end

function drawB(Point p, Int width = 1, Color c = ColorConst::Black)
  # Invalid
end

function drawC(Point p, Color c)
  ...
end

function drawC(Point p, Int width = 1)
  # OK
end

function drawD(Point p, Color c = ColorConst::Black)
  ...
end

function drawC(Point p, Int width = 1)
  # OK
end
```

上面的 `drawA` 和 `drawB` 的第 2 个函数定义都会引起运行时异常，因为它的必选参数部分跟另外两个函数的数据类型相同，且可选参数会跟其他重载存在歧义。

具体过程是，在语法解析之后，运行环境会把存在可选参数的函数当中的可选部分当作不存在，然后拿必选参数部分跟其他重载比较：

1. 如果参数类型不一样，则认为是合法的重载，没进一步比较的必要；
2. 如果参数类型一样，则拿取正在比较的两个函数的剩余部分参数（不分必选还是可选），只有有一个参数集合是空的，或者两个集合存在交集，都认为是非法重载。

有这样的限制，主要是为了消除歧义，在调用之前调用者就已经（通过静态分析）可以确认它真正调用的是哪个重载。
-->
<p>需注意的：</p>
<ul>
<li>即使函数重载的定义不存在冲突，在调用时，如果调用语句使用了按参数名称传参，则仍然存在冲突的可能，详细见函数调用冲突章节；</li>
<li>XiaoXuan 语句的函数调用优先匹配参数的数据类型和顺序，此时将无视参数的名称，这部分匹配完毕之后，再根据调用语句当中的名称参数跟函数定义当中剩余的参数进行名称匹配。</li>
<li>为了方便静态分析和编译，同时也是为了降低语言实现的难度，XiaoXuan 语言<strong>不支持变长参数</strong>。</li>
</ul>
<!--
### 函数的模式匹配（::不支持）

函数的参数不仅仅用于引用或记录传入的参数值（类似赋值语句），同时还能作为模式匹配，即只有实参跟参数要求的模式相匹配时，该参数才会获取相应的值。示例：

```js
01  函数 显示余数 (Int a, Int 0) = 书写行 ("除数不能为零")
02  函数 显示余数 (Int a, Int b) = 格式化书写行 ("余数为 {}", a `余` b)
03
04  显示余数 (5, 2) # 02 行函数被调用
05  显示余数 (5, 0) # 01 行函数被调用
```

```js
01  function showRemain (Int a, Int 0) = writeLine ("The divisor cannot be zero")
02  function showRemain (Int a, Int b) = writeLine ("The remainder is {}", a `rem` b)
03
04  showRemain (5, 2) # 02 function is invoked
05  showRemain (5, 0) # 01 function is invoked
```

运行环境会根据函数的定义顺序，对每个函数的参数列表进行匹配，只有匹配中的那个函数定义才会被执行。

函数重载其实也是函数模式匹配的一种，对一个函数的匹配顺序是：

1. 检查参数的个数；
2. 检查每个参数的数据类型；
3. 检查每个参数是否模式匹配。

详细的模式匹配见 [08 模式](pattern-and-matching.md)
-->
<h3 id="分支函数"><a class="header" href="#分支函数">分支函数</a></h3>
<p>可以在函数定义后面使用关键字 <code>分支</code>（<code>branch</code>）让函数根据不同的条件执行不同的主体，这种函数称为 &quot;分支函数&quot;。</p>
<p>分支函数的关键字是 <code>分支</code>（<code>branch</code>），写在函数的参数列表，或者 <code>其中</code>（<code>where</code>）列表之后，也可以单独一行写。然后是一个或多个使用 <code>情况</code>（<code>case</code>） 关键字的条件分支。</p>
<p>改写上一个示例如下：</p>
<pre><code class="language-js">01  函数 显示余数 (Int a, Int b) 分支
02      情况 b == 0: 书写行 (&quot;除数不能为零&quot;)
03      情况 b &gt; a: 书写行 (&quot;除数比被除数还大&quot;)
04      情况 b == a: 书写行 (&quot;没有余数&quot;)
05      默认: 书写行 (&quot;余数为 {}&quot;, a `余` b)
06  以上
07
08  显示余数 (5, 0) # 执行 02 行
09  显示余数 (5, 6) # 执行 03 行
10  显示余数 (5, 5) # 执行 04 行
11  显示余数 (5, 2) # 执行 05 行
</code></pre>
<pre><code class="language-js">01  function showRemain (Int a, Int b) branch
02      case b == 0: writeLine (&quot;The divisor cannot be zero&quot;)
03      case b &gt; a: writeLine (&quot;divisor is larger than dividend&quot;)
04      case b == a: writeLine (&quot;no remainder&quot;)
05      default: writeLine (&quot;The remainder is {}&quot;, a `rem` b)
06  end
07
11  showRemain (5, 0) # execute line 02
10  showRemain (5, 6) # execute line 03
08  showRemain (5, 5) # execute line 04
09  showRemain (5, 2) # execute line 05
</code></pre>
<p>每一个分支情况后面都接着一个能返回逻辑值的表达式，当表达式返回 <code>真</code> 时，该分支会被执行。<code>分支</code> 语句的语法跟 <code>条件</code> 语句一样（<code>分支</code> 语句是 <code>条件</code> 语句的语法糖，如果 <code>分支</code> 里缺少 <code>默认</code> 分支，则运行时会自动添加一个抛出运行时异常的默认分支）。条件语句的详细用法请参见 <a href="control-flow.html">流程控制</a>。</p>
<p>每一个分支都是独立的一个函数主体。如果函数主体是多行语句，则需要在语句 <code>情况</code>（<code>case</code>）关键字后面换行写。</p>
<p>最后一个分支通常是不限任何条件的默认分支，如果没有默认分支，当所有的条件都不满足时，运行环境会抛出一个运行时错误。</p>
<h4 id="函数的分支与数学的函数定义"><a class="header" href="#函数的分支与数学的函数定义">函数的分支与数学的函数定义</a></h4>
<p>带分支语句的函数与数学的函数定义非常接近，考虑如下一个函数：</p>
<pre><code class="language-js">function int check (Int x) branch
    case x &gt;= 90: 1
    case x &gt;= 80: 2
    case x &gt;= 70: 3
    case x &gt;= 60: 4
    default: 5
end
</code></pre>
<p>对应的数学函数：</p>
<p>[
check(x)=
\begin{cases}
1,  &amp; \text{if } x \geq 90\
2,  &amp; \text{if } x \geq 80\
3,  &amp; \text{if } x \geq 70\
4,  &amp; \text{if } x \geq 60\
5,  &amp; \text{otherwise}
\end{cases}
]</p>
<h2 id="纯函数"><a class="header" href="#纯函数">纯函数</a></h2>
<p>纯函数是指函数的返回值只跟输入的参数值有关，跟所在的上下文环境无关，而且只要输入参数值一样，总能得出一样的结果值。</p>
<p>典型的纯函数如 <code>加</code>，<code>减</code> 等算术函数，运行环境提供了一系列纯函数，这些函数被标上 <code>@pure</code> 标注。</p>
<p>需要注意纯函数必须有具有意义的输入参数和返回值，当用户定义的函数只调用纯函数时，它自身也会自动成为纯函数。</p>
<p>XiaoXuan 运行环境能够对纯函数作优化处理，比如延迟执行、缓存结果、并行执行等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据容器"><a class="header" href="#数据容器">数据容器</a></h1>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="collection.html#%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8">数据容器</a>
<ul>
<li><a href="collection.html#%E5%88%97%E8%A1%A8">列表</a>
<ul>
<li><a href="collection.html#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%84%E5%BB%BA%E5%88%97%E8%A1%A8">使用构造函数构建列表</a></li>
<li><a href="collection.html#%E8%8E%B7%E5%8F%96%E5%88%97%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6">获取列表的长度</a></li>
<li><a href="collection.html#%E8%AE%BF%E9%97%AE%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0">访问列表的元素</a>
<ul>
<li><a href="collection.html#%E8%8E%B7%E5%8F%96%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">获取第一个元素</a></li>
<li><a href="collection.html#%E8%8E%B7%E5%8F%96%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B9%8B%E5%A4%96%E7%9A%84%E5%85%83%E7%B4%A0">获取第一个元素之外的元素</a></li>
<li><a href="collection.html#%E8%8E%B7%E5%8F%96%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">获取最后一个元素</a></li>
<li><a href="collection.html#%E8%8E%B7%E5%8F%96%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%B9%8B%E5%A4%96%E7%9A%84%E5%85%83%E7%B4%A0">获取最后一个之外的元素</a></li>
<li><a href="collection.html#%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%BD%AE%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0">根据位置获取元素</a>
<ul>
<li><a href="collection.html#%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%8B%AC%E5%8F%B7%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0">使用中括号获取指定位置的元素</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="collection.html#%E9%80%89%E5%8F%96%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E7%9A%84%E5%85%83%E7%B4%A0">选取指定范围的元素</a>
<ul>
<li><a href="collection.html#%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%8B%AC%E5%8F%B7%E9%80%89%E5%8F%96%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E7%9A%84%E5%85%83%E7%B4%A0">使用中括号选取指定范围的元素</a>
<ul>
<li><a href="collection.html#%E7%9C%81%E7%95%A5-%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0">省略 &quot;元素个数&quot;</a></li>
<li><a href="collection.html#%E7%9C%81%E7%95%A5-%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE">省略 &quot;开始位置&quot;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="collection.html#%E8%8E%B7%E5%8F%96%E5%BC%80%E5%A7%8B%E9%83%A8%E5%88%86%E7%9A%84%E5%85%83%E7%B4%A0">获取开始部分的元素</a></li>
<li><a href="collection.html#%E8%B7%B3%E8%BF%87%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0">跳过部分元素</a></li>
<li><a href="collection.html#%E4%BF%AE%E6%94%B9%E5%88%97%E8%A1%A8">修改列表</a></li>
<li><a href="collection.html#%E5%A2%9E%E5%8A%A0%E5%85%83%E7%B4%A0">增加元素</a></li>
<li><a href="collection.html#%E8%BF%BD%E5%8A%A0%E5%85%83%E7%B4%A0%E6%88%96%E5%88%97%E8%A1%A8">追加元素或列表</a></li>
<li><a href="collection.html#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">删除元素</a></li>
<li><a href="collection.html#%E8%BF%87%E6%BB%A4%E5%85%83%E7%B4%A0">过滤元素</a></li>
<li><a href="collection.html#%E6%8B%86%E5%88%86%E5%88%97%E8%A1%A8">拆分列表</a></li>
<li><a href="collection.html#%E8%BF%9E%E6%8E%A5%E5%88%97%E8%A1%A8">连接列表</a></li>
<li><a href="collection.html#%E8%A3%81%E5%89%AA">裁剪</a></li>
<li><a href="collection.html#%E8%A1%A5%E9%BD%90">补齐</a></li>
<li><a href="collection.html#%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97">重复序列</a>
<ul>
<li><a href="collection.html#%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2">重复字符串</a></li>
</ul>
</li>
<li><a href="collection.html#%E5%B9%B3%E5%88%86%E5%88%97%E8%A1%A8">平分列表</a></li>
<li><a href="collection.html#%E5%88%86%E9%9A%94%E5%88%97%E8%A1%A8">分隔列表</a></li>
<li><a href="collection.html#%E6%8B%BC%E6%8E%A5-todo"><code>拼接</code> ::TODO</a></li>
<li><a href="collection.html#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E6%88%96%E5%88%97%E8%A1%A8">插入元素或列表</a></li>
<li><a href="collection.html#%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%E6%88%96%E5%88%97%E8%A1%A8">替换元素或列表</a></li>
<li><a href="collection.html#%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8-todo">排序列表 ::TODO</a></li>
<li><a href="collection.html#%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A8-todo">反转列表 ::TODO</a></li>
<li><a href="collection.html#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E6%88%96%E5%AD%90%E5%88%97%E8%A1%A8%E7%9A%84%E5%87%BA%E7%8E%B0%E4%BD%8D%E7%BD%AE">查找元素或（子）列表的出现位置</a></li>
<li><a href="collection.html#reversefindposition">reverseFindPosition</a></li>
<li><a href="collection.html#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0">查找元素</a></li>
<li><a href="collection.html#%E6%A3%80%E6%9F%A5%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8">检查指定元素是否存在</a>
<ul>
<li><a href="collection.html#%E5%AD%98%E5%9C%A8%E5%BC%80%E5%A7%8B-todo">存在开始 ::TODO</a></li>
<li><a href="collection.html#%E5%AD%98%E5%9C%A8%E7%BB%93%E6%9D%9F-todo">存在结束 ::TODO</a></li>
</ul>
</li>
<li><a href="collection.html#%E5%85%A8%E9%83%A8%E5%8C%B9%E9%85%8D-todo"><code>全部匹配</code> ::TODO</a></li>
<li><a href="collection.html#%E9%80%90%E4%B8%AA-%E5%87%BD%E6%95%B0"><code>逐个</code> 函数</a></li>
<li><a href="collection.html#%E6%9E%9A%E4%B8%BE">枚举</a></li>
<li><a href="collection.html#%E6%98%A0%E5%B0%84-todo"><code>映射</code> ::TODO</a></li>
<li><a href="collection.html#%E6%8A%98%E5%8F%A0-todo">折叠 ::TODO</a></li>
<li><a href="collection.html#%E5%8F%B3%E6%8A%98%E5%8F%A0-todo">右折叠 ::TODO</a></li>
<li><a href="collection.html#%E6%9E%84%E5%BB%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%88%97%E8%A1%A8">构建随机数列表</a></li>
</ul>
</li>
<li><a href="collection.html#%E6%95%B0%E5%88%97">数列</a>
<ul>
<li><a href="collection.html#%E6%AD%A5%E8%BF%9B%E5%80%BC">步进值</a></li>
<li><a href="collection.html#%E7%BA%BF%E6%80%A7%E5%80%BC">线性值</a></li>
<li><a href="collection.html#%E5%8A%A8%E6%80%81%E6%8C%87%E5%AE%9A%E5%BC%80%E5%A7%8B%E5%80%BC-%E7%BB%93%E6%9D%9F%E5%80%BC%E5%92%8C%E6%AD%A5%E8%BF%9B%E5%80%BC">动态指定开始值、结束值和步进值</a></li>
<li><a href="collection.html#%E6%B5%AE%E7%82%B9%E6%95%B0%E6%95%B0%E5%88%97">浮点数数列</a></li>
<li><a href="collection.html#%E5%AD%97%E7%AC%A6%E6%95%B0%E5%88%97-%E6%9C%AA%E6%94%AF%E6%8C%81">字符数列 (::未支持)</a></li>
<li><a href="collection.html#%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C">延迟执行</a></li>
<li><a href="collection.html#%E7%9C%81%E7%95%A5%E7%BB%93%E6%9D%9F%E5%80%BC">省略结束值</a></li>
</ul>
</li>
<li><a href="collection.html#%E6%95%B0%E5%88%97%E9%9B%86">数列集</a></li>
<li><a href="collection.html#%E6%95%B0%E7%BB%84">数组</a>
<ul>
<li><a href="collection.html#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>
<ul>
<li><a href="collection.html#touppercase">toUpperCase</a></li>
<li><a href="collection.html#tolowercase">toLowerCase</a></li>
<li><a href="collection.html#%E8%A3%81%E5%89%AA%E7%A9%BA%E7%99%BD-todo">裁剪空白 ::TODO</a></li>
<li><a href="collection.html#%E5%85%A8%E9%83%A8%E6%9B%BF%E6%8D%A2-todo">全部替换 ::TODO</a></li>
</ul>
</li>
<li><a href="collection.html#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">多维数组</a></li>
<li><a href="collection.html#%E7%9F%A9%E9%98%B5">矩阵</a></li>
</ul>
</li>
<li><a href="collection.html#%E5%88%97%E8%A1%A8-%E6%95%B0%E7%BB%84-%E5%88%97%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83">列表、数组、列表的比较</a>
<ul>
<li><a href="collection.html#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a></li>
</ul>
</li>
<li><a href="collection.html#%E5%BA%8F%E5%88%97%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">序列的常用函数</a>
<ul>
<li><a href="collection.html#%E6%95%B0%E5%AD%97%E5%88%97%E8%A1%A8">数字列表</a></li>
<li><a href="collection.html#%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">字符列表</a></li>
</ul>
</li>
<li><a href="collection.html#%E8%A1%A8%E6%A0%BC">表格</a></li>
<li><a href="collection.html#%E6%98%A0%E5%B0%84%E8%A1%A8">映射表</a>
<ul>
<li><a href="collection.html#%E8%AE%BF%E9%97%AE%E6%98%A0%E5%B0%84%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0">访问映射表的元素</a>
<ul>
<li><a href="collection.html#%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%8B%AC%E5%8F%B7%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E9%94%AE%E7%9A%84%E5%80%BC">使用中括号获取指定键的值</a></li>
<li><a href="collection.html#%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%84%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E9%94%AE%E7%9A%84%E5%80%BC">使用模式解构获取指定键的值</a></li>
</ul>
</li>
<li><a href="collection.html#%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84-%E9%94%AE-%E5%80%BC%E5%AF%B9">添加新的 &quot;键-值对&quot;</a></li>
<li><a href="collection.html#%E6%9B%B4%E6%96%B0%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E9%94%AE%E5%80%BC">更新已存在的键值</a></li>
<li><a href="collection.html#%E6%B7%BB%E5%8A%A0%E6%88%96%E6%9B%B4%E6%96%B0-%E9%94%AE-%E5%80%BC%E5%AF%B9">添加或更新 &quot;键-值对&quot;</a>
<ul>
<li><a href="collection.html#%E4%BD%BF%E7%94%A8%E4%B8%89%E4%B8%AA%E7%82%B9%E6%9D%A5%E6%B7%BB%E5%8A%A0%E6%88%96%E6%9B%B4%E6%96%B0-%E9%94%AE-%E5%80%BC%E5%AF%B9">使用三个点来添加或更新 &quot;键-值对&quot;</a></li>
</ul>
</li>
<li><a href="collection.html#%E6%A3%80%E6%9F%A5%E6%8C%87%E5%AE%9A%E9%94%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8">检查指定键是否存在</a></li>
<li><a href="collection.html#%E5%88%A0%E9%99%A4-%E9%94%AE-%E5%80%BC%E5%AF%B9">删除 &quot;键-值对&quot;</a></li>
<li><a href="collection.html#%E5%88%A0%E9%99%A4%E5%A4%9A%E4%B8%AA-%E9%94%AE-%E5%80%BC%E5%AF%B9">删除多个 &quot;键-值对&quot;</a></li>
<li><a href="collection.html#%E8%BF%87%E6%BB%A4-%E9%94%AE-%E5%80%BC%E5%AF%B9">过滤 &quot;键-值对&quot;</a></li>
<li><a href="collection.html#%E9%81%8D%E5%8E%86%E6%98%A0%E5%B0%84%E8%A1%A8%E5%85%83%E7%B4%A0">遍历映射表元素</a></li>
</ul>
</li>
<li><a href="collection.html#%E9%9B%86%E5%90%88">集合</a>
<ul>
<li><a href="collection.html#%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%99%AE%E9%80%9A%E5%88%97%E8%A1%A8">转换为普通列表</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->
<h2 id="列表"><a class="header" href="#列表">列表</a></h2>
<p>多个数据类型相同的数据依次连接便形成 <code>列表</code>（<code>List</code>）。</p>
<p>列表的字面量使用一对中括号 <code>[...]</code> 包围所有数据，每项数据称为 &quot;元素&quot;，元素之间使用逗号分隔。</p>
<p>示例：</p>
<pre><code class="language-js">让 a = [1, 2, 3]
让 b = [3.14, 2.718, 0.618]
让 c = [&quot;天地玄黄&quot;, &quot;宇宙洪荒&quot;, &quot;日月盈昃&quot;, &quot;辰宿列张&quot;]
让 d = [真, 假, 假, 真]
</code></pre>
<pre><code class="language-js">let a = [1, 2, 3]
let b = [3.14, 2.718, 0.618]
let c = [&quot;twinkle&quot;, &quot;twinkle&quot;, &quot;little&quot;, &quot;star&quot;]
let d = [true, false, false, true]
</code></pre>
<p>上面的语句分别构建了四个列表：</p>
<ul>
<li><code>列表&lt;整数&gt;</code>（<code>List&lt;Int&gt;</code>）</li>
<li><code>列表&lt;浮点数&gt;</code>（<code>List&lt;Float&gt;</code>）</li>
<li><code>列表&lt;字符串&gt;</code>（<code>List&lt;String&gt;</code>）</li>
<li><code>列表&lt;逻辑&gt;</code>（<code>List&lt;Boolean&gt;</code>）</li>
</ul>
<p>一个列表里不能同时存在不同类型的元素，比如下列的语句是错误的：</p>
<pre><code class="language-js">让 a = [100, 200, 2.9979e8, 6.67e-11]  # 前两个元素是整数型，后两个是浮点型。
让 b = [&quot;寒来暑往&quot;, 真, &quot;秋收冬藏&quot;]     # 前后两个是字符串型，中间是逻辑型。
</code></pre>
<pre><code class="language-js">let a = [100, 200, 2.9979e8, 6.67e-11] # there are both Int and Float
let b = [&quot;hickory&quot;, true, &quot;dickory&quot;]  # there are both String and Boolean
</code></pre>
<p>注意：</p>
<ul>
<li>列表最后一个元素后面可以加逗号，也可以不加。</li>
<li>列表的元素可以分行写。</li>
</ul>
<h3 id="使用构造函数构建列表"><a class="header" href="#使用构造函数构建列表">使用构造函数构建列表</a></h3>
<p>使用构造函数也可以构建一个列表。</p>
<p>示例：</p>
<ul>
<li>让 a1 = 新建 数组(5, 0)</li>
<li>let a1 = new Array(5, 0)</li>
</ul>
<p>构造函数的第一个参数指定列表的长度，第二个参数指定元素的初始值。</p>
<p>上面示例构建了一个有 5 个元素，且所有元素的值都是整数 0 的列表，即 <code>[0, 0, 0, 0, 0]</code>。</p>
<p>需要注意的是，列表一旦构建之后，其长度和元素的值都是无法更改的。</p>
<h3 id="获取列表的长度"><a class="header" href="#获取列表的长度">获取列表的长度</a></h3>
<p>使用 <code>长度</code>（<code>length</code>）函数可以获取列表元素的数量（有时也称为列表的 <code>大小</code>，<code>size</code>）。</p>
<p>示例：</p>
<pre><code class="language-js">让 i = a.长度()
# 让 i = 长度 (a)
</code></pre>
<pre><code class="language-js">let i = a.length()
# let i = length (a)
</code></pre>
<p>注意上面列出的两句是等效的，即 <code>长度</code> 这个函数既能单独调用，也能够以列表的方法的方式调用，详细见 <a href="function.html">函数</a> 一章。</p>
<h3 id="访问列表的元素"><a class="header" href="#访问列表的元素">访问列表的元素</a></h3>
<p>XiaoXuan 的列表虽然跟函数式编程语言（Clojure, Haskell, Lisp 等）的列表概念相似，但对列表操作的函数名称有所不同，比如常见的 &quot;head，tail，init，last&quot; 函数分别表示获取 &quot;第一个&quot;、&quot;第一个之外&quot;、&quot;最后一个之外&quot;、&quot;最后一个&quot; 元素，XiaoXuan 使用更接近日常生活习惯的名称。</p>
<h4 id="获取第一个元素"><a class="header" href="#获取第一个元素">获取第一个元素</a></h4>
<p>使用 <code>第一个</code>（<code>first</code>）函数可获取列表的第一个元素。</p>
<p>示例：</p>
<pre><code class="language-js">让 a = [1, 2, 3, 4, 5]
让 i = 第一个 (a)
# 让 i = a.第一个()
</code></pre>
<pre><code class="language-js">let a = [1, 2, 3, 4, 5]
let i = first (a)
# let i = a.first()
</code></pre>
<p>上例中变量 <code>i</code> 的值将会是整数 <code>1</code>。</p>
<p>对一个空列表执行 <code>第一个</code> 函数会引发运行时异常。</p>
<p>有时想试探性地获取第一个元素（即免去检测列表是否为空这个步骤），可以使用 <code>尝试第一个</code>（<code>tryFirst</code>）函数，其返回值是 <code>可选&lt;T&gt;</code>（<code>Option&lt;T&gt;</code>），列表为空时它返回 <code>可选::无</code>，而不是直接抛出运行时错误。当列表不为空时，则返回 <code>可选::有(value)</code></p>
<p>示例：</p>
<pre><code class="language-js">let v1 = [1, 2, 3, 4, 5].tryFirst()  # Option::Some(1)
let v2 = [].tryFirst()               # Option::None
</code></pre>
<h4 id="获取第一个元素之外的元素"><a class="header" href="#获取第一个元素之外的元素">获取第一个元素之外的元素</a></h4>
<p>使用 <code>其余</code>（<code>rest</code>）函数可获取列表中除了第一个元素之外的其余元素，函数返回由其余元素组成的一个新列表。</p>
<p>示例：</p>
<pre><code class="language-js">让 a = [1, 2, 3, 4, 5]
让 i = a.其余()
# 让 i = 其余 (a)
</code></pre>
<pre><code class="language-js">let a = [1, 2, 3, 4, 5]
let i = a.rest()
# let i = rest (a)
</code></pre>
<p>上例中变量 <code>i</code> 的值将会是 <code>[2, 3, 4, 5]</code>。</p>
<p>对一个空列表执行 <code>其余</code> 函数总会返回空列表。</p>
<blockquote>
<p>通过循环地依次使用 <code>添加</code>-&gt;<code>第一个</code>-&gt;<code>其余</code> 三个函数，可以实现经典的 <code>FILO</code> 栈功能。</p>
</blockquote>
<h4 id="获取最后一个元素"><a class="header" href="#获取最后一个元素">获取最后一个元素</a></h4>
<p>使用 <code>最后一个</code>（<code>last</code>）函数可获取列表的最后一个元素。</p>
<pre><code class="language-js">让 a = [1, 2, 3, 4, 5]
让 i = a.最后一个()
# 让 i = 最后一个 (a)
</code></pre>
<pre><code class="language-js">let a = [1, 2, 3, 4, 5]
let i = a.last()
# let i = last (a)
</code></pre>
<p>上例中变量 <code>i</code> 的值将会是整数 <code>5</code>。</p>
<p>对一个空列表执行 <code>最后一个</code> 函数会引发运行时异常。</p>
<p>有时想试探性地获取最后一个元素，可以使用 <code>尝试最后一个</code>（<code>tryLast</code>）函数，其返回值是 <code>可选&lt;T&gt;</code>（<code>Option&lt;T&gt;</code>），列表为空时它返回 <code>可选::无</code>，而不是直接抛出运行时错误。当列表不为空时，则返回 <code>可选::有(value)</code></p>
<p>示例：</p>
<pre><code class="language-js">let v1 = [1, 2, 3, 4, 5].tryLast()  # Option::Some(5)
let v2 = [].tryLast()               # Option::None
</code></pre>
<h4 id="获取最后一个之外的元素"><a class="header" href="#获取最后一个之外的元素">获取最后一个之外的元素</a></h4>
<p>使用 <code>最后一个除外</code>（<code>exceptLast</code>）函数可以获取列表中除了最后一个元素之外的其他元素，函数返回一个除了最后一个元素的新列表。</p>
<p>示例：</p>
<pre><code class="language-js">let a = [1, 2, 3, 4, 5]
let b1 = a.exceptLast()
let b2 = b1.exceptLast()
</code></pre>
<p>最后变量 <code>b1</code> 的值为 <code>[1, 2, 3, 4]</code>（列表），变量 <code>b2</code> 的值为 <code>[1, 2, 3]</code>。</p>
<p>对一个空列表执行 <code>最后一个除外</code> 函数总会返回空列表。</p>
<blockquote>
<p>通过循环地依次使用 <code>添加</code>-&gt;<code>最后一个</code>-&gt;<code>最后一个除外</code> 三个函数，可以实现经典的 <code>FIFO</code> 列表功能。</p>
</blockquote>
<h4 id="根据位置获取元素"><a class="header" href="#根据位置获取元素">根据位置获取元素</a></h4>
<p>使用 <code>获取</code>（<code>get</code>）函数可根据指定的位置获取元素。<code>获取</code> 函数的原型是：</p>
<ul>
<li><code>获取 (位置, 列表实例)</code></li>
<li><code>get (position, listInstance)</code></li>
</ul>
<p>函数的第一个参数表示指定元素的位置值。</p>
<p>需注意：</p>
<ul>
<li>位置值从数字 1 开始，而不是从 0 开始； <!-- TODO:: 为了便于跟现有的环境配合，比如 XiaoXuan Script 和 XiaoXuan Native 需要跟浏览器、跟操作系统现有的库和程序交流，可能还是从 0 开始比较好 TODO:: 所以索引值的起始值需要再考虑一下 --></li>
<li>位置值的最大值为列表的长度，也就是说，位置值的有效范围是从 &quot;0&quot; 到 &quot;列表的长度&quot;；</li>
<li>位置值不能超出列表的范围，即小于 1 或者大于列表长度，否则会引起运行时错误。</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">让 a = [1, 2, 3, 4, 5]
让 i = a.获取(2)
# 让 i = 获取 (2, a)
</code></pre>
<pre><code class="language-js">let a = [1, 2, 3, 4, 5]
let i = a.get(2)
# let i = get (2, a)
</code></pre>
<p>上例中变量 <code>i</code> 的值将会是整数 <code>2</code>。</p>
<blockquote>
<p>因为列表一般通过使用单向链表来实现，所以按位置来访问元素的效率比较低，函数需要逐个元素遍历直到指定的位置为止，我们应该尽量避免高频次使用位置值来访问列表元素。如果需要高频次按位置访问元素，可以使用下面将会讲述的 <code>数组</code> 数据类型。</p>
</blockquote>
<p>有时想试探性地获取一个位置的值（即免去实现检查有效范围的步骤），则可以使用 <code>尝试获取</code>（<code>tryGet</code>）函数。函数返回 <code>可选&lt;T&gt;</code>（<code>Option&lt;T&gt;</code>），如果指定的位置在有效范围之内，则返回 <code>可选::有(value)</code>，否则返回 <code>可选::无</code>。</p>
<p>示例：</p>
<pre><code class="language-js">let a = [1, 2, 3, 4, 5]
let i = tryGet(2, a)
let j = tryGet(10, a)
</code></pre>
<p>上例中变量 <code>i</code> 的值为 <code>可选::有(2)</code>，变量 <code>j</code> 的值为 <code>可选::无</code>。</p>
<h5 id="使用中括号获取指定位置的元素"><a class="header" href="#使用中括号获取指定位置的元素">使用中括号获取指定位置的元素</a></h5>
<p>除了使用 <code>获取</code> 函数，还可以在列表后面使用中括号表达式 <code>[N]</code> 方便地按位置访问列表元素。</p>
<p>示例：</p>
<ul>
<li><code>让 i = a[2]</code></li>
<li><code>let i = a[2]</code></li>
</ul>
<p>中括号里面写上需要获取的元素的位置值，表达式会被解析为调用函数 <code>获取</code>。</p>
<blockquote>
<p>使用中括号访问列表元素在外观上很像 C、Java 等语言的数组按索引值访问元素，不过索引值表示的是相对第一个元素的偏移量，所以是从 0 开始的。而 XiaoXuan 使用我们日常生活中的次序概念，也就是位置值而不是索引值或者偏移量，所以从数字 1 开始。</p>
</blockquote>
<h3 id="选取指定范围的元素"><a class="header" href="#选取指定范围的元素">选取指定范围的元素</a></h3>
<p>使用 <code>选取</code>（<code>slice</code>） 函数可以选取指定范围的元素，并返回一个新列表。函数的原型是：</p>
<ul>
<li><code>选取 (开始位置, 元素个数, 列表实例)</code></li>
<li><code>slice (startPosition, count, listInstance)</code></li>
</ul>
<p><code>选取</code> 函数各参数的含义：</p>
<ul>
<li>第 1 个参数表示选取范围的开始位置，取值范围从 1 到 &quot;列表的长度&quot;，选取的结果包括此位置的元素；</li>
<li>第 2 个参数表示选取元素的个数，取值范围从 0 到 &quot;列表长度 - 开始位置 + 1&quot;。比如假设一个列表有 10 个元素，开始位置值为 <code>2</code>，则有效的选取元素个数为 <code>0</code> 到 <code>9</code>（9 = 10 - 2 + 1）。</li>
<li>第 3 个参数为源列表。</li>
</ul>
<p>需注意：</p>
<ul>
<li>如果 &quot;元素个数&quot; 参数传入 <code>0</code>，则会返回一个空列表 <code>[]</code>；</li>
<li>&quot;开始位置&quot; 以及 &quot;元素个数&quot; 都不能超出列表的范围，否则都会引起运行时异常。</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">让 a = [1, 2, 3, 4, 5]
让 b2 = a.选取 (2, 3)
# 让 b1 = 选取 (2, 3, a)
</code></pre>
<pre><code class="language-js">let a = [1, 2, 3, 4, 5]
let b2 = a.slice (2, 3)
# let b1 = slice (2, 3, a)
</code></pre>
<p>上面示例表示从列表 <code>a</code> 的第 2 个元素开始（包括第 2 个元素），选取 3 个元素，因此变量 <code>b</code> 的值将会是 <code>[2, 3, 4]</code>。</p>
<p><code>选取</code> 函数有一个省略 &quot;元素个数&quot; 参数的重载，表示选取从 &quot;开始位置&quot; 到列表的最后一个元素，示例：</p>
<ul>
<li><code>让 c = 选取 (4, a)</code></li>
<li><code>let c = slice (4, a)</code></li>
</ul>
<p>变量 <code>c</code> 的值将会是 <code>[4, 5]</code>。</p>
<p>对于获取列表后面任意 N 个元素的代码如下：</p>
<pre><code class="language-js">let N = 3
let c = a.slice(a.length() - N + 1)
# let c = slice(a.length() - N + 1, a)
</code></pre>
<h4 id="使用中括号选取指定范围的元素"><a class="header" href="#使用中括号选取指定范围的元素">使用中括号选取指定范围的元素</a></h4>
<p>除了使用 <code>选取</code> 函数，还可以在列表后面使用中括号表达式 <code>[Position:Count]</code> 选取列表指定范围的元素。</p>
<p>示例：</p>
<pre><code class="language-js">让 a = [1, 2, 3, 4, 5]
让 b = a[2:3]
</code></pre>
<pre><code class="language-js">let a = [1, 2, 3, 4, 5]
let b = a[2:3]
</code></pre>
<p>中括号里分别位选取的开始位置以及选取的元素个数，表达式会被解析为调用函数 <code>选取</code>。</p>
<p>上面示例的语句表示从列表 <code>a</code> 的第 2 个元素开始（包括第 2 个元素），选取 3 个元素，变量 <code>b</code> 的值将会是 <code>[2, 3, 4]</code>。</p>
<h5 id="省略-元素个数"><a class="header" href="#省略-元素个数">省略 &quot;元素个数&quot;</a></h5>
<p>如果省略 &quot;元素个数&quot;，表示选取从 &quot;开始位置&quot; 到列表的最后一个元素，示例：</p>
<ul>
<li><code>让 c = a[4:]</code></li>
<li><code>let c = a[4:]</code></li>
</ul>
<p>上例中变量 <code>c</code> 的值将会是 <code>[4, 5]</code>。</p>
<h5 id="省略-开始位置"><a class="header" href="#省略-开始位置">省略 &quot;开始位置&quot;</a></h5>
<p>如果省略 &quot;开始位置&quot;，则表示选取列表最后指定个数的元素。</p>
<p>示例：</p>
<ul>
<li><code>让 b = a[:3]</code></li>
<li><code>let b = a[:3]</code></li>
</ul>
<p>上面示例表示选取列表 <code>a</code> 的最后 3 个元素，所以变量 <code>b</code> 的值将会是 <code>[3, 4, 5]</code>。</p>
<p>表达式 <code>a[:N]</code> 会被解析为函数调用 <code>slice(a.length() - N + 1, a)</code>。</p>
<h3 id="获取开始部分的元素"><a class="header" href="#获取开始部分的元素">获取开始部分的元素</a></h3>
<p>::TODO::
<code>拿走</code> <code>take</code></p>
<p><code>序列&lt;T&gt; &lt;- 拿走 (整数 数量, 序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;T&gt; &lt;- take (Int count, Sequence&lt;T&gt; target)</code></p>
<h3 id="跳过部分元素"><a class="header" href="#跳过部分元素">跳过部分元素</a></h3>
<p>::TODO::
<code>跳过</code> <code>skip</code></p>
<p>返回剩余的元素</p>
<h3 id="修改列表"><a class="header" href="#修改列表">修改列表</a></h3>
<p>XiaoXuan 所有类型的数据都不支持更改，自然也无法对一个列表增加、修改或者删除元素。或者说，所有对列表的更改都会产生一个新的列表。比如向一个列表增加一个元素将会返回一个 &quot;包含有新增的那个元素&quot; 的新列表，而原先那个列表仍保持不变。</p>
<p>运行环境内部一般采用单向链表来实现列表，在单向链表的头部（最新元素的那端，有时也称为开始端）添加元素能在常数时间内完成，所以如果要增加列表元素，一般都是往列表的头部添加。另一方面，往列表末尾追加元素的效率则非常低（因为要重新构建一次列表）。</p>
<p>为了简化应用，XiaoXuan 运行环境一般使用两个单向链表，让它们尾尾相连的组成一个列表，其中一个链表的头作为列表的尾，因此无论是在列表的头部还是尾部添加或删除元素，都能在常数时间内完成。</p>
<p>下面表示一个有 3 个元素的列表，其中元素 <code>a</code> 这一端是列表的 &quot;头部&quot;，元素 <code>a</code> 称为 <code>第一个</code> 元素；元素 &quot;c&quot; 那端是列表的 &quot;尾部&quot;，元素 <code>c</code> 称为 <code>最后一个</code> 元素。</p>
<div class="table-wrapper"><table><thead><tr><th>a</th><th>b</th><th>c</th></tr></thead><tbody>
<tr><td>1</td><td>2</td><td>3</td></tr>
</tbody></table>
</div>
<p>上表第二排表示元素的位置（次序），第一个元素的位置值是 1，第二个元素的位置值是 2，如此类推。</p>
<p>使用 <code>添加</code> 函数往这个列表增加元素 &quot;n&quot;，得到一个如下的新列表：</p>
<div class="table-wrapper"><table><thead><tr><th>n</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody>
<tr><td>1</td><td>2</td><td>3</td><td>4</td></tr>
</tbody></table>
</div>
<p>现在列表的头部，也就是第一个元素变成了 <code>n</code>，应该注意到原有元素（即 <code>a</code>、<code>b</code>、<code>c</code>）的位置值都被改变了，这是因为新增加的元素是以 &quot;插队&quot; 的形式被添加到列表的头部，原有的元素的位置都被往后挪了一个。</p>
<h3 id="增加元素"><a class="header" href="#增加元素">增加元素</a></h3>
<p>使用一对中括号和 <code>展开符号</code> &quot;...&quot;（即三个点号）的表达式可以实现往列表头部添加一个元素。</p>
<p>示例：</p>
<p>假设有列表 <code>a</code>：</p>
<ul>
<li><code>让 a = [1, 2, 3]</code></li>
<li><code>let a = [1, 2, 3]</code></li>
</ul>
<p>现在要添加整数 <code>88</code> 到列表头部，则语句如下：</p>
<ul>
<li><code>让 b = [88, ...a]</code></li>
<li><code>let b = [88, ...a]</code></li>
</ul>
<p>上例将会得到一个新的列表并赋值给变量 <code>b</code>，其值为 <code>[88, 1, 2, 3]</code>。</p>
<p>也可以一次添加多个元素，比如：</p>
<ul>
<li><code>让 c = [77, 88, 99, ...a]</code></li>
<li><code>let c = [77, 88, 99, ...a]</code></li>
</ul>
<p>这样又会产生一个新的列表，并赋值给变量 <code>c</code>，其值为 <code>[77, 88, 99, 1, 2, 3]</code>。</p>
<p>需注意:</p>
<ul>
<li>新添加的元素总是以 &quot;插队&quot; 的形式出现在列表的头部。</li>
<li>关键字 <code>...</code> 只能出现在中括号的末尾，比如语句 <code>[...a, 4, 5]</code> 语法是错误的。</li>
</ul>
<p>表达式 <code>[x, ...a]</code> 会被解析为调用函数 <code>添加</code>（<code>add</code>）。</p>
<p>函数 <code>添加</code> 的原型是：</p>
<ul>
<li><code>Sequence&lt;T&gt; &lt;- add (T, Sequence&lt;T&gt;)</code></li>
<li><code>Sequence&lt;T&gt; &lt;- add (Sequence&lt;T&gt; additional, Sequence&lt;T&gt; target)</code></li>
</ul>
<p>示例：</p>
<pre><code class="language-js">让 b = [8, ...a]  # 这条语句会被解析为如下两句的其中一个
让 b = a.添加(8)
# 让 b = 添加 (8, a)

让 c = [77,88,99, ...a]  # 这条语句会被解析为如下两句的其中一个
让 c = a.添加([77,88,99])
# 让 c = 添加 ([77,88,99], a)
</code></pre>
<pre><code class="language-js">let b = [8, ...a]  # This statement will be parsed as one of the following two statements
let b = a.add(8)
# let b = add (8, a)

let c = [77,88,99, ...a]  # This statement will be parsed as one of the following two statements
let c = a.add([77,88,99])
# let c = add ([77,88,99], a)
</code></pre>
<p>需注意表达式 <code>[x, y, z, ...a]</code> 也可能会被解析为多次调用 <code>添加(T, seq&lt;T&gt;)</code> 函数，具体由运行时决定，但无论如何结果都是一样的。</p>
<h3 id="追加元素或列表"><a class="header" href="#追加元素或列表">追加元素或列表</a></h3>
<p>使用 <code>追加</code>（<code>append</code>） 函数可以在一个列表的末尾追加元素或者另一个列表。</p>
<p><code>追加</code> 函数的原型是：</p>
<ul>
<li><code>Sequence&lt;T&gt; &lt;- append (T, Sequence&lt;T&gt;)</code></li>
<li><code>Sequence&lt;T&gt; &lt;- append (Sequence&lt;T&gt; additional, Sequence&lt;T&gt; target)</code></li>
</ul>
<p>示例：</p>
<pre><code class="language-js">让 a = [1,2,3,4,5]
让 aa = a.追加(99)
让 ab = a.追加([77,88,99])
</code></pre>
<pre><code class="language-js">let a = [1,2,3,4,5]
let aa = a.append(99)
let ab = a.append([77,88,99])
</code></pre>
<p>最后变量 aa 的值为 <code>[1,2,3,4,5,99]</code>，ab 的值为 <code>[1,2,3,4,5,77,88,99]</code>。</p>
<blockquote>
<p>跟 <code>添加</code> 函数不同，往列表 <code>追加</code> 元素不会改变原有元素的位置值。</p>
</blockquote>
<h3 id="删除元素"><a class="header" href="#删除元素">删除元素</a></h3>
<p>对列表调用 <code>删除</code>（<code>remove</code>）函数将会返回一个新的 &quot;且删除了指定元素的&quot; 列表。</p>
<p><code>删除</code> 函数的原型是：</p>
<ul>
<li><code>Sequence&lt;T&gt; &lt;- remove (position, Sequence&lt;T&gt;)</code></li>
<li><code>Sequence&lt;T&gt; &lt;- remove (startPos, count, Sequence&lt;T&gt;)</code></li>
<li><code>Sequence&lt;T&gt; &lt;- remove (Boolean &lt;- (T), Sequence&lt;T&gt;)</code></li>
</ul>
<p>示例：</p>
<pre><code class="language-js">让 a = [1,2,3,4,5]
让 e = a.删除(2)
</code></pre>
<p>上例中 <code>删除</code> 函数的参数表示待删除的元素的位置值。结果变量 <code>e</code> 的值为 <code>[1,3,4,5]</code>。</p>
<p>注意位置值必须在合法的范围，否则会抛出运行时异常。</p>
<p><code>删除</code> 函数的第二个重载用于删除指定范围的元素，两个参数的含义跟<code>选取</code> 函数的一样，分别表示 &quot;开始位置&quot; 和待 &quot;删除元素的个数&quot;。</p>
<p>示例：</p>
<pre><code class="language-js">让 a = [1,2,3,4,5]
让 e = 删除(2, 3, a)
# 让 e = a.删除(2, 3)
</code></pre>
<pre><code class="language-js">let a = [1,2,3,4,5]
let e = remove(2, 3, a)
# let e = a.remove(2, 3)
</code></pre>
<p>上面示例表示从列表 <code>a</code> 的第 2 个元素开始，共删除 3 个元素，结果变量 <code>e</code> 的值将会是 <code>[1, 5]</code>。</p>
<p>运行环境使用获取部分元素的方法实现 <code>删除</code> 函数的功能，下面演示的是等效代码：</p>
<pre><code class="language-py"># 目的：删除列表的第 1 个元素
# 方法：获取除了第 1 个元素之外的剩余元素
让 b = a.其余()
让 [_, ...b] = a

# 目的：删除列表的前 N 个元素（0 &lt;= N &lt;= 列表长度 - 1）
# 方法：获取从位置 N+1 开始往后的所有元素
让 c = a.选取(N+1)
让 c = a[N+1 :]

# 目的：删除列表的后 N 个元素（0 &lt;= N &lt;= 列表长度）
# 方法：获取从位置 1 开始，获取 &quot;总个数 - N&quot; 个元素
让 d = a.选取(1,  a.长度() - N)
让 d = a[1 : a.长度() - N]
</code></pre>
<pre><code class="language-py"># expected: delete the first element of the list
# solution: get the remaining elements except for the 1st element
let b = a.rest()
let [_, ...b] = a

# expected: delete the first N elements of the list (0 &lt;= N &lt;= list length - 1)
# solution: get all elements from position N+1
let c = a.slice(N+1)
let c = a[N+1 :]

# expected: delete the last N elements of the list (0 &lt;= N &lt;= list length)
# solution: get the elements start from position 1, count &quot;Total - N&quot;.
let d = a.slice(1, a.length() - N)
let d = a[1 : a.length() - N]
</code></pre>
<p>此外还可以向 <code>删除</code>（<code>remove</code>） 函数传入一个签名为 <code>Boolean &lt;- (T)</code> 的函数，用于实现根据条件删除一个或多个元素，返回剩余的元素。</p>
<p>示例：</p>
<pre><code class="language-js">让 a = [1,2,3,4,5]
let e1 = a.remove(x =&gt; x &gt; 3)  # `[1,2,3]`
let e2 = a.remove(x =&gt; x % 2 == 0)  # `[1,3,5]`
</code></pre>
<h3 id="过滤元素"><a class="header" href="#过滤元素">过滤元素</a></h3>
<p>使用 <code>过滤</code>（<code>filter</code>） 函数可以根据条件过滤掉一个或多个元素，只保留满足条件的元素（跟 <code>删除</code> 函数刚好相反）。</p>
<p><code>过滤</code> 函数的原型是：</p>
<ul>
<li><code>过滤 (逻辑 &lt;- (T), seq)</code></li>
<li><code>filter (Boolean &lt;- (T), seq)</code></li>
</ul>
<p>示例：</p>
<pre><code class="language-js">let a = [1,2,3,4,5]
let e1 = a.filter(x =&gt; x &gt; 3)       # `[4, 5]`
let e2 = a.filter(x =&gt; x % 2 == 0)  # `[2, 4]`
</code></pre>
<h3 id="拆分列表"><a class="header" href="#拆分列表">拆分列表</a></h3>
<p>使用 <code>拆分</code>（<code>separate</code>）函数可以在指定位置将一个列表拆分为两个子列表。</p>
<p><code>拆分</code> 函数的原型是：</p>
<ul>
<li><code>拆分 (位置之前, 列表实例)</code></li>
<li><code>separate (positionBefore, listInstance)</code></li>
</ul>
<p>示例：</p>
<ul>
<li><code>让 (x, y) = a.拆分(3)</code></li>
<li><code>let (x, y) = a.separate(3)</code></li>
</ul>
<p><code>拆分</code> 函数返回一个元组，元组有两个成员，分别是拆分而得的前后两个列表。其中参数表示从该位置开始分开，该位置之前的元素形成一个列表，该位置以及该位置之后的元素形成后一个列表。</p>
<p>所以上面的示例将会得到：</p>
<pre><code class="language-js">(
    [1, 2],
    [3, 4, 5]
)
</code></pre>
<p>&quot;位置之前&quot; 参数的取值范围是从 <code>1</code> 开始到 &quot;列表长度&quot;。</p>
<ul>
<li>如果 &quot;位置之前&quot; 参数值为 1，因为位置 1 前面已经没有其他元素，所以返回一个空列表和一个跟源列表一样的列表，即 (<code>[]</code>, <code>[1,2,3,4,5]</code>)；</li>
<li>如果 &quot;位置之前&quot; 参数值为 &quot;列表长度&quot;，则返回一个除了最后一个元素之外的列表，跟一个只有最后一个元素的列表，即 (<code>[1,2,3,4]</code>, <code>[5]</code>)。</li>
</ul>
<p>如果 &quot;位置之前&quot; 值超出允许范围，则会引起运行时异常。</p>
<p><code>拆分</code> 函数也支持传入一个签名为 <code>Boolean &lt;- (T)</code> 的函数作为参数，当该函数的返回值为 <code>真</code> 时，该元素被划分到第一个列表，否则划分到第二个列表。</p>
<p>示例：</p>
<pre><code class="language-js">let s = [1,2,3,4,5]
let (a, b) = s.separate(i=&gt; i % 2 == 0)
# a == [2,4]
# b == [1,3,5]
</code></pre>
<h3 id="连接列表"><a class="header" href="#连接列表">连接列表</a></h3>
<p>使用 <code>连接</code>（<code>concat</code>）函数可以将两个列表连接起来，并返回连接后的新列表。</p>
<p>示例：</p>
<ul>
<li><code>让 a = 连接([1,2,3], [7,8,9])</code></li>
<li><code>let a = concat([1,2,3], [7,8,9])</code></li>
</ul>
<p>上例将会得到一个新的列表 <code>[1,2,3,7,8,9]</code>。</p>
<p><code>连接</code> 函数有一个纯符号的别名 <code>++</code> （即两个加号），使用 <code>++</code> 符号重写上例的代码如下：</p>
<ul>
<li><code>让 a = [1,2,3] ++ [7,8,9]</code></li>
<li><code>let a = [1,2,3] ++ [7,8,9]</code></li>
</ul>
<p>需注意：</p>
<ul>
<li>待连接的列表的数据类型必须相同；</li>
<li>连接操作是从右到左结合，如 <code>[1,2] ++ [5,6] ++ [8,9]</code> 先连接后两个列表得 <code>[5,6,8,9]</code> 然后再连接第一个列表；</li>
</ul>
<blockquote>
<p>因为 <code>字符串</code> 也实现了 <code>List</code> 特性，<!-- 实际上是 `列表<字符>`（`List<Char>`） 数据类型，--> 所以字符串的连接也是使用 <code>++</code> 函数，比如： <code>&quot;hello&quot; ++ &quot;world&quot;</code> 得到 <code>&quot;helloworld&quot;</code>。</p>
</blockquote>
<h3 id="裁剪"><a class="header" href="#裁剪">裁剪</a></h3>
<p><code>裁剪</code>（<code>trim</code>）
trim/trimStart/trimEnd</p>
<p><code>Sequence&lt;T&gt; &lt;- trim (T, Sequence&lt;T&gt;)</code>
<code>Sequence&lt;T&gt; &lt;- trim (Boolean &lt;- T, Sequence&lt;T&gt;)</code>
<code>Sequence&lt;T&gt; &lt;- trimStart (T, Sequence&lt;T&gt;)</code>
<code>Sequence&lt;T&gt; &lt;- trimStart (Boolean &lt;- T, Sequence&lt;T&gt;)</code>
<code>Sequence&lt;T&gt; &lt;- trimEnd (T, Sequence&lt;T&gt;)</code>
<code>Sequence&lt;T&gt; &lt;- trimEnd (Boolean &lt;- T, Sequence&lt;T&gt;)</code></p>
<h3 id="补齐"><a class="header" href="#补齐">补齐</a></h3>
<p>padStart/padEnd</p>
<p><code>Sequence&lt;T&gt; &lt;- padStart(T, Int length, Sequence&lt;T&gt;)</code>
<code>Sequence&lt;T&gt; &lt;- padEnd(T, Int length, Sequence&lt;T&gt;)</code></p>
<h3 id="重复序列"><a class="header" href="#重复序列">重复序列</a></h3>
<p>重复序列是指将一个序列复制多遍，然后形成值重复的序列。在被复制的序列使用<strong>表示复制</strong>的符号 <code>**</code> 可以重复一个列表。</p>
<p>示例：</p>
<pre><code class="language-js">let a = [1] ** 4
let b = [0.0] ** 4
let d = [true] ** 3
let e = [&quot;foo&quot;] ** 3
let f = [0, 1] ** 2
let g = [false, true] ** 2
</code></pre>
<p>结果生成如下等效数列：</p>
<ul>
<li><code>[1, 1, 1, 1]</code></li>
<li><code>[0.0, 0.0, 0.0, 0.0]</code></li>
<li><code>[true, true, true]</code></li>
<li><code>[&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]</code></li>
<li><code>[0, 1, 0, 1]</code></li>
<li><code>[false, true, false, true]</code></li>
</ul>
<p>符号 <code>**</code> 后面的数字表示复制的次数，为了跟乘法一致，规定复制 1 次表示得出原先的列表。</p>
<p>符号 <code>**</code> 对应的函数是 <code>重复</code>（<code>replicate</code> ::remove<code>duplicate</code>）函数：</p>
<ul>
<li><code>让 a = 重复(4, [1,2,3])</code></li>
<li><code>let a = replicate(4, [1,2,3])</code></li>
</ul>
<h4 id="重复字符串"><a class="header" href="#重复字符串">重复字符串</a></h4>
<!--
`字符串`（`String`） 类型实际上是 `数组<字符>`（`Array<Char>`）的别称，所以字符串也是可以重复的。

示例：

"abc" 的实际值是 `!['a', 'b', 'c']`，当使用 `**` 复制这个数组时，比如复制 2 次，结果值为 `!['a', 'b', 'c', 'a', 'b', 'c']`，恰好就是 "abcabc"。所以
-->
<p><code>**</code> 运算符号同样可以直接用于重复字符串。</p>
<p>示例：</p>
<p><code>let s1 = &quot;=&quot; ** 3</code>
<code>let s2 = &quot;abc&quot; ** 2</code></p>
<p>变量 <code>s1</code> 的值为 &quot;===&quot;， 变量 <code>s2</code> 的值为 &quot;abcabc&quot;。</p>
<h3 id="平分列表"><a class="header" href="#平分列表">平分列表</a></h3>
<p>使用 <code>平分</code>（<code>part</code> TODO:: 考虑使用 <code>divid</code>）函数可以将一个列表平分为多个子列表。函数的参数用于指定需要划分为多少个部分。</p>
<p>示例：</p>
<pre><code class="language-js">let a = [1,2,3,4,5,6]
let b1 = a.part(2)
let b2 = a.part(3)
// let b3 = a.divid(4)
</code></pre>
<p>结果变量 <code>b1</code> 的值为 <code>[[1,2,3],[4,5,6]]</code>，变量 <code>b2</code> 的值为 <code>[[1,2], [3,4], [5,6]]</code>。</p>
<p>注意：</p>
<ul>
<li>当平分的数量比元素总数量要大时，将会有连续几个空列表出现在结果的末尾，比如 <code>[1,2].part(4)</code> 将会得出 <code>[[1], [2], [], []]</code></li>
<li>当元素的总数量不是平分数量的整数倍时，结果当中靠后的子列表的数量会比靠前的子列表要少。比如将 14 分成 4 组，先计算 <code>int(14 / 4)</code> 得出每组有 3 个元素，最后一组会多出 2 个元素。这时函数会将这多出来的 2 个元素优先给靠前的小组加 1，也就是说前 2 个小组的元素数量会多 1 个。</li>
</ul>
<h3 id="分隔列表"><a class="header" href="#分隔列表">分隔列表</a></h3>
<p>使用 <code>分隔</code>（<code>split</code>）函数可以将一个列表根据指定的值分隔为若干份，指定的值将会作为 &quot;分隔符&quot;，所以不会出现在结果集里。</p>
<p>示例：</p>
<ul>
<li><code>让 s = [1,2,0,3,0,4,5,6].分隔(0)</code></li>
<li><code>let s = [1,2,0,3,0,4,5,6].split(0)</code></li>
</ul>
<p>则 <code>s</code> 的值为：</p>
<pre><code class="language-js">[
    [1, 2],
    [3],
    [4, 5, 6]
]
</code></pre>
<p>注意：</p>
<ul>
<li>如果找不到指定的值，则返回仅有一个元素的列表，该元素的值跟原列表一样，即 <code>[[...]]</code>；</li>
<li>如果指定的值出现在第一个元素，则返回的列表的第一个元素是空列表，即 <code>[[], ...]</code>；</li>
<li>如果指定的值出现在最后一个元素，则返回的列表的最后一个元素是空列表，即 <code>[..., []]</code>。</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">让 s1 = [1, 2, 3].分隔(0)
让 s2 = [1, 2, 3].分隔(1)
让 s3 = [1, 2, 3].分隔(2)
让 s4 = [1, 2, 3].分隔(3)
让 s5 = [0].分隔(0)
让 s6 = [0, 0].分隔(0)
</code></pre>
<p>则它们的值分别为：</p>
<ul>
<li><code>s1 == [[1,2,3]]</code></li>
<li><code>s2 == [[], [2, 3]]</code></li>
<li><code>s3 == [[1], [3]]</code></li>
<li><code>s4 == [[1, 2], []]</code></li>
<li><code>s5 == [[], []]</code></li>
<li><code>s6 == [[],[],[]]</code></li>
</ul>
<!-- 因为字符串实质是字符列表，所以 -->
<p>也可以使用 <code>分隔</code> 函数对字符串进行分隔，示例：</p>
<pre><code class="language-js">让 a = &quot;123,456,789&quot;
让 s = a.分隔(',')
</code></pre>
<p>得出结果为：</p>
<pre><code class="language-js">[&quot;123&quot;, &quot;456&quot;, &quot;789&quot;]
</code></pre>
<p><code>分隔</code> 函数也支持传入一个列表，表示根据这个子列表的值分隔源列表，示例：</p>
<pre><code class="language-js">让 a = &quot;123abc456abc789&quot;
让 s = a.分隔(&quot;abc&quot;)
</code></pre>
<p>得出结果为：</p>
<pre><code class="language-js">[&quot;123&quot;, &quot;456&quot;, &quot;789&quot;]
</code></pre>
<p><code>分隔</code> 函数还支持传入一个签名为 <code>Boolean &lt;- (T item)</code> 的函数，用于根据该函数的返回值（如果返回 true 则从该位置分隔）分隔列表。</p>
<p>示例：</p>
<pre><code class="language-js">let a = [1, 2, 3, 4, 5, 6, 7]
let b = a.split(x =&gt; x % 3 == 0)
</code></pre>
<p>上例中的 <code>x % 3 == 0</code> 表示如果 <code>x</code> 能被 3 整数，则返回 <code>真</code>。所以结果为：</p>
<pre><code class="language-js">[[1, 2], [4, 5], [7]]
</code></pre>
<h3 id="拼接-todo"><a class="header" href="#拼接-todo"><code>拼接</code> ::TODO</a></h3>
<p>如果列表是空的，则返回空列表。如果列表只有一个元素项目，那么将返回该元素而不使用分隔符。</p>
<h3 id="插入元素或列表"><a class="header" href="#插入元素或列表">插入元素或列表</a></h3>
<p>插入元素可以由 &quot;拆分列表&quot; 和 &quot;连接列表&quot; 两个操作完成，为了简化操作，可以使用 <code>插入</code>（<code>insert</code>） 函数来完成。</p>
<p><code>插入</code> 函数的原型是：</p>
<ul>
<li><code>插入 (位置之前, 新元素, 列表实例)</code></li>
<li><code>insert (positionBefore, newElement, listInstance)</code></li>
</ul>
<p>参数 &quot;位置之前&quot; 跟 <code>拆分</code> 函数一样，其有效取值范围是从 &quot;1&quot; 到 &quot;列表的长度&quot;，表示插入的位置（即把新元素以 &quot;插队&quot; 的形式放到该位置之前）。</p>
<p>示例，假设有列表 <code>[1,2,3,4,5]</code>，现分别有新元素 <code>99</code> 和新列表 <code>[77,88,99]</code> 准备插入到位置 N，假设 N = 3，代码如下：</p>
<pre><code class="language-js">函数 宽容拆分(p, list)
    如果 p == list.长度() + 1 那么
        (list, [])
    否则
        拆分(p, list)
    以上
以上

让 N = 3

让 (x, y) = 宽容拆分(N, a)
让 aa = x ++ [99, ...y]
让 ab = x ++ [77,88,99] ++ y

# 使用 `插入` 函数
让 aa = a.插入(N, 99)
让 ab = a.插入(N, [77,88,99])
</code></pre>
<pre><code class="language-js">function permissivePart(p, list)
    if p == list.length() + 1 then
        (list, [])
    else
        part(p, list)
    end
end

let N = 3
let (x, y) = a.permissivePart(N)
let aa = x ++ [99, ...y]
let ab = x ++ [77,88,99] ++ y

# by using `insert` function
let aa = a.insert(N, 99)
let ab = a.insert(N, [77,88,99])
</code></pre>
<p>最后变量 aa 的值为 <code>[1,2,99,3,4,5]</code>，ab 的值为 <code>[1,2,77,88,99,3,4,5]</code>。</p>
<h3 id="替换元素或列表"><a class="header" href="#替换元素或列表">替换元素或列表</a></h3>
<p>替换元素可以由两次 &quot;拆分列表&quot; 和两次 &quot;连接列表&quot; 共 4 个操作完成，为了简化操作，可以使用 <code>替换</code>（<code>replace</code>） 函数。</p>
<p><code>替换</code> 函数的原型是：</p>
<ul>
<li><code>替换 (开始位置, 元素个数, 新元素, 列表实例)</code></li>
<li><code>replace (startPosition, count, newElement, listInstance)</code></li>
</ul>
<p>示例，假设有列表 <code>[1,2,3,4,5]</code>，现分别有新元素 <code>99</code> 和新列表 <code>[77,88,99]</code> 准备替换从位置 M 开始的 N 个元素，假设 M = 2，N = 3，代码如下：</p>
<pre><code class="language-js">让 M = 2
让 N = 3

让 (x, y) = 宽容拆分(M, a)
让 (_, z) = 宽容拆分(M + N, y)
让 b1 = x ++ [99, ...z]
让 b2 = x ++ [77,88,99] ++ z

# 使用 `替换` 函数
让 b1 = a.替换(M, N, 99)
让 b2 = a.替换(M, N, [77,88,99])
</code></pre>
<pre><code class="language-js">let M = 2
let N = 3

let (x, y) = permissivePart(M, a)
let (_, z) = permissivePart(M+N, y)
let b1 = x ++ [99, ...z]
let b2 = x ++ [77,88,99] ++ z

# by using `replace` function
let b1 = a.replace(M, N, 99)
let b2 = a.replace(M, N, [77,88,99])
</code></pre>
<p>结果变量 <code>b1</code> 的值为 <code>[1,99,5]</code>，<code>b2</code> 的值为 <code>[1,77,88,99,5]</code>。</p>
<h3 id="排序列表-todo"><a class="header" href="#排序列表-todo">排序列表 ::TODO</a></h3>
<h3 id="反转列表-todo"><a class="header" href="#反转列表-todo">反转列表 ::TODO</a></h3>
<h3 id="查找元素或子列表的出现位置"><a class="header" href="#查找元素或子列表的出现位置">查找元素或（子）列表的出现位置</a></h3>
<p><code>查找位置</code>（<code>findPosition</code>）函数可以在指定的列表中查找指定的元素或者子列表，并返回找到的位置（位置值将会被 <code>可选</code> 类型的 <code>有</code> 封装）。如果没发现目标，则返回 <code>无</code>（<code>None</code>）。</p>
<p>示例：</p>
<pre><code class="language-js">让 i = a.查找位置(4)        # 得 `有(4)`
让 j = a.查找位置(99)       # 得 `无`
让 m = a.查找位置([3,4])    # 得 `有(3)`
让 n = a.查找位置([77,88])  # 得 `无`
</code></pre>
<pre><code class="language-js">let i = a.findPosition(4)        # get `Some(4)`
let j = a.findPosition(99)       # get `None`
let m = a.findPosition([3,4])    # get `Some(3)`
let n = a.findPosition([77,88])  # get `None`
</code></pre>
<p>查找位置也支持传入一个签名为 <code>Boolean &lt;- (T item)</code> 的函数，查找过程会从列表逐个元素取出然后传递给这个函数，当函数返回 <code>真</code>（<code>true</code>）时，查找过程中断，并且返回当时的位置。如果查到最后一个元素这个函数仍未返回 <code>真</code>，则查找过程返回 <code>无</code>（<code>None</code>）。</p>
<p>假设现有一个结构体 <code>用户</code>（<code>User</code>）及几个实例如下：</p>
<pre><code class="language-js">struct User
    String name
    String email
end

let u1 = User(&quot;foo&quot;, &quot;foo@domain.local&quot;)
let u2 = User(&quot;bar&quot;, &quot;bar@domain.local&quot;)

let uu = [u1, u2]
</code></pre>
<p>下面的代码用于查找用户名为 &quot;bar&quot; 的元素的位置值：</p>
<pre><code class="language-js">let i = uu.findPosition(item =&gt; item.name === &quot;bar&quot;)  # get `Some(2)`
let j = uu.findPosition(item =&gt; item.name === &quot;John&quot;) # get `None`
</code></pre>
<h3 id="reversefindposition"><a class="header" href="#reversefindposition">reverseFindPosition</a></h3>
<h3 id="查找元素"><a class="header" href="#查找元素">查找元素</a></h3>
<p><code>查找</code>（<code>find</code>）函数可以根据传入的 <code>Boolean &lt;- (T item)</code> 查找符合的元素，找到后返回被 <code>可选</code> 类型的 <code>有</code> 封装的元素，如果没发现目标，则返回 <code>无</code>（<code>None</code>）。</p>
<p>示例，继续上例当中的列表 <code>uu</code>，下面的代码用于查找用户名为 &quot;bar&quot; 的元素：</p>
<pre><code class="language-js">let m = uu.find(item =&gt; item.name === &quot;bar&quot;)    # get `Some(User(&quot;foo&quot;, ...))`
let n = uu.find(item =&gt; item.name === &quot;John&quot;)   # get `None`
</code></pre>
<h3 id="检查指定元素是否存在"><a class="header" href="#检查指定元素是否存在">检查指定元素是否存在</a></h3>
<p>使用 <code>存在</code>（<code>exist</code>）函数可以检查是否存在指定的元素，如果存在则返回 <code>真</code>（<code>true</code>），否则返回 <code>假</code>（<code>false</code>）。</p>
<p>示例：</p>
<pre><code class="language-js">let a = [1,2,3,4,5]
let e1 = a.exist(3)
let e2 = a.exist(6)
</code></pre>
<p>结果变量 <code>e1</code> 的值为 <code>真</code>，变量 <code>e2</code> 的值为 <code>假</code>。</p>
<p><code>存在</code> 函数也接受一个签名为 <code>Boolean &lt;- (T)</code> 或者 <code>Boolean &lt;- (Int, T)</code> 的函数，<code>存在</code> 函数会从列表里逐个元素，然后调用参数函数，当参数函数返回值为 <code>真</code> 时，函数立即返回 <code>真</code>。</p>
<pre><code class="language-js">let i = uu.exist(item =&gt; item.name === &quot;bar&quot;)  # true
let j = uu.exist(item =&gt; item.name === &quot;John&quot;) # false
</code></pre>
<h4 id="存在开始-todo"><a class="header" href="#存在开始-todo">存在开始 ::TODO</a></h4>
<p>existStart</p>
<h4 id="存在结束-todo"><a class="header" href="#存在结束-todo">存在结束 ::TODO</a></h4>
<p>existEnd</p>
<h3 id="全部匹配-todo"><a class="header" href="#全部匹配-todo"><code>全部匹配</code> ::TODO</a></h3>
<p>allMatch</p>
<h3 id="逐个-函数"><a class="header" href="#逐个-函数"><code>逐个</code> 函数</a></h3>
<p><code>逐个</code>（<code>each</code>）函数用于遍历一个序列的每一个元素。</p>
<p><code>逐个</code> 函数的原型是：</p>
<ul>
<li><code>逐个 (void &lt;- (T), seq)</code></li>
<li><code>each (void &lt;- (T), seq)</code></li>
</ul>
<p>示例：</p>
<ul>
<li><code>逐个(i =&gt; 书写行 (i),  [1..10])</code></li>
<li><code>each(i =&gt; writeLine (i), [1..10])</code></li>
</ul>
<p>上面的示例将会输出数列 <code>[1..10]</code> 的每一个元素，也就是数字 <code>1</code> 到 <code>10</code>。</p>
<p><code>逐个</code> 函数跟 <code>设有 取自</code> 语句的作用一样，不同的是 <code>逐个</code> 是一个函数，而 <code>设有 取自</code> 是语句，它们都没有返回值。</p>
<h3 id="枚举"><a class="header" href="#枚举">枚举</a></h3>
<p>enum() 用于返回一个带有序号/索引的 Seq，比如原有数列 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]，enum(list, indexBase) 返回 [(0, &quot;a&quot;), (1, &quot;b&quot;), (2, &quot;c&quot;)]</p>
<h3 id="映射-todo"><a class="header" href="#映射-todo"><code>映射</code> ::TODO</a></h3>
<p>跟 <code>设有 取自</code> 语句一样，<code>逐个</code> 函数也是没有返回值，如果向遍历一个列表且有返回值，可以参考 <code>映射</code>（<code>map</code>） 和 <code>折叠</code>（<code>fold</code>） 函数。</p>
<h3 id="折叠-todo"><a class="header" href="#折叠-todo">折叠 ::TODO</a></h3>
<h3 id="右折叠-todo"><a class="header" href="#右折叠-todo">右折叠 ::TODO</a></h3>
<h3 id="构建随机数列表"><a class="header" href="#构建随机数列表">构建随机数列表</a></h3>
<p>使用列表的函数 <code>newRandom</code> 还能创建一个随机数的列表。</p>
<p>示例：</p>
<pre><code class="language-js">let r = List::newRandom&lt;Int&gt;(25, 1, 100)
</code></pre>
<p>上例将会产生一个含有 25 个随机整数的数列，其中随机数的范围从整数 <code>1</code>（包括、即闭区间） 到整数 <code>100</code> （包括、即闭区间）。</p>
<p>下例演示计算 25 个随机数的标准差，已知标准差的公式是：</p>
<p>$$
\text{variance} = \frac{\sum_{i=1}^n(x_i - x_{avg})^2}{n}
$$</p>
<p>$$
\text{standard deviation} = \sqrt{\text{variance}}
$$</p>
<p>对应的代码是：</p>
<pre><code class="language-js">let v = new List::newRandom&lt;Int&gt;(25, 1, 100)
let variance = sum((v - average(v)) ^ 2) / 25 # Both subtraction and power have broadcast behavior
let sd = sqrt(variance)
</code></pre>
<blockquote>
<p>跟随机函数情况类似，如果要产生随机实数，范围值当中的开始值是闭区间，结束值是开放区间，比如 <code>List::newRandom&lt;Real&gt;(25, 0.0, 1.0)</code>，结果当中的元素有可能存在值为 <code>0.0</code> 的元素，但永远不会有值为 <code>1.0</code> 的元素。</p>
</blockquote>
<p><code>newRandom</code> 函数还可以指定随机数的分布规律，比如是否要正态分布等，详细见标准库文档。</p>
<h2 id="数列"><a class="header" href="#数列">数列</a></h2>
<p><code>数列</code>（<code>Range</code>）指在指定范围内的一系列等差数字。在中括号内使用<strong>表示范围</strong>的符号 <code>..</code> （即两个点号）可以构建一个等差数列，比如：</p>
<p><code>[1..10]</code></p>
<p>将会生成一个含有从 &quot;开始值&quot; （整数 1） 到 &quot;结束值&quot; （整数 10） 的列表，即 <code>[1,2,3,4,5,6,7,8,9,10]</code>。</p>
<p>开始值和结束值和符号 <code>..</code> 之间的空格有无均可。</p>
<p>如果开始值和结束值一样，则会构建一个只有一个元素的数列。比如 <code>[10..10]</code>。</p>
<h3 id="步进值"><a class="header" href="#步进值">步进值</a></h3>
<ul>
<li><code>让 n = 新建 数列(1,10)</code></li>
<li><code>let n = new Range(1,10)</code></li>
</ul>
<p>相邻元素间的差值（即步进值）默认是整数 <code>1</code>,如果想设置其他步进值，则除了 &quot;开始值&quot; 和 &quot;结束值&quot;，还需要额外提供第 2 个元素，则步进值将会是 &quot;第 2 个元素 - 第 1 个元素（即开始值）&quot;。</p>
<p>比如：</p>
<ul>
<li><code>[1, 3, ..9]</code></li>
<li><code>[10, 20, ..50]</code></li>
</ul>
<p>分别生成列表 <code>[1,3,5,7,9]</code> 和 <code>[10,20,30,40,50]</code>，步进值分别是 <code>3-1=2</code> 和 <code>20-10=10</code>。</p>
<p>注意</p>
<ul>
<li>第 2 个元素与第 1 个元素不能相同，否则会抛出运行时异常；</li>
<li>当存在第 2 个元素时，第 1 个和 第 2 个元素之间需要加上逗号，第 2 个元素后面的逗号可加可不加；</li>
<li>当存在第 2 个元素时，结束值必须符合步进的结果，比如 <code>[1,3,..10]</code> 表达式当中的结束值 <code>10</code> 不符合步进的结果，运行环境会抛出运行时异常。（::考虑宽容）</li>
</ul>
<p>也可以使用数列的构造函数来构建等差数列：</p>
<ul>
<li><code>让 n = 新建 数列(1, 9, 2)</code>  # <code>== [1, 3, ..9]</code></li>
<li><code>let n = new Range(1, 9, 2)</code>  # <code>== [1, 3, ..9]</code></li>
</ul>
<p>注意构造函数的第三个参数是步进值，也就是相当于字面量表达式的第 2 元素与第 1 个元素之差。如果省略步进值，则默认值为 1。</p>
<p>示例：</p>
<ul>
<li><code>让 n = 新建 数列(1, 5)</code>  # <code>== [1,2,3,4,5]</code></li>
<li><code>let n = new Range(1, 5)</code>  # <code>== [1,2,3,4,5]</code></li>
</ul>
<h3 id="线性值"><a class="header" href="#线性值">线性值</a></h3>
<p>::TODO</p>
<pre><code class="language-js">let n = Range::lineSpace(-1,1,0.1)
</code></pre>
<h3 id="动态指定开始值结束值和步进值"><a class="header" href="#动态指定开始值结束值和步进值">动态指定开始值、结束值和步进值</a></h3>
<p>开始值、结束值和步进值除了接受字面值，也可以是变量，比如</p>
<pre><code class="language-js">let start = 10
let end = 14
let step = 2
let a = [start .. end]
let b = [start, step, .. end]
</code></pre>
<p>则 <code>a</code> 的结果是 <code>[10,11,12,13,14]</code>，<code>b</code> 的结果是 <code>[10,12,14]</code>。</p>
<h3 id="浮点数数列"><a class="header" href="#浮点数数列">浮点数数列</a></h3>
<p>如果想生成浮点数数列，则必须提供第 2 个元素以确定步进值，比如：</p>
<p><code>[0.1, 0.2 .. 0.5]</code></p>
<p>将会生成 <code>[0.1, 0.2, 0.3, 0.4, 0.5]</code></p>
<p>或者使用构造函数构建：</p>
<ul>
<li><code>让 n = 新建 数列(0.1, 0.5, 0.1)</code></li>
<li><code>let n = new Range(0.1, 0.5, 0.1)</code></li>
</ul>
<h3 id="字符数列-未支持"><a class="header" href="#字符数列-未支持">字符数列 (::未支持)</a></h3>
<p>字符数据类型存储的是 Unicode 字符，在运行时实际上是 <code>UInt32</code>，所以开始值、结束值也可以是 <code>字符</code>。</p>
<p>示例：</p>
<p><code>['a' .. 'f']</code></p>
<p>将会生成字符数列 <code>['a','b','c','d','e', 'f']</code>。需要注意的是 Unicode 的码点（code point）并不是连续的，所以在生成字符数列时会自动跳过那些无效的 Unicode 字符。另外，字符列表<strong>不支持</strong>指定步进值。</p>
<h3 id="延迟执行"><a class="header" href="#延迟执行">延迟执行</a></h3>
<p>当 XiaoXuan 运行环境执行诸如 <code>[1 .. 2^63-1]</code> 语句时，不用担心机器的内存会被消耗光，因为运行环境并不会立即产生这个数列的每个元素，而是在真正需要时才产生并返回相应的数据。技术地说，这个数列跟普通数列有一样的访问接口，但实际上它只是一个函数。</p>
<h3 id="省略结束值"><a class="header" href="#省略结束值">省略结束值</a></h3>
<p>当省略结束值时，数列的结束值会被设定为起始值数据类型的最接近最大值的最后一个合法数字。不同类型数据的最大值是不相同的，比如对于默认的 <code>整数</code> 类型，其默认值为 2^63-1。</p>
<p>示例：</p>
<pre><code class="language-js">让 a = [1, ..]
让 b = [1, 3, ..]
</code></pre>
<pre><code class="language-js">let a = [1, ..]
let b = [1, 3, ..]
</code></pre>
<p>分别产生数列 <code>1, 2, 3, ...</code> 和 <code>1, 3, 5, 7, ...</code> 一直到 <code>Int64</code> 最后一个符合等差值的数字。</p>
<p>注意：</p>
<ul>
<li>对于 <code>浮点数</code> 和 <code>字符</code> 类型，不允许省略结束值。</li>
<li>省略结束值并不是构建了一个无限数列，虽然数列的元素数量很大，不过仍然是有限的。</li>
</ul>
<h2 id="数列集"><a class="header" href="#数列集">数列集</a></h2>
<p><code>数列集</code>（<code>RangeSet</code>）即包含一个或多个 <code>数列</code> 的集合。</p>
<p>示例：</p>
<pre><code class="language-js">let n = [1..10, 50, 90..100]
</code></pre>
<p>显然往 <code>数列</code> 添加或追加元素，或者两个 <code>数列</code> 连接（<code>++</code>）的结果就是一个 <code>数列集</code>；往 <code>数列集</code> 添加或追加元素，或者两个 <code>数列集</code> 连接，或者重复 <code>数列集</code> 的整体或部分，结果仍然是一个 <code>数列集</code>。</p>
<p>上例的等同代码如下：</p>
<pre><code class="language-js">let n = [1..10].append(50) ++  [90..100]
</code></pre>
<p>注意对数列集合元素的访问得到的是其中的数字，而不是组成它的各个子数列。</p>
<p>示例：</p>
<pre><code class="language-js">let n = [1..10, 50, 90..100]
let f1 = n.first()  # f1 == 1
let f2 = n.get(1)   # f2 == 1
let f3 = n.get(11)  # f3 == 50
let f4 = n.get(12)  # f4 == 90
let f5 = n.get(13)  # f5 == 91
</code></pre>
<h2 id="数组"><a class="header" href="#数组">数组</a></h2>
<p><code>数组</code>（<code>Array</code>）是一种对针具有连续存储整特性的数据而优化的序列。数组的字面量跟列表类似，不同的是需要在第一个中括号之前添加一个感叹号，也就是 <code>![...]</code>。</p>
<p>示例：</p>
<pre><code class="language-js">let a1 = ![1,2,3,4,5]
</code></pre>
<p>数组具有下列特点：</p>
<ul>
<li>数组使用连续的内存储存数据，所以如果需要批量处理数据，使用数组的运行效率要高一些（数据缓存命中率也较高）；</li>
<li>通过元素位置访问数组元素能在常数时间内完成，效率很高；</li>
<li>对数组的任何 &quot;更改&quot; 操作都是整体数据复制的，效率很低。所以数组不适合频繁增删改的场合，也就是说，数组适合只读的场合。</li>
</ul>
<p>使用构造函数也能构建数组，示例：</p>
<ul>
<li>让 a1 = 新建 数组([1,2,3,4,5])</li>
<li>let a1 = new Array([1,2,3,4,5])</li>
</ul>
<p>使用 <code>长度</code>(<code>length</code>) 函数可以获取数组的大小，即数组的元素数量。</p>
<p>示例：</p>
<pre><code class="language-js">let len1 = a1.length()  # 5
</code></pre>
<blockquote>
<p>注意数组的长度是在创建时就确定的，数组创建后，其长度和元素的值均不可改变。</p>
</blockquote>
<p>使用构造函数还能创建初始值相同的数组，示例：</p>
<pre><code class="language-js">let a2 = new Array(4, 1)
let a3 = new Array(4, 0.1)
</code></pre>
<p>上面例子分别创建了一个长度为 4 初始值为整数 1 的数组，即 <code>![1, 1, 1, 1]</code>，另一个是长度为 4 初始值为实数 0.1 的数组，即 <code>![0.1, 0.1, 0.1, 0.1]</code>。</p>
<p><code>数组</code> 还提供创建初始值为随机数的函数 <code>newRandom</code>。</p>
<p>示例：</p>
<pre><code class="language-js">let r2 = Array::newRandom(4, 0.0, 1.0)
</code></pre>
<p>结果会产生一个长度为 4，值在 <code>0.0</code>（包括） 到 <code>1.0</code>（不包括）之间的随机数数组。另外还可以指定随机数的分布规律，比如是否要正态分布等，详细见标准库文档。</p>
<h3 id="字符串-1"><a class="header" href="#字符串-1">字符串</a></h3>
<p><code>字符串</code>（<code>String</code>）实际上是对 <code>数组&lt;字节&gt;</code>（<code>Array&lt;字节&gt;</code>）的封装，但因为需要计算 Unicode 码点，所以使用索引访问字符时，效率非常低。如果需要频繁使用索引访问字符，可以将字符串转换为 <code>Array&lt;Char&gt;</code>。</p>
<!-- 别称，所以字符串的连接效率很低，如果需要多次连接/累加字符串，一般是使用列表作为缓冲，在列表完成全部连接/累加操作后再转换为字符串。
因为字符串是字符数组，所以对字符串的索引访问能在常数时间内完成。
-->
<p>XiaoXuan 为字符串添加了一些额外的函数。</p>
<h4 id="touppercase"><a class="header" href="#touppercase">toUpperCase</a></h4>
<h4 id="tolowercase"><a class="header" href="#tolowercase">toLowerCase</a></h4>
<h4 id="裁剪空白-todo"><a class="header" href="#裁剪空白-todo">裁剪空白 ::TODO</a></h4>
<p>裁剪开始空白
裁剪结束空白</p>
<h4 id="全部替换-todo"><a class="header" href="#全部替换-todo">全部替换 ::TODO</a></h4>
<p>replaceAll(Regex, &quot;..&quot;, String)</p>
<h3 id="多维数组"><a class="header" href="#多维数组">多维数组</a></h3>
<p>数组的元素可以是任何数据类型，显然也能再放入一组数组。当一个数组里直接包含一层或多层子数组时，则可称为 &quot;多维数组&quot;（NDArray，Multi-Dimensional Array，N-Dimensional Array）。</p>
<p>示例，下面使用字面量构建二维数组：</p>
<pre><code class="language-js">let nd1 = ![[1,2,3],
            [4,5,6]]
</code></pre>
<p>注意多维数组字面量里面的子数组需要使用 <code>![...]</code> 符号包围，XiaoXuan 语法约定，一个数组或者多维数组使用 <code>!</code> 符号前缀字面量时，内部的 <code>[...]</code> 符号都会被解析为数组而不是列表。</p>
<p>这个数组的类型是 <code>Array&lt;Array&lt;Int&gt;&gt;</code>，跟列表一样，可以使用 <code>[n]</code> 符号访问第 N 个元素的值。示例：</p>
<pre><code class="language-js">let e1 = nd1[1]
</code></pre>
<p>将会返回 <code>![1,2,3]</code>，如果想访问子数组的元素，可以累加中括号，比如：</p>
<p><code>let e = [n][m]</code></p>
<p>也可以简写为（语法糖）：</p>
<p><code>let e = [n, m]</code></p>
<p>使用 <code>形状</code>（<code>shape</code>） 函数可以获得一个多维数组的各个维度的大小，比如：</p>
<pre><code class="language-js">let s1 = nd1.shape()  # [2,3]
</code></pre>
<p>多维数组也可以使用构造函数构建：</p>
<pre><code class="language-js">let nd2 = Array::new&lt;Array&lt;Int&gt;&gt;([2], 0)          # get an Array&lt;Array&lt;Int&gt;&gt;
let nd3 = Array::new&lt;Array&lt;Array&lt;Int&gt;&gt;&gt;([2,3], 0) # get an Array&lt;Array&lt;Array&lt;Int&gt;&gt;&gt;
</code></pre>
<p>构造函数的第一个参数表示各维的长度，第二个参数是初始值。</p>
<p>为了简化书写，XiaoXiao 为二维到六维数组创建了类型别名，分别是：<code>二维数组</code>（<code>N2Array</code>）、<code>三维数组</code>（<code>N3Array</code>）、一直到 <code>六维数组</code>（<code>N6Array</code>）。</p>
<p>注意多维数组只是多层嵌套的普通数组，所以使用 <code>头</code>（<code>first</code>）函数将会获取多维数组第一维（最外一维）第一个子维度，示例：</p>
<pre><code class="language-js">let n1 = first(nd1)  # n1 == ![1,2,3]
</code></pre>
<p>显然使用 <code>长度</code>（<code>length</code>） 函数也只能获取第一维的大小，而不是整个多维数组的元素总数。</p>
<p>下例是一个 3 维数组：</p>
<p>设有一张 RGB 图片，像素是 2 x 2 pixel，像素的顺序是从左到右，从上往下，4 个点的颜色分别是 &quot;橙-青-紫-绿&quot;。</p>
<svg width="40px" height="40px">
  <rect x="0" y="0" width="10" height="10" fill="rgb(240,160,30)" />
  <rect x="10" y="0" width="10" height="10" fill="rgb(30,240,240)" />
  <rect x="0" y="10" width="10" height="10" fill="rgb(240,30,240)" />
  <rect x="10" y="10" width="10" height="10" fill="rgb(160,240,30)" />
</svg>
<p>将颜色作为第 1 维，将 x, y 坐标（即行，列坐标）作为第 2 维和第 3 维，像素点上的颜色分量值（0～255）作为数组元素的值，则该图片的数据大致如下：</p>
<pre><code class="language-js">let rgb = ![
    [              # 红色（R）
        [240, 30], # 第一行的两个像素点的红色（R）分量
        [240, 160] # 第二行的两个像素点的红色（R）分量
    ],
    [              # 绿色（G）
        [160, 240],
        [30, 240]
    ],
    [              # 蓝色（B）
        [30, 240],
        [240, 30]
    ]
]
</code></pre>
<p>其 3 维图示大致如下：</p>
<pre><code class="language-ascii"> +------------------------&gt; X
 |  +------------+ R
 |  |            |
 |  |  +------------+ G
 |  |  |            |
 |  |  |  +------------+ B
 |  |  |  |            |
 |  +--|  |  30  , 240 |
 |     |  |            |
 |     +--|  240 , 30  |
 |        |            |
 |        +------------+
 V Y
</code></pre>
<p>下面是各个常见函数的调用及返回值：</p>
<pre><code class="language-js">let v1 = rgb.length()  # `3`
let v2 = rgb.shape()   # `[3, 2, 2]`
let v3 = rgb[1]        # `![![30, 240],![240, 30]]`
let v4 = rgb[1][2]     # `![240, 30]`
let v5 = rgb[1, 2]     # `![240, 30]`
let v6 = rgb[1, 2, 1]  # `240`
</code></pre>
<h3 id="矩阵"><a class="header" href="#矩阵">矩阵</a></h3>
<p><code>矩阵</code>（<code>Matrix</code>）是由 m 行（row）n 列（column）元素排列成的矩形阵列。矩阵是二维数组的别称，比如 <code>Matrix&lt;T&gt;</code> 实际上是 <code>Array&lt;Array&lt;T&gt;&gt;</code> 。</p>
<p>矩阵的字面量除了可以使用标准的二维数组表示方法，还能使用简化的格式：使用 <code>![...]</code> 符号包围数据，行与行之间的数据使用分号 <code>;</code> 分隔。</p>
<p>示例：</p>
<pre><code class="language-js">let m1 = ![
    1,2,3;
    4,5,6;
    7,8,9]
</code></pre>
<p>它跟下面的二维数组的字面量是等效的：</p>
<pre><code class="language-js">let m1 = ![[1,2,3],
           [4,5,6],
           [7,8,9]]
</code></pre>
<p>显然简化版的表示方法要简单一些，而且在省略变量的数据类型情况下，第一种写法返回的数据类型显示名称时显示的是 <code>Matrix&lt;Int&gt;</code>，而第二种写法是 <code>Array&lt;Array&lt;Int&gt;&gt;</code>（注意只是显示名称不一样，实际运算时都是使用别名的真实类型，即 <code>Array&lt;Array&lt;Int&gt;&gt;</code>）。它们构建的矩阵如下：</p>
<p>$$
\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
a_{m1} &amp; a_{m2} &amp; \cdots&amp; a_{mn} \
\end{bmatrix}
$$</p>
<p>跟访问二维数组的方法一样，也可以使用中括号访问矩阵的元素，比如第 1 行第 2 列（即 m=1, n=2）的元素，语句如下：</p>
<pre><code class="language-js">让 c1 = m1[1][2]  # c == 2
让 c2 = m1[1, 2]   # c == 2
</code></pre>
<pre><code class="language-js">let c1 = m1[1][2]  # c == 2
let c2 = m1[1, 2]   # c == 2
</code></pre>
<p>矩阵也可以通过构造函数构建。</p>
<p>示例：</p>
<pre><code class="language-js">let m = new Matrix(2, 3, 0)
</code></pre>
<p>构造函数的参数分别表示行、列、初始值。</p>
<p>同样也可以创建随机数的矩阵：</p>
<pre><code class="language-js">let m = Matrix::newRandom(2, 3, 0.0, 1.0)
</code></pre>
<p>XiaoXuan 为 <code>Matrix&lt;Int&gt;</code> 重载了矩阵的乘法运算，<code>矩阵 a * 矩阵 b</code> 的结果是：</p>
<p>$$
c(i,j) = \sum_{k=1}^{n}{a(i,k)b(k,j)}
$$</p>
<p>即线性代数的矩阵乘法（前提是矩阵 a 的行数必须等于 b 的列数）；结构相同的矩阵有加法和减法运算；标量和矩阵有乘法运算，表示逐个元素跟该标量相乘。详细见 https://en.wikipedia.org/wiki/Matrix_(mathematics)#Basic_operations</p>
<p>对于一维数组，有点积（用点乘 <code>.*</code> 符号表示）运算，可用于大小相同的数组，表示逐个位置对应的元素相乘，然后求和。XiaoXuan 没有提供一维数组的叉积运算。</p>
<p>XiaoXuan 还提供诸如 <code>获取列</code>（<code>getColumn</code>） 函数，用来获取指定的一列数据。</p>
<h2 id="列表数组列表的比较"><a class="header" href="#列表数组列表的比较">列表、数组、列表的比较</a></h2>
<p>除了列表，还有其他几种序列类型的数据集合，即都实现了 <code>序列</code>（<code>Sequence</code>）特性。它们一般具有跟列表一致的访问接口，比如可以使用 <code>let [a, ...b] = n</code> 获取第一个元素和其余元素，有些序列支持添加元素操作，也就可以使用 <code>let n = [a,...b]</code> 添加元素。</p>
<!--
所有序列都可以使用 `数据类型[]`（`DataType[]`） 这样的格式作表示其数据类型，比如：

`Int[] a = [1,2,3,4,5]`

下面将会讲述的数列、数组也能用同样的方法赋值到一个变量，比如：

`Int[] b = [1..5]`
`Int[] c = ![1,2,3]`

实际上 `数据类型[]` 就是 `序列<数据类型>`（`Sequence<DataType>`） 的别名。所以上面的代码等同于：

`Sequence<Int> b = [1..5]`


需注意的是一旦将具体的一个序列赋值给这种数据类型的变量或者参数之后，就丢失了具体类型的其他特性。`序列` 特性只有 `第一个`、`其余` 两个方法。
-->
<h3 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h3>
<p>下面比较列表、列表、数集、数组这几种序列：</p>
<ul>
<li>
<p>列表</p>
<p>列表可作为一般用途的数据集合。一般用于需要增加、连接、删除、拆解元素等场合。不适合（在尾部）累加元素，也不适合按索引访问元素。</p>
</li>
<li>
<p>数组</p>
<p>数组适合需要经常批量访问数据（即一次访问多个数据）的场合，适合按索引访问元素，适合 &quot;一次构建、多次读取&quot;。数组不适合需要增加、连接、删除、拆解元素等场合。</p>
</li>
<li>
<p>列表</p>
<p>列表适合（在尾部）累加元素，比如构建字符串、表格等，适合 &quot;多次写入，多次读取&quot;。</p>
</li>
</ul>
<h2 id="序列的常用函数"><a class="header" href="#序列的常用函数">序列的常用函数</a></h2>
<p>上面讲述的列表、数列、数集、列表、数组都属于序列，即它们都实现了 <code>序列</code>（<code>Sequence</code>）特性，<code>序列</code> 特性包含了两个方法 <code>第一个</code>（以及 <code>尝试第一个</code>） 和 <code>其余</code>。</p>
<p>::TODO 至于 List, Array 它们实现了 <code>Collection</code> 特性，该特性是好几个特性的组合。</p>
<p>然而大部分派生于 <code>序列</code> 的数据类型都不仅仅具有 <code>序列</code> 特性，同时还具有其他伴随的特性，这里不一一展开，下面笼统地使用 <code>序列</code>（<code>Sequence</code>）代替这类派生于 <code>序列</code> 的数据类型。</p>
<p>下面列出这些数据类型通常会具有的方法及其方法原型。</p>
<ul>
<li>
<p>长度 length
<code>整数 &lt;- 长度 (序列&lt;T&gt; 目标)</code>
<code>Int &lt;- length (Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>第一个 first
<code>T &lt;- 第一个 (序列&lt;T&gt; 目标)</code>
<code>T &lt;- first (Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>尝试第一个 tryFirst
<code>可选&lt;T&gt; &lt;- 尝试第一个 (序列&lt;T&gt; 目标)</code>
<code>Option&lt;T&gt; &lt;- tryFirst (Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>其余 rest
<code>序列&lt;T&gt; &lt;- 其余 (序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;T&gt; &lt;- rest (Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>最后一个 last
<code>T &lt;- 最后一个 (序列&lt;T&gt; 目标)</code>
<code>T &lt;- last (Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>尝试最后一个 tryLast
<code>可选&lt;T&gt; &lt;- 尝试最后一个 (序列&lt;T&gt; 目标)</code>
<code>Option&lt;T&gt; &lt;- tryLast (Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>最后一个除外 exceptLast
<code>序列&lt;T&gt; &lt;- 最后一个除外 (序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;T&gt; &lt;- exceptLast (Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>获取 get
<code>T &lt;- 获取 (整数 位置, 序列&lt;T&gt; 目标)</code>
<code>T &lt;- get (Int position, Sequence&lt;T&gt; target)</code></p>
<p>语法糖：
<code>目标序列[位置]</code>
<code>target_seq[position]</code></p>
</li>
<li>
<p>尝试获取 tryGet
<code>可选&lt;T&gt; &lt;- 尝试获取 (整数 位置, 序列&lt;T&gt; 目标)</code>
<code>Option&lt;T&gt; &lt;- tryGet (Int position, Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>选取 slice
<code>序列&lt;T&gt; &lt;- 选取 (整数 开始位置, 整数 数量, 序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;T&gt; &lt;- slice (Int startPos, Int count, Sequence&lt;T&gt; target)</code></p>
<p>语法糖：
<code>目标序列[开始位置:数量]</code>
<code>target_seq[startPos:count]</code></p>
</li>
<li>
<p>开始部分 take
<code>序列&lt;T&gt; &lt;- 开始部分 (整数 数量, 序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;T&gt; &lt;- take (Int count, Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>添加 add
<code>序列&lt;T&gt; &lt;- 添加 (T 新增项, 序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;T&gt; &lt;- add (T additional, Sequence&lt;T&gt; target)</code></p>
<p>语法糖：
<code>[新增项, ...目标序列]</code>
<code>[additional, ...target_seq]</code></p>
</li>
</ul>
<p>//TODO:: remove（移除，删除第一个元素，返回 (first, rest)）</p>
<ul>
<li>
<p>追加 append
<code>序列&lt;T&gt; &lt;- 追加 (T 新增项, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;T&gt; &lt;- 追加 (序列&lt;T&gt; 新增项, 序列&lt;T&gt; 目标)</code></p>
<p><code>Sequence&lt;T&gt; &lt;- append (T additional, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;T&gt; &lt;- append (Sequence&lt;T&gt; additional, Sequence&lt;T&gt; target)</code></p>
</li>
</ul>
<p>//TODO:: drop (抛弃，删除最后一个元素，返回 (last, expectLast))</p>
<ul>
<li>
<p>删除 remove (TODO:: 改名为 delete 或者 cut，表示中间删除)
<code>序列&lt;T&gt; &lt;- 删除 (整数 位置, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;T&gt; &lt;- 删除 (整数 开始位置, 整数 数量, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;T&gt; &lt;- 删除 (逻辑 &lt;- (T), 序列&lt;T&gt; 目标)</code></p>
<p><code>Sequence&lt;T&gt; &lt;- remove (Int position, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;T&gt; &lt;- remove (Int startPos, Int count, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;T&gt; &lt;- remove (Boolean &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>过滤 filter
<code>序列&lt;T&gt; &lt;- 过滤 (逻辑 &lt;- (T), 序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;T&gt; &lt;- filter (Boolean &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>拆分 separate
<code>(序列&lt;T&gt;, 序列&lt;T&gt;) &lt;- 拆分 (整数 位置之前, 序列&lt;T&gt; 目标)</code>
<code>(序列&lt;T&gt;, 序列&lt;T&gt;) &lt;- 拆分 (逻辑 &lt;- (T), 序列&lt;T&gt; 目标)</code></p>
<p><code>(Sequence&lt;T&gt;, Sequence&lt;T&gt;) &lt;- separate (Int posBefore, Sequence&lt;T&gt; target)</code>
<code>(Sequence&lt;T&gt;, Sequence&lt;T&gt;) &lt;- separate (Boolean &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>连接 concat （TODO:: 考虑使用 append 代替）
<code>序列&lt;T&gt; &lt;- 连接 (序列&lt;T&gt; 新增项, 序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;T&gt; &lt;- concat (Sequence&lt;T&gt; additional, Sequence&lt;T&gt; target)</code></p>
<p>语法糖：
<code>新增项 ++ 目标序列</code>
<code>additional ++ target_seq</code></p>
</li>
<li>
<p>裁剪 trim
<code>序列&lt;T&gt; &lt;- 裁剪 (T 项目, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;T&gt; &lt;- 裁剪 (逻辑 &lt;- T, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;T&gt; &lt;- 裁剪头 (T 项目, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;T&gt; &lt;- 裁剪头 (逻辑 &lt;- T, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;T&gt; &lt;- 裁剪尾 (T 项目, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;T&gt; &lt;- 裁剪尾 (逻辑 &lt;- T, 序列&lt;T&gt; 目标)</code></p>
<p><code>Sequence&lt;T&gt; &lt;- trim (T item, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;T&gt; &lt;- trim (Boolean &lt;- T, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;T&gt; &lt;- trimStart (T item, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;T&gt; &lt;- trimStart (Boolean &lt;- T, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;T&gt; &lt;- trimEnd (T item, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;T&gt; &lt;- trimEnd (Boolean &lt;- T, Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>补齐
<code>序列&lt;T&gt; &lt;- 补齐头(T 项目, 整数 长度, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;T&gt; &lt;- 补齐尾(T 项目, 整数 长度, 序列&lt;T&gt; 目标)</code></p>
<p><code>Sequence&lt;T&gt; &lt;- padStart(T item, Int length, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;T&gt; &lt;- padEnd(T item, Int length, Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>重复 replicate
<code>序列&lt;T&gt; &lt;- 重复 (整数 数量, 序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;T&gt; &lt;- replicate (Int count, Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>平分 part
<code>序列&lt;序列&lt;T&gt;&gt; &lt;- 平分 (整数 数量, 序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;Sequence&lt;T&gt;&gt; &lt;- part (Int count, Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>分隔 split
<code>序列&lt;序列&lt;T&gt;&gt; &lt;- 分隔 (T 分隔符, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;序列&lt;T&gt;&gt; &lt;- 分隔 (逻辑 &lt;- (T), 序列&lt;T&gt; 目标)</code></p>
<p><code>Sequence&lt;Sequence&lt;T&gt;&gt; &lt;- split (T separater, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;Sequence&lt;T&gt;&gt; &lt;- split (Boolean &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>拼接 join
<code>序列&lt;T&gt; &lt;- 拼接 (T 连接符, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;T&gt; &lt;- 拼接 (序列&lt;T&gt; 连接符, 序列&lt;T&gt; 目标)</code></p>
<p><code>Sequence&lt;T&gt; &lt;- join (T joint, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;T&gt; &lt;- join (Sequence&lt;T&gt; joint, Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>插入 insert
<code>序列&lt;T&gt; &lt;- insert (整数 位置之前, T 新增项, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;T&gt; &lt;- insert (整数 位置之前, 序列&lt;T&gt; 新增项, 序列&lt;T&gt; 目标)</code></p>
<p><code>Sequence&lt;T&gt; &lt;- insert (Int posBefore, T additional, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;T&gt; &lt;- insert (Int posBefore, Sequence&lt;T&gt; additional, Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>替换 replace
<code>序列&lt;T&gt; &lt;- replace (整数 开始位置, 整数 数量, T 替换项, 序列&lt;T&gt; 目标)</code>
<code>序列&lt;T&gt; &lt;- replace (整数 开始位置, 整数 数量, 序列&lt;T&gt; 替换项, 序列&lt;T&gt; 目标)</code></p>
<p><code>Sequence&lt;T&gt; &lt;- replace (Int startPos, Int count, T, Sequence&lt;T&gt; target)</code>
<code>Sequence&lt;T&gt; &lt;- replace (Int startPos, Int count, Sequence&lt;T&gt;, Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>排序 sort
<code>序列&lt;T&gt; &lt;- sort (序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;T&gt; &lt;- sort (Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>反转 reverse
<code>序列&lt;T&gt; &lt;- reverse (序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;T&gt; &lt;- reverse (Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>查找位置 findPosition
<code>可选&lt;整数&gt; &lt;- 查找位置 (T 查找项, 序列&lt;T&gt; 目标)</code>
<code>可选&lt;整数&gt; &lt;- 查找位置 (逻辑 &lt;- (T), 序列&lt;T&gt; 目标)</code></p>
<p><code>Option&lt;Int&gt; &lt;- findPosition (T searching, Sequence&lt;T&gt; target)</code>
<code>Option&lt;Int&gt; &lt;- findPosition (Boolean &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>反向查找位置 reverseFindPosition
<code>可选&lt;整数&gt; &lt;- 反向查找位置 (T 查找项, 序列&lt;T&gt; 目标)</code>
<code>可选&lt;整数&gt; &lt;- 反向查找位置 (逻辑 &lt;- (T), 序列&lt;T&gt; 目标)</code></p>
<p><code>Option&lt;Int&gt; &lt;- reverseFindPosition (T searching, Sequence&lt;T&gt; target)</code>
<code>Option&lt;Int&gt; &lt;- reverseFindPosition (Boolean &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>查找 find
<code>可选&lt;T&gt; &lt;- 查找 (逻辑 &lt;- (T), 序列&lt;T&gt; 目标)</code>
<code>Option&lt;T&gt; &lt;- 查找 (Boolean &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>存在 exist
<code>逻辑 &lt;- 存在 (T 查找项, 序列&lt;T&gt; 目标)</code>
<code>逻辑 &lt;- 存在 (逻辑 &lt;- (T), 序列&lt;T&gt; 目标)</code></p>
<p><code>Boolean &lt;- exist (T searching, Sequence&lt;T&gt; target)</code>
<code>Boolean &lt;- exist (Boolean &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>存在开始 existStart
<code>逻辑 &lt;- 存在开始 (T 查找项, 序列&lt;T&gt; 目标)</code>
<code>逻辑 &lt;- 存在开始 (序列&lt;T&gt; 查找项, 序列&lt;T&gt; 目标)</code>
<code>逻辑 &lt;- 存在开始 (逻辑 &lt;- (T), 序列&lt;T&gt; 目标)</code></p>
<p><code>Boolean &lt;- existStart (T searching, Sequence&lt;T&gt; target)</code>
<code>Boolean &lt;- existStart (Sequence&lt;T&gt; searching, Sequence&lt;T&gt; target)</code>
<code>Boolean &lt;- existStart (Boolean &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>存在结束 existEnd
<code>逻辑 &lt;- 存在结束 (T 查找项, 序列&lt;T&gt; 目标)</code>
<code>逻辑 &lt;- 存在结束 (序列&lt;T&gt; 查找项, 序列&lt;T&gt; 目标)</code>
<code>逻辑 &lt;- 存在结束 (Boolean &lt;- (T), 序列&lt;T&gt; 目标)</code></p>
<p><code>Boolean &lt;- existEnd (T searching, Sequence&lt;T&gt; target)</code>
<code>Boolean &lt;- existEnd (Sequence&lt;T&gt; searching, Sequence&lt;T&gt; target)</code>
<code>Boolean &lt;- existEnd (Boolean &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>全部匹配 allMatch
<code>逻辑 &lt;- 全部匹配 (Boolean &lt;- (T), 序列&lt;T&gt; 目标)</code>
<code>Boolean &lt;- allMatch (Boolean &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>逐个 each
<code>void &lt;- 逐个(void &lt;- (T), 序列&lt;T&gt; 目标)</code>
<code>void &lt;- each(void &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>映射 map
<code>序列&lt;E&gt; &lt;- 映射 (E &lt;- (T), 序列&lt;T&gt; 目标)</code>
<code>Sequence&lt;E&gt; &lt;- map (E &lt;- (T), Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>折叠 fold
<code>E &lt;- 折叠(E &lt;- (E 累计值, T 当前值), E 初始值,  序列&lt;T&gt; 目标)</code>
<code>E &lt;- fold(E &lt;- (E accumulator, T currentValue), E initialValue,  Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>右折叠 foldRight
<code>E &lt;- 右折叠(E &lt;- (E 累计值, T 当前值), E 初始值,  序列&lt;T&gt; 目标)</code>
<code>E &lt;- foldRight(E &lt;- (E accumulator, T currentValue), E initialValue,  Sequence&lt;T&gt; target)</code></p>
</li>
<li>
<p>配对 zip
<code>序列&lt;(E, T)&gt; &lt;- 配对 (序列&lt;E&gt; 增加项, 序列&lt;T&gt; 目标)</code></p>
<p><code>Sequence&lt;(E, T)&gt; &lt;- zip (Sequence&lt;E&gt; additional, Sequence&lt;T&gt; target)</code></p>
</li>
</ul>
<h3 id="数字列表"><a class="header" href="#数字列表">数字列表</a></h3>
<p>对于整数、自然数、实数型列表，还有 max, min, average, sum, median 等函数。</p>
<h3 id="字符列表"><a class="header" href="#字符列表">字符列表</a></h3>
<p>对于字符列表，有 toUpperCase, toLowerCase, trim, trimBegin, trimEnd, replaceAll 等函数。</p>
<p>另外还有求相似度、Diff、Hash、KMP/Rabin-Karp/BM(Boyer-Moore)/horspool/Sunday 单关键字和 AC 自动机多关键字快速搜索、模糊匹配等常用算法。</p>
<h2 id="表格"><a class="header" href="#表格">表格</a></h2>
<p><code>表格</code>（<code>Table</code>）是一个由标头、行、列组成的数据。同一列的数据类型必须相同，标头就是列的名称。一行数据由各列数据在同一行的数据组成。表格在概念上跟电子表格（spreadsheet）是一样的。注意表格不是序列。</p>
<p>构造一个表格之前先需要定义一个结构体，一行数据就是一个结构体的实例，标头就是结构体各成员的名称。</p>
<p>示例，下面构建一个 <code>用户</code>（<code>User</code>） 结构体：</p>
<pre><code class="language-js">结构体 用户
    整数 编号
    字符串 姓名
    逻辑 检查
以上
</code></pre>
<pre><code class="language-js">struct User
    Int id
    String name
    Boolean checked
end
</code></pre>
<p>然后使用 <code>表格</code> 构造函数构建表格：</p>
<pre><code class="language-js">let t1 = new Table&lt;User&gt;([
    User(1, &quot;foo&quot;, true),
    User(2, &quot;bar&quot;, false)
])
</code></pre>
<p>XiaoXuan 提供了一个字面量语法糖构建结构体，上例的表格可以使用下面的字面量来构建：</p>
<pre><code class="language-js">let t1 = ![
    User(Int id, String name, Boolean checked);
    1, &quot;foo&quot;, true;
    2, &quot;bar&quot;, false
]
</code></pre>
<p>如果提供的数据是基本的数据类型，也可以省略第一行结构体当中的成员数据类型，示例：</p>
<pre><code class="language-js">let t1 = ![
    User(id, name, checked);
    1, &quot;foo&quot;, true;
    2, &quot;bar&quot;, false
]
</code></pre>
<p>上例所构建的表格如下：</p>
<div class="table-wrapper"><table><thead><tr><th>id</th><th>name</th><th>checked</th></tr></thead><tbody>
<tr><td>1</td><td>foo</td><td>true</td></tr>
<tr><td>2</td><td>bar</td><td>false</td></tr>
</tbody></table>
</div>
<p>使用 <code>标头</code>（<code>header</code>）函数可以获取表格的结构体类型，使用 <code>标头标题</code>（<code>headerTitles</code>）可以获取由标头组成的字符串列表，比如 <code>[&quot;id&quot;, &quot;name&quot;, &quot;checked&quot;]</code>。</p>
<p>表格也是一种序列，可以视为元素为一个结构体的列表，即上例 <code>Table&lt;User&gt;</code> 大致相当于列表 <code>List&lt;User&gt;</code>。所以同一般序列一样，使用 <code>获取</code>（<code>get</code>）函数可以获取指定行的数据，返回的是一个结构体。</p>
<p>示例：</p>
<pre><code class="language-js">let i = t1.get(2)
</code></pre>
<p>则 <code>i</code> 的值是 <code>User(id=2, name=&quot;bar&quot;, checked=false)</code>。</p>
<p>跟元素类型为一个结构体的列表（如 <code>List&lt;User&gt;</code>）不同，<code>表格</code> 数据类型提供了很多跟表格处理相关的函数，比如排序、筛选等。</p>
<h2 id="映射表"><a class="header" href="#映射表">映射表</a></h2>
<p><code>映射表</code>（<code>Map</code>）是一系列 &quot;键-值对&quot; 数据。映射表不属于序列（即映射表没有实现 <code>序列</code> 特性），但也是常用的数据集合的一种。</p>
<p>映射表的字面量是：使用一对花括号包围所有数据，多个 &quot;键-值对&quot;（key-value pair） 之间使用逗号分隔，使用 &quot;键名:值&quot; 构建 &quot;键-值对&quot;。示例：</p>
<pre><code class="language-js">{
    #东: 123,
    #西: 456
}
</code></pre>
<pre><code class="language-js">{
    #foo: 123,
    #bar: 456
}
</code></pre>
<!--
键支持大部分类型的数据，只要实现了 "可散列" 特性即可，值可以是任何类型的数据。当键为散列字符串类型时，键名的井号可以省略，比如上面第一个映射表，可以简化为：
-->
<p>(::TODO 考虑移除此特性，去除了 # 符号，容易跟变量名混淆)</p>
<pre><code class="language-js">{
    东: 123,
    西: 456
}
</code></pre>
<pre><code class="language-js">{
    foo: 123,
    bar: 456
}
</code></pre>
<blockquote>
<p>使用整数作为键有最好的性能，一般映射表的内部也是使用整数作为键。当用户使用其他数据类型作为键时，程序会调用数据的 <code>获取散列值</code>（<code>getHash</code>）函数获取对象的散列值，然后再作为内部键使用。XiaoXuan 内置了一种叫 <code>散列字符串</code>（<code>HashString</code>）的数据类型，具有 <code>可散列</code> 特性，在创造实例的时候计算散列值，适合作为映射表的键。</p>
</blockquote>
<p>需注意一个映射表里的所有 &quot;键-值对&quot; 的数据类型必须一样，&quot;键-值对&quot; 实际上是一个含有两个成员的结构体，结构体定义如下：</p>
<pre><code class="language-js">结构体 映射表元素&lt;T,E&gt;
    T 键
    E 值
以上
</code></pre>
<pre><code class="language-js">struct MapElement&lt;T,E&gt;
    T key
    E value
end
</code></pre>
<p>结构体的第一个成员是 &quot;键&quot;，第二个成员是 &quot;值&quot;。上面示例的第一个映射表数据类型是 &quot;映射表&lt;字符串, 整数&gt;&quot;, 第二个是 &quot;映射表&lt;字符串, 字符串&gt;&quot;。</p>
<p>XiaoXuan 运行环境默认使用二叉树（或者平衡树）来实现映射表。</p>
<h3 id="访问映射表的元素"><a class="header" href="#访问映射表的元素">访问映射表的元素</a></h3>
<p>使用 <code>获取</code>（<code>get</code>）函数用于获取指定键的元素。</p>
<p>假设现有映射表 <code>a</code> 内容如下：</p>
<pre><code class="language-js">让 a = {
    #东: 1,
    #西: 2,
    #南: 3,
    #北: 4
}
</code></pre>
<p>如果项获取键 &quot;西&quot; 的值，语句如下：</p>
<ul>
<li>
<p><code>让 i = 获取 (#西, a)</code></p>
</li>
<li>
<p><code>让 i = a.获取 (#西)</code></p>
</li>
<li>
<p><code>let i = get (#西, a)</code></p>
</li>
<li>
<p><code>let i = a.get (#西)</code></p>
</li>
</ul>
<p>如果指定的键不存在，则会抛出运行时异常。如果想试探性获取一个键值，可以使用 <code>尝试获取</code>（<code>tryGet</code>）函数，函数返回 <code>可选&lt;T&gt;</code>（<code>Option&lt;T&gt;</code>），如果存在指定键，则返回 <code>可选::有(值)</code>，否则返回 <code>可选::无</code>。</p>
<p>示例：</p>
<pre><code class="language-js">let i = tryGet(#西, a)
let j = tryGet(#中, a)
</code></pre>
<p>变量 <code>i</code> 的值为 <code>可选::有(2)</code>，变量 <code>j</code> 的值为 <code>可选::无</code>。</p>
<h4 id="使用中括号获取指定键的值"><a class="header" href="#使用中括号获取指定键的值">使用中括号获取指定键的值</a></h4>
<p>可以在映射表实例后面使用一对中括号 <code>[...]</code> 简化调用 <code>获取</code> 函数。</p>
<p>示例：</p>
<ul>
<li><code>让 i = a[#西]</code></li>
<li><code>let i = a[#西]</code></li>
</ul>
<p>变量 i 的值跟使用 <code>获取(#西, a)</code> 函数的返回值一样。</p>
<h4 id="使用模式解构获取指定键的值"><a class="header" href="#使用模式解构获取指定键的值">使用模式解构获取指定键的值</a></h4>
<p>示例：</p>
<pre><code class="language-js"># 同时获取键 &quot;东&quot; 和 &quot;南&quot; 的值，并赋值给变量 i 和 j。
让 {#东#: i, #南#: j} = a

# 同上，然后将剩余的 &quot;键-值对&quot; 存入变量 k，变量 k 将是一个映射表，
# 其内容为 `{&quot;西&quot;: 2, &quot;北&quot;: 4}`
让 {#东#: i, #南#: j, ...k} = a

# 当键的数据类型是散列字符串时，也可以省略双引号
让 {东: i, 南: j} = a

# 如果连变量 i, j 都省略，那么将会得到跟键名一样的变量
让 {东, 南} = a
</code></pre>
<h3 id="添加新的-键-值对"><a class="header" href="#添加新的-键-值对">添加新的 &quot;键-值对&quot;</a></h3>
<p>使用 <code>添加</code>（<code>add</code>）函数向映射表添加新的 &quot;键-值对&quot;（&quot;key-value pair&quot;），函数返回值是 <code>结果&lt;映射表&gt;</code>。如果操作成功，则返回 <code>好(新映射表)</code>（<code>Ok(new_map)</code>），如果键名已经存在，则返回 <code>错误()</code>（<code>Err()</code>）。</p>
<p>示例：</p>
<pre><code class="language-js">match a.add(#中#, 5)
    case Ok(m): writeLineFormat(&quot;new map: {:?}&quot;, m)
    case Err(): writeLine(&quot;error&quot;)
end
</code></pre>
<p>正如上面所说，&quot;键-值对&quot; 实际上是一个含有两个成员的结构体，所以也可以直接添加 &quot;键-值对&quot; 结构体：</p>
<pre><code class="language-js">let e = new 映射表元素(#中#, 5)
a.add(e)
</code></pre>
<h3 id="更新已存在的键值"><a class="header" href="#更新已存在的键值">更新已存在的键值</a></h3>
<p>使用 <code>更新</code>（<code>update</code>）函数向映射表更新已存在的键值，如果操作成功，则返回 <code>好(新映射表)</code>（<code>Ok(new_map)</code>），如果指定的键不存在，则返回 <code>错误()</code>（<code>Err()</code>）。</p>
<p>示例：</p>
<pre><code class="language-js">match a.update(#中#, 2)
    case Ok(m): ...
    case Err(): ...
end
</code></pre>
<h3 id="添加或更新-键-值对"><a class="header" href="#添加或更新-键-值对">添加或更新 &quot;键-值对&quot;</a></h3>
<p>可以使用 <code>添加或更新</code>（<code>addOrUpdate</code>）函数添加或更新 &quot;键-值对&quot;，也就是说，如果指定的键不存在，则相当于 <code>添加</code> 函数，如果指定的键已存在，则相当于 <code>更新</code> 函数。函数总是返回一个新的映射表。</p>
<p>示例：</p>
<pre><code class="language-js">let b = a.addOrUpdate(#中#, 6)
</code></pre>
<h4 id="使用三个点来添加或更新-键-值对"><a class="header" href="#使用三个点来添加或更新-键-值对">使用三个点来添加或更新 &quot;键-值对&quot;</a></h4>
<p>使用三个点符号 &quot;...&quot; 可以代替 <code>添加或更新</code> 函数，示例：</p>
<pre><code class="language-js">let m = {a: 123, b: 456}
let b1 = {c: 789, ...m}
let b2 = {a: 555, ...m}
</code></pre>
<p>结果变量 <code>b1</code> 的值为 <code>{&quot;a&quot;: 123, &quot;b&quot;: 456, &quot;c&quot;: 789}</code>，变量 <code>b2</code> 的值为 <code>{&quot;a&quot;: 555, &quot;b&quot;: 456}</code></p>
<h3 id="检查指定键是否存在"><a class="header" href="#检查指定键是否存在">检查指定键是否存在</a></h3>
<p>使用 <code>存在</code>（<code>exist</code>）函数可以检查是否存在指定的键，如果存在则返回 <code>真</code>（<code>true</code>），否则返回 <code>假</code>（<code>false</code>）。</p>
<p>示例：</p>
<pre><code class="language-js">let m = {&quot;a&quot;: 123, &quot;b&quot;: 456}
let e1 = m.exist(&quot;a&quot;)
let e2 = m.exist(&quot;c&quot;)
</code></pre>
<p>结果变量 <code>e1</code> 的值为 <code>真</code>，变量 <code>e2</code> 的值为 <code>假</code>。</p>
<p><code>存在</code> 函数也接受一个签名为 <code>Boolean &lt;- (MapEntry&lt;K, V&gt;)</code> 或者 <code>Boolean &lt;- (K, V)</code> 的函数，<code>存在</code> 函数会从映射表里逐个取出 &quot;键-值 对&quot;，然后调用参数函数，当参数函数返回值为 <code>真</code> 时，函数立即返回 <code>真</code>。</p>
<pre><code class="language-js">let m = {&quot;a&quot;: 123, &quot;b&quot;: 456}
let e1 = m.exist((k, v) =&gt; k == &quot;a&quot;)  # true
let e2 = m.exist((k, v) =&gt; v &gt; 300)   # true
let e2 = m.exist((_, v) =&gt; v &gt; 500)   # false
</code></pre>
<h3 id="删除-键-值对"><a class="header" href="#删除-键-值对">删除 &quot;键-值对&quot;</a></h3>
<p>使用 <code>删除</code>（<code>remove</code>） 函数可以根据指定的键删除 &quot;键-值 对&quot;，需注意如果指定的键不存在，会引起运行时异常。</p>
<p>可以使用 <code>尝试删除</code>（<code>tryRemove</code>） 函数常识性地 &quot;删除&quot; 映射表指定的 &quot;键-值对&quot;，函数返回值的类型是 <code>结果&lt;映射表&gt;</code>，成功则返回新映射表，如果指定键不存在则返回 <code>错误()</code>。</p>
<h3 id="删除多个-键-值对"><a class="header" href="#删除多个-键-值对">删除多个 &quot;键-值对&quot;</a></h3>
<p>使用 <code>删除全部</code>（<code>removeAll</code>） 函数可以根据条件删除一个或多个 &quot;键-值 对&quot;。</p>
<pre><code class="language-js">let m = {&quot;a&quot;: 123, &quot;b&quot;: 456}
let e1 = m.removeAll((k, v) =&gt; v &gt; 300)  # {&quot;a&quot;: 123}
</code></pre>
<h3 id="过滤-键-值对"><a class="header" href="#过滤-键-值对">过滤 &quot;键-值对&quot;</a></h3>
<p>使用 <code>过滤</code>（<code>filter</code>） 函数可以根据条件过滤掉一个或多个 &quot;键-值 对&quot;，只保留满足过滤条件的 &quot;键-值 对&quot;。</p>
<pre><code class="language-js">let m = {&quot;a&quot;: 123, &quot;b&quot;: 456}
let e1 = m.filter((k, v) =&gt; v &gt; 300)  # {&quot;b&quot;: 456}
</code></pre>
<h3 id="遍历映射表元素"><a class="header" href="#遍历映射表元素">遍历映射表元素</a></h3>
<p>使用 <code>转为列表</code>（<code>toList</code>） 函数可以获取映射表的所有项目，返回值是一个列表，列表的元素是 &quot;键-值对&quot;，即 <code>映射表元素&lt;T,E&gt;</code>。</p>
<p>示例：</p>
<pre><code class="language-js">let items = a.toList()
for item in items
    writeLine (item.key, item.value)
end
</code></pre>
<p>上面示例会遍历映射表 <code>a</code> 的所有元素。</p>
<p>另外还有 <code>获取键组</code>（<code>getKeys</code>） 和 <code>获取值组</code>（<code>getValues</code>）函数可以获取映射表的键组和值组。</p>
<h2 id="集合"><a class="header" href="#集合">集合</a></h2>
<p><code>集合</code>（<code>Set</code>）跟列表类似，但它不允许有重复的数据。集合可以理解为只有 &quot;键&quot; 而没有 &quot;值&quot; 的映射表，实际上 <code>Set</code> 就是 <code>Map&lt;T, Unit&gt;</code> 数据类型的别名（<code>Unit</code> 即 <code>空元型</code>，它只有一个值 <code>空间型::空元</code>，<code>Unit::Empty</code>）。集合一般用来排除重复数据。</p>
<p>集的字面量表示方法，</p>
<pre><code class="language-js">let s1 = !{1,2,2,3}
let s2 = !{&quot;abc&quot;, &quot;xyz&quot;, &quot;abc&quot;, &quot;abc&quot;}
</code></pre>
<p>使用构造函数构建：</p>
<pre><code class="language-js">让 s1 = 新建 集([1,2,2,3])
让 s2 = 新建 集([&quot;abc&quot;, &quot;xyz&quot;, &quot;abc&quot;, &quot;abc&quot;])
</code></pre>
<pre><code class="language-js">let s1 = new Set([1,2,2,3])
let s2 = new Set([&quot;abc&quot;, &quot;xyz&quot;, &quot;abc&quot;, &quot;abc&quot;])
</code></pre>
<p>上例中重复的数据将会被剔除，最后 <code>s1</code> 的值为 <code>1, 2, 3</code>，<code>s2</code> 的值为 <code>&quot;abc&quot;, &quot;xyz&quot;</code>。</p>
<h3 id="转换为普通列表"><a class="header" href="#转换为普通列表">转换为普通列表</a></h3>
<p>通常运行环境使用二叉树（或者平衡树）实现数据表，从集合读取元素的效率很低，因此需要使用集合的 <code>转为列表</code>（<code>toList</code>） 函数即将集合转换为普通列表。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体和联合体"><a class="header" href="#结构体和联合体">结构体和联合体</a></h1>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="structs-and-unions.html#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93">结构体和联合体</a>
<ul>
<li><a href="structs-and-unions.html#%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a>
<ul>
<li><a href="structs-and-unions.html#%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93">实例化结构体</a></li>
<li><a href="structs-and-unions.html#%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E7%9A%84%E5%80%BC">访问结构体成员的值</a></li>
<li><a href="structs-and-unions.html#%E6%9B%B4%E6%96%B0%E6%88%90%E5%91%98%E7%9A%84%E5%80%BC">更新成员的值</a></li>
<li><a href="structs-and-unions.html#%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81%E7%BA%A6%E6%9D%9F">数据验证约束</a></li>
<li><a href="structs-and-unions.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">自定义构造函数</a></li>
<li><a href="structs-and-unions.html#%E5%8C%BF%E5%90%8D%E6%88%90%E5%91%98%E7%BB%93%E6%9E%84%E4%BD%93">匿名成员结构体</a></li>
<li><a href="structs-and-unions.html#%E6%97%A0%E6%88%90%E5%91%98%E7%BB%93%E6%9E%84%E4%BD%93">无成员结构体</a></li>
</ul>
</li>
<li><a href="structs-and-unions.html#%E8%81%94%E5%90%88%E4%BD%93">联合体</a>
<ul>
<li><a href="structs-and-unions.html#%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%81%94%E5%90%88%E4%BD%93">实例化联合体</a></li>
<li><a href="structs-and-unions.html#%E8%AE%BF%E9%97%AE%E8%81%94%E5%90%88%E4%BD%93%E6%88%90%E5%91%98%E7%9A%84%E5%80%BC">访问联合体成员的值</a></li>
</ul>
</li>
<li><a href="structs-and-unions.html#%E5%85%83%E7%BB%84">元组</a>
<ul>
<li><a href="structs-and-unions.html#%E5%85%83%E7%BB%84%E7%9A%84%E8%AE%BF%E9%97%AE">元组的访问</a></li>
<li><a href="structs-and-unions.html#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%BB%84%E5%85%83%E7%B4%A0">添加元组元素</a></li>
</ul>
</li>
<li><a href="structs-and-unions.html#%E6%9E%9A%E4%B8%BE">枚举</a></li>
<li><a href="structs-and-unions.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0">数据类型的内部实现</a>
<ul>
<li><a href="structs-and-unions.html#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基本数据类型</a></li>
<li><a href="structs-and-unions.html#%E8%81%94%E5%90%88%E4%BD%93-1">联合体</a></li>
<li><a href="structs-and-unions.html#%E6%9E%9A%E4%B8%BE-1">枚举</a></li>
<li><a href="structs-and-unions.html#%E5%80%BC%E7%9A%84%E5%A4%8D%E5%88%B6">值的复制</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->
<p>结构体和联合体是用户自定义数据类型。</p>
<p>XiaoXuan 各种数据类型之间没有继承关系。</p>
<h2 id="结构体-1"><a class="header" href="#结构体-1">结构体</a></h2>
<p>结构体的作用是将一堆相关的数据打包成为一个整体。结构体由基本数据类型，比如整数、字符串、逻辑等组成，当然结构体也能嵌套其他结构体和联合体。结构体的定义语法如下：</p>
<pre><code class="language-js">结构体 名称
    数据类型1 成员名称1
    数据类型2 成员名称2
    ...
以上
</code></pre>
<pre><code class="language-js">struct Name
    DataType1 memberName1
    DataType2 memberName2
    ...
end
</code></pre>
<p>结构体的定义也可以写成一行的形式，只需把所有成员（member）用括号包围起来，然后使用逗号分隔各个成员即可，语法如下。</p>
<pre><code class="language-js">结构体 名称(数据类型1 成员名称1, 数据类型2 成员名称2, ...)
</code></pre>
<pre><code class="language-js">struct Name(DataType1 memberName1, DataType2 memberName2, ...)
</code></pre>
<p>示例：</p>
<pre><code class="language-js">结构体 用户
    整数 id
    字符串 name
    逻辑 checked
以上

结构体 登录(用户 user, 时间 time)
</code></pre>
<pre><code class="language-js">struct User
    Int id
    String name
    Boolean checked
end

struct Login(User user, Time time)
</code></pre>
<blockquote>
<p>结构体的成员是有区分顺序的，即使成员的名称和类型相同，只要顺序不同，则结构体也不同。比如 <code>struct User(Int id, String name)</code> 跟 <code>struct User(String name, Int id)</code> 是不同的结构体，所以当重构代码时，如果调整了成员的顺序，则需要保证所有使用到该结构体的模块都要重新编译。</p>
</blockquote>
<blockquote>
<p>结构体成员的数据类型只能是基本的数据类型、结构体、枚举、联合体等，不能是函数（函数签名）、特性、接口等。</p>
</blockquote>
<h3 id="实例化结构体"><a class="header" href="#实例化结构体">实例化结构体</a></h3>
<p>:: TODO 尚未决定</p>
<p>运行环境会自动为每一个结构体创建一个默认构造函数，函数的参数为全部成员。使用 <code>新建</code>（<code>new</code>） 关键字可以调用此构造函数以创建结构体的实例。</p>
<p>示例：</p>
<pre><code class="language-js"># 使用 new 关键字
让 u1 = 新建 用户 (100, &quot;张三&quot;, true)
让 u2 = 新建 用户 (id=101, name=&quot;李四&quot;, checked=false)

# 原始函数调用
让 u1 = 用户::新建 (100, &quot;张三&quot;, true)
让 u2 = 用户::新建 (id=101, name=&quot;李四&quot;, checked=false)

# 使用符号
让 u1 = 用户!(100, &quot;张三&quot;, true)
让 u1 = 用户!(101, &quot;李四&quot;, false)

# 使用符号 # 方案 2
让 u1 = 用户{100, &quot;张三&quot;, true}
让 u1 = 用户{id: 101, name: &quot;李四&quot;, checked: false}
</code></pre>
<pre><code class="language-js">let u1 = new User (100, &quot;foo&quot;, true)
let u2 = new User (id = 101, name = &quot;bar&quot;, checked = false)

let u1 = User::new (100, &quot;foo&quot;, true)
let u2 = User::new (id = 101, name = &quot;bar&quot;, checked = false)

let u1 = User!(100, &quot;foo&quot;, true)
let u1 = User{id: 101, name: &quot;bar&quot;, checked: false}
</code></pre>
<p>跟普通函数一样，构造函数也可以按参数名称调用。</p>
<p>示例：</p>
<pre><code class="language-js">让 u1 = new 用户 (id=100, name=&quot;张三&quot;, checked=true)
</code></pre>
<p>需注意的是，混合按参数顺序和按参数名称调用时，必须先写完所有按顺序传参的值，才可以开始写按名称传参的值。</p>
<h3 id="访问结构体成员的值"><a class="header" href="#访问结构体成员的值">访问结构体成员的值</a></h3>
<p>使用 &quot;实例名称 + . + 成员名称&quot; 的格式可以访问结构体各个成员的值。</p>
<p>示例：</p>
<pre><code class="language-js">让 编号 = u1.id
让 姓名 = u1.name
</code></pre>
<pre><code class="language-js">let id = u1.id
let name = u1.name
</code></pre>
<h3 id="更新成员的值"><a class="header" href="#更新成员的值">更新成员的值</a></h3>
<p>因为 XiaoXuan 的值不可变性，所以没法直接为结构体的成员赋予新值，比如 <code>u1.name = &quot;John&quot;</code> 这语句是语法错误的，如果需要更新成员的值，只能新建一个结构体实例，然后把原结构体实例需要保留的值一一复制过来，示例：</p>
<pre><code class="language-js">让 u3 = 用户(u1.id, &quot;王五&quot;, u1.checked)
</code></pre>
<pre><code class="language-js">let u3 = User(u1.id, &quot;John&quot;, u1.checked)
</code></pre>
<p>上面的代码的作用相当于将 <code>u1</code> 的 <code>name</code> 成员的值更新，然后将新实例存储到变量 <code>u3</code>。</p>
<p>XiaoXuan 支持一种简化的更新结构体成员（即复制其他实例成员的值）的语法，调用构造函数时，使用按参数名称方式传入成员的新值，并使用 &quot;...&quot; 符号（即三个点）复制原实例成员的值。</p>
<p>示例：</p>
<pre><code class="language-js">让 u3 = 用户(name=&quot;王五&quot;, ...u1)
让 u4 = 用户(name=&quot;赵六&quot;, checked=false, ...u1)
</code></pre>
<pre><code class="language-js">let u3 = User(name=&quot;John&quot;, ...u1)
let u4 = User(name=&quot;Smith&quot;, checked=false, ...u1)
</code></pre>
<h3 id="数据验证约束"><a class="header" href="#数据验证约束">数据验证约束</a></h3>
<p>有时一个结构体的成员的值有一定的使用限制，比如表示有理数的结构体的分母不能为 0 等。可以在定义结构体时添加 <code>@验证</code>（<code>@validate</code>）标注用于约束成员的值。示例：</p>
<pre><code class="language-js">@验证(id &gt; 0 :并且 name != &quot;&quot;)
结构体 用户
    整数 id
    字符串 name
    逻辑 checked
以上
</code></pre>
<pre><code class="language-js">@validate(id &gt; 0 :and name != &quot;&quot;)
struct User
    Int id
    String name
    Boolean checked
end
</code></pre>
<p>标注 <code>@验证</code> 的内容是一个能返回逻辑值的表达式，该表达式会被运行环境自动置入默认构造函数当中，在构造结构体实例时，如果该表达式返回 <code>假</code>，则会引起运行时异常，即实例构造失败。</p>
<p>一个结构体可以有多个 <code>@验证</code> 标注，只要任何一个验证表达式返回 <code>假</code>，都会导致实例构造失败。</p>
<p>标注 <code>@验证</code> 也可以标在结构体的成员之上，示例：</p>
<pre><code class="language-js">结构体 用户
    @验证(id &gt; 0)
    整数 id

    @验证(name != &quot;&quot;)
    字符串 name

    逻辑 checked
以上
</code></pre>
<p>当标注 <code>@验证</code> 标在成员之上时，只能单独验证该成员的值。</p>
<h3 id="自定义构造函数"><a class="header" href="#自定义构造函数">自定义构造函数</a></h3>
<p>运行环境会自动为结构体创建一个默认构造函数，函数的参数为全部成员。可以为结构体添加一个或多个 <code>新建</code>（<code>new</code>）方法，只要这些方法的参数列表跟默认构造函数不同，且返回值为该结构体，则它们都会自动称为构造函数。当程序使用 <code>新建</code>（<code>new</code>）关键字实例化结构体时，会根据参数情况自动选择适当的构造函数。</p>
<p>示例：</p>
<pre><code class="language-js">实现 用户
    函数 新建 (整数 id, 字符串 name) = 新建 用户(id, name, true)
    函数 新建 (整数 id) = 用户(id, &quot;张三&quot;)
以上
</code></pre>
<pre><code class="language-js">implement User
    function new (Int id, String name) = new User (id, name, true)
    function new (Int id) = User(id, &quot;张三&quot;)
end
</code></pre>
<p>上面定义了两个自定义构造函数。其中第一个允许用户省略 <code>checked</code> 参数，函数的主体为调用默认的构造函数。第二个构造函数则允许用户省略 <code>name</code> 和 <code>checked</code> 参数。</p>
<p>通过自定义构造函数，我们可以简化某些复杂的结构体的实例化过程。</p>
<p>需要注意的是，默认构造函数是无法覆盖的，即我们无法添加一个签名跟默认构造函数一样的函数。即运行环境会自动为每个结构体生成类似下面的函数：</p>
<pre><code class="language-js">实现 用户
    函数 新建 (整数 id, 字符串 name, 逻辑 checked)
        ...
    以上
以上
</code></pre>
<p>该函数会调用运行环境提供的内置方法以创建结构体实例。从中也可以看出，创建实例除了使用 <code>创建</code>（<code>new</code>） 关键字，其实也可以直接调用结构体的 <code>创建</code>（<code>new</code>）函数。示例：</p>
<ul>
<li>让 u1 = 用户.创建 (123, &quot;foo&quot;, true)</li>
<li>let u1 = User.new (123, &quot;foo&quot;, true)</li>
</ul>
<h3 id="匿名成员结构体"><a class="header" href="#匿名成员结构体">匿名成员结构体</a></h3>
<h3 id="无成员结构体"><a class="header" href="#无成员结构体">无成员结构体</a></h3>
<h2 id="联合体"><a class="header" href="#联合体">联合体</a></h2>
<p>联合体由一个或多个成员组成，每一个成员可以是一个结构体、一个元组、一个常量。</p>
<p>虽然联合体可以有多个成员，但一个联合体实例的值只能是其中一个成员的值。</p>
<p>需注意的是，联合体成员的定义必须在现场定义，而不能使用外部已定义的（比如不能使用外部定义的结构体）。联合体的定义语法是：</p>
<pre><code class="language-js">01  联合体 名称
02      成员名称1 (数据类型1 成员名称1, 数据类型2 成员名称2, ...)
03      成员名称2 (数据类型1, 数据类型2, ...) // ::TODO 考虑不支持无成员名称的成员
04      成员名称3
05      ...
06  以上
</code></pre>
<pre><code class="language-js">01  Union Name
02      MemberName1 (DataType1 memberName1, DataType2 memberName2, ...)
03      MemberName2 (DataType1, DataType2, ...) // ::TODO removed?
04      MemberName3
05      ...
06  end
</code></pre>
<p>上面语句的 02 行定义了一个结构体类型的成员，03 行定义了一个元组类型的成员（::TODO 考虑不支持无成员名称的成员），04 行定义了一个常量，需注意的是这个常量并不需要指定其数值，这点跟其他面向对象语言当中的 &quot;枚举&quot; 类型有些类似。</p>
<p>示例：</p>
<pre><code class="language-js">联合体 作品
    书籍(字符串 title, 字符串 isbn)
    专辑(字符串 title, 字符串 artist)
以上
</code></pre>
<pre><code class="language-js">union Work
    Book(String title, String isbn)
    Album(String title, String artist)
end
</code></pre>
<blockquote>
<p>联合体的成员是有区分顺序的，即使成员的名称和类型相同，只要顺序不同，则联合体也不同。比如 <code>union One(...) Two(...)</code> 跟 <code>union Two(...) One(...)</code> 是不同的联合体，所以当重构代码时，如果调整了成员的顺序，则需要保证所有使用到该联合体的模块都要重新编译。</p>
</blockquote>
<h3 id="实例化联合体"><a class="header" href="#实例化联合体">实例化联合体</a></h3>
<p>联合体的结构体类型和元组类型的成员的实例化跟正常的结构体和元组的实例化方法一样，至于常量，则不需实例化，直接当成常量使用即可。</p>
<p>示例：</p>
<pre><code class="language-js">让 作品1 = 作品::书籍(&quot;从地球到月球&quot;, &quot;123456&quot;)
让 作品2 = 作品::专辑(&quot;Fly Me to the Moon&quot;, &quot;foobar&quot;)
</code></pre>
<pre><code class="language-js">let work1 = Work::Book(&quot;从地球到月球&quot;, &quot;123456&quot;)
let work2 = Work::Album(&quot;Fly Me to the Moon&quot;, &quot;foobar&quot;)
</code></pre>
<h3 id="访问联合体成员的值"><a class="header" href="#访问联合体成员的值">访问联合体成员的值</a></h3>
<p>因为联合体实例只能存储其中一个成员的值，所以首先需要确定它的值是哪个成员，然后再读取其成员的值。XiaoXuan 只支持通过模式匹配来完成这个任务。示例：</p>
<pre><code class="language-js">匹配 作品1
    情况 书籍(title, isbn):
        ...
    情况 专辑(title, artist):
        ...
以上
</code></pre>
<pre><code class="language-js">match work1
    case Book(title, isbn):
        ...
    case Album(title, artist):
        ...
end
</code></pre>
<p>如果有时只对其中一个成员的值感兴趣，也可以使用简化版的 <code>匹配</code> 语句 ———— <code>如果 让</code> 语句来完成，示例：</p>
<pre><code class="language-js">如果 让 书籍(title, isbn) 匹配 作品1 那么
    ...
以上
</code></pre>
<pre><code class="language-js">if let Book(title, isbn) match work1 then
    ...
end
</code></pre>
<h3 id="内置的联合体"><a class="header" href="#内置的联合体">内置的联合体</a></h3>
<ul>
<li>Option<T></li>
<li>Result&lt;T, E&gt;</li>
<li>Either&lt;T, U&gt;</li>
</ul>
<h2 id="元组-1"><a class="header" href="#元组-1">元组</a></h2>
<p><code>元组</code>（<code>Tuple</code>）<!-- 考虑取消这个特性  是 XiaoXuan 函数传参的底层原理，也就是说，传一组参数给一个函数，实际上是传了一个由一个或多个数值组成的元组给函数。一个函数有且只有一个参数和一个返回值。 --></p>
<p>元组一般用于函数需要返回多个数值（却又不想单独创建一个专门的结构体）的情况，即使用元组把多个值包装成一个值然后返回。</p>
<p>一个元组可以视为一个 <strong>匿名成员的结构体</strong>，即它由固定数量、顺序、数据类型的一个或多个成员组成。注意跟其他语言的元组不同，XiaoXuan 的元组并不是一种集合。</p>
<p>元组的字面量的格式是：使用一对括号包围所有数据，数据之间使用逗号分隔。</p>
<p>示例：</p>
<pre><code class="language-js">(1, 2, 3)
(1, &quot;hello&quot;, true, 3.14)
</code></pre>
<p>如果元组成员是表达式的返回值，则可以分行写，示例：</p>
<pre><code class="language-js">(&quot;hello world&quot;,
1+2*3,
someFunction(1,2),
)
</code></pre>
<p>元组最后一个成员后面可以添加逗号，也可以不添加。有些人习惯添加上逗号是为了让每一行看起来格式一致，同时当以后需要增加或者删除成员时，使用版本管理软件的比较（Diff）源码时，更加能准确被修改的行。</p>
<p>元组的数据类型为元组各个成员的数据类型的组合，比如上面两个元组的数据类型分别是：</p>
<ul>
<li><code>(整数, 整数, 整数)</code></li>
<li><code>(整数, 字符串, 逻辑, 浮点数)</code></li>
</ul>
<p>需注意，列表要求所有元素的数据类型必须相同，而元组的每个成员的数据类型都可以不同。</p>
<blockquote>
<p>元组无法使用函数构建。</p>
</blockquote>
<p>为了一致性，也存在单独一个成员的元组，其字面量是在第一个数值后面加上一个逗号。</p>
<p>示例：</p>
<ul>
<li><code>(456, )</code></li>
<li><code>(&quot;foo&quot;, )</code></li>
</ul>
<p>上面两个元组的数据类型分别是 <code>(整数)</code> 和 <code>(字符串)</code>。但作为函数的参数整体时，并不需要在后面加一个逗号，比如 <code>let a = sqrt(36)</code>，解析器会自动把 <code>(36)</code> 解析为元组。但在其他场合，这对括号仅仅被解析为 &quot;语句块&quot;，然后被求值，最后得一个整数 <code>36</code>。</p>
<p>对于一个里面仅有一个数值（且没有逗号）的一对括号：</p>
<ul>
<li>如果写在函数的后面，它会被解析为元组。</li>
<li>写在其他地方会被解析为语句块。</li>
</ul>
<!--
::TODO 考虑取消

另外还有空元组 `()`，它是 `Unit::Empty` 值的字面量。它用在几种场合：

* 调用一个无参数的函数，比如 `doSomething()`
* 当一个函数的参数数据类型为 `Unit` 时，可以传入 `Unit::Empty`，也可以传入 `()`，比如 `Result::Ok(())`；
* 当一个函数的返回值类型为 `Unit` 时，返回语句可以写 `return Unit::Empty`，也可以写 `return ()`，甚至直接写成 `return`。
-->
<h3 id="元组的访问"><a class="header" href="#元组的访问">元组的访问</a></h3>
<p>元组跟列表和映射表不同，它的成员既不能通过位置/索引来访问，也没法通过成员名称来访问，一般使用模式匹配或者模式解构来访问。</p>
<p>示例，假设现有元组 <code>a</code>，其值为：</p>
<p><code>让 a = (123, &quot;hello&quot;, true)</code></p>
<p>可以使用如下语句获取它的三个成员的值：</p>
<p><code>让 (a,b,c) = a</code></p>
<p>三个变量 <code>a</code>, <code>b</code>, <code>c</code> 的值分别为 123, &quot;hello&quot; 和 true。</p>
<p>除了模式匹配和模式解构，还可以通过 <!-- 运行环境自动为元组生成的成员名称来访问，成员名称的分别为 "_1"，"_2" 如此类推，即一个下划线加上成员的次序，-->
<code>获取成员</code>（<code>getMember</code>）函数获取成员的值，向函数传入成员的次序即可读取相应的成员值，次序从数字 1 开始（而不是从 0 开始）。</p>
<p>示例：</p>
<pre><code class="language-js">让 a = (123, &quot;hello&quot;, true)

让 m1 = a.获取成员(1) # 123
让 m2 = a.获取成员(2) # &quot;hello&quot;
让 m3 = a.获取成员(3) # true
</code></pre>
<p>使用 <code>成员个数</code>（<code>memberCount</code>） 函数可以获取成员的个数。</p>
<p>示例：</p>
<pre><code class="language-js">让 c = a.成员个数() # 3
</code></pre>
<!-- 考虑去除此特性
需注意的是，在构造元组实例时，运行环境支持为成员值附带上名称。比如在调用函数时，可以按参数位置传参，也可以按参数名称传参，或者混合两种传参方式。但成员的名称仅仅用于构造元组实例，只是成员的一个附加的数据，XiaoXuan 没提供获取成员名称的方法，也没提供按元组成员名称访问成员的方法。

示例：

```js
让 a = (1, 2, 3, 名称 = "hello", 形状 = "circle")

让 m4 = a.获取成员(4) # "hello"
让 m5 = a.获取成员(5) # "circle"
```

元组成员大致相当于如下的联合体：

```js
union TupleMember<T>
    Value(Int index, T v)
    ValueWithName(Int index, String name, T v)
end
```
-->
<h3 id="添加元组元素"><a class="header" href="#添加元组元素">添加元组元素</a></h3>
<!-- 考虑取消此特性 -->
<p>元组常用的只有构造和读取两种操作，一般很少需要修改元组的数据，不过<!-- XiaoXuan 还是提供了添加新成员到一个元组的头部的方法，用于构造一个新元组。--> 可以通过是使用一对圆括号和 &quot;...&quot; 符号（三个点号）的方法向元组头部添加成员。</p>
<!--
示例：

```js
让 a = (1, 2, 3)
让 b1 = (99, ...a)
让 b2 = (77, "foo", true, ...a)

# b1 == (99, 1, 2, 3)
# b2 == (77, "foo", true, 1, 2, 3)
```

这种语法对应的函数是 `元组::添加`（`Tuple::add`），它是一个系统函数，有且只有一个参数，可以接受任意类型的值，另外还有 `元组::追加`（`Tuple::append`） 系统函数用于向元组末尾添加成员。 -->
<h2 id="枚举-1"><a class="header" href="#枚举-1">枚举</a></h2>
<p>枚举跟全局常量相类似，不过枚举有以下几个特点：</p>
<ul>
<li>枚举的成员数量固定；</li>
<li>枚举的成员的值无需指定，运行环境内部按照枚举成员的定义顺序自动分配从 <code>整数</code> 数值 <code>0</code> 开始分配数值；</li>
<li>枚举是一种数据类型；</li>
<li>枚举的值无法直接跟其他数据类型转换，也就是说无法从枚举值转为 <code>整数</code>，也无法直接从 <code>整数</code> 转成枚举值。</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">枚举 原色
    红
    绿
    蓝
以上

让 a = 原色.蓝
</code></pre>
<pre><code class="language-js">enum PrimaryColor
    Red
    Green
    Blue
end

let a = PrimaryColor.Blue
</code></pre>
<p>因为枚举是数据类型，所以枚举可以用在函数的参数上，用于某个参数只能从有限的几种值当中取其一的这种场合。示例：</p>
<pre><code class="language-js">函数 设置背景色 (原色 c)
    书写行 (c)
以上

# 调用函数
设置背景色 (原色.红)
</code></pre>
<pre><code class="language-js">function setBackgroundColor (PrimaryColor c)
    writeLine (c)
end

# call function
setBackgroundColor (PrimaryColor.Red)
</code></pre>
<p>注意枚举值<strong>不能</strong>与其他数据类型的值相互转换，比如无法将整数转为上例中的 <code>原色</code> 的值（也无法将枚举的值转成整数）。</p>
<p>例如下面的语句是错误的：</p>
<pre><code class="language-js">设置背景色 (1)
</code></pre>
<pre><code class="language-js">setBackgroundColor (1)
</code></pre>
<blockquote>
<p>枚举的成员是有区分顺序的，即使成员的名称相同，只要顺序不同，则枚举也不同。比如 <code>enum Red Blue</code> 跟 <code>enum Blue Red</code> 是不同的枚举，所以当重构代码时，如果调整了成员的顺序，则需要保证所有使用到该枚举的模块都要重新编译。</p>
</blockquote>
<!-- 考虑移除

可以使用 @enumValue 标注指定枚举成员的具体值，不过一般没必要这样做，因为语言不提供读取成员内部值（一个整数）的方法。另外编译器不检查指定的成员值是否有重复，所以需要用户确保成员值是正确的。

这个标注的作用是当一个枚举数据类型需要（通过 API 或者序列化）跟外部程序或者本地库（比如 C/C++/Rust 等语言所生成的库）进行内存级别的运算时才有实际意义。比如基本数据类型 `逻辑`（`Boolean`）的定义如下：

```js
enum Boolean
    @enumValue(0)
    False

    @enumValue(1)
    True
end
```
-->
<h2 id="类型的内部实现"><a class="header" href="#类型的内部实现">类型的内部实现</a></h2>
<p>XiaoXuan 的类型系统包括数据类型（简称类型）、函数类型（也叫做函数签名）两种。</p>
<p>注意数据类型的检查位于编译阶段，在 IR 层面及在运行过程中均不作数据类型检查。也就是说 XiaoXuan 是静态数据类型编译型语言。</p>
<h3 id="数据类型-2"><a class="header" href="#数据类型-2">数据类型</a></h3>
<p>在运行环境内部，所有数据类型（包括结构体、联合体、元组、枚举）本质上都是结构体，程序使用到的所有结构体都会登记在一个 <code>数据类型记录表</code> 里。这个记录表是一个有序表，一般有以下几个部分组成：</p>
<ol>
<li>成员表。成员表是一个有序数组，可以使用下标访问成员。
数据的每一个元素由两个数据组成：
<ul>
<li>数据类型编号。</li>
<li>成员名称</li>
</ul>
</li>
</ol>
<p>成员表的第一条记录（即编号 0）是一个空数组。</p>
<ol start="2">
<li>信息表
<ul>
<li>members 成员表编号。如果当前数据类型没有成员（即空结构体）或者是虚拟机基本数据类型，则该字段值为 0。</li>
<li>category 数据类型的类别，可能的值有：
<ul>
<li>结构体，即一般结构体</li>
<li>联合体结构体</li>
<li>联合体成员结构体</li>
<li>枚举结构体</li>
<li>元组</li>
<li>基本数据类型</li>
</ul>
</li>
<li>name 数据类型名称，比如 &quot;Int64&quot;，注意一个数据类型可以定义别名，所以存在多个类型指向同一个成员表的情况；</li>
<li>namePath 所在的名称空间，比如 &quot;core&quot;；</li>
<li>fullName 包括命名空间路径和名称的全称，比如 &quot;core::Int64&quot;；</li>
<li>parent 联合体结构体指针。仅当当前类型为联合体成员结构体时这个字段值才有意义，除此之外该字段值为 0。</li>
</ul>
</li>
</ol>
<p>信息表的第一条记录（即编号 0）是一个空元组。</p>
<p>可以使用宏 typeOf(...) 获取一个数据类型的详细信息，宏返回一个 <code>Type</code> 结构体，该结构体的定义如下：</p>
<pre><code class="language-js">struct Type
    // Option&lt;Array&lt;Member&gt;&gt; members
    TypeCategory typeCategory
    String name
    String namePath
    // String fullName
    Option&lt;Type&gt; parent
end

enum TypeCategory
    Struct
    Union
    UnionMember
    Enum
    Tuple
    Primitive
end
</code></pre>
<p>可以通过 <code>Type::getMembers</code> 方法获取类型的成员列表。</p>
<pre><code class="language-js">struct Member
    Type type
    String name
end
</code></pre>
<h4 id="基本数据类型的实现"><a class="header" href="#基本数据类型的实现">基本数据类型的实现</a></h4>
<p>XiaoXuan 的基本数据类型（比如整数、实数）在标准库里定义为结构体，所以在运行环境内部的 <code>数据类型记录表</code> 里也有其相关记录。</p>
<p>下面是标准库里对于 <code>Int32</code> 类型的定义：</p>
<pre><code class="language-js">@compileTypeCategory(TypeCategory::Primitive)
@compileTypeNative(type=&quot;i32&quot;) // 编译指令，用户不可使用
struct Int32
    // empty
end
</code></pre>
<p>上面的 <code>@compileTypeNative</code> 标记用于告诉编译器，当一个基本数据类型的变量在编译成 IR 时会被解析为虚拟机基本数据类型，其类型信息将会被丢弃。也就是说对于基本数据类型的变量值，在运算过程中其值是存储在寄存器即栈当中，当遇到 <code>typeOf</code> 一个基本数据类型时，编译器实际上会把它翻译成一个内部的函数 <code>typeByNumber</code> 直接从类型记录表里读取类型信息。</p>
<h4 id="一般结构体的实例的实现"><a class="header" href="#一般结构体的实例的实现">一般结构体的实例的实现</a></h4>
<p>一个结构体变量储存的是一个指向该结构体数据（一个内部结构体）的指针，该内部结构体的信息如下：</p>
<ul>
<li>type
数据类型编号，也就是目标数据类型在 <code>数据类型记录表</code> 的索引值；</li>
<li>value_ref
<ul>
<li>当数据类型是虚拟机基本数组类型时，该值是一个指向实际值的指针。</li>
<li>当数据类型是一个结构体时，该值是一个指向结构体各成员情况的指针。</li>
</ul>
</li>
</ul>
<p>结构体成员是一个数组，数组的每个成员跟上面结构体一样，该数组如下：</p>
<p>[{type, value_ref}, {type, value_ref}, ...]</p>
<blockquote>
<p>跟一个基本数据类型的变量的情况不同，如果一个结构体的成员是基本数据类型，其值也是保存在堆（heap）里。</p>
</blockquote>
<h4 id="联合体的实现"><a class="header" href="#联合体的实现">联合体的实现</a></h4>
<p>联合体使用两次结构体实现，即联合体本身会被解析为一个结构体</p>
<p>假设有如下一个联合体：</p>
<pre><code class="language-js">union Option
    Some(Int value)
    None
end
</code></pre>
<p>编译器会自动生成如下结构体及其常量值：</p>
<pre><code class="language-js">namespace std
    @compileTypeCategory(TypeCategory::Union)
    @derive(std::trait::Union)
    struct Option
        WordWidth memberNumber
        WordWidth memberAddr
    end

    namespace Option
        // 构造结构体型成员
        function Parent::Option new(WordWidth memberNumber, WordWidth memberAddr)
            // native
        end

        // 构造常量型成员
        function Parent::Option new(WordWidth memberNumber)
            // native
        end

        @compileTypeCategory(TypeCategory::UnionMember)
        @compileTypeParent(&quot;std::Option&quot;)
        @compileMemberNumber(0)
        struct Some
            Int value
        end

        // 构造成员 None
        @compileTypeCategory(TypeCategory::UnionMember)
        @compileTypeParent(&quot;std::Option&quot;)
        @compileMemberNumber(1)
        const None = new(1)

        // 构造成员 Some
        function Parent::Option Some(Int value)
            let some = Current::Some::new(value)
            let addr = Pointer(some)
            new(0, addr)
        end

        function equal(Parent::Option left, Parent::Option right)
            // 自动生成
            // 先比较 memberNumber
            // memberNumber 相同时再逐个 member 比较，伪代码如下：
            // if left.memberNumber == right.memberNumber then
            //      switch left.memberNumber
            //          case 0:
            //              Current::Some::equal(*left.memberAddress, *right.memberAddress)
            //          case 1:
            //              1
            //      end
            // else
            //      false
            // end

        end

        namespace Some
            // 构造成员 Some 的实际函数
            function Parent::Some new(Int value)
                // native
            end

            function equal(Parent::Some left, Parent::Some right)
                // 自动生成
            end
        end
    end
end
</code></pre>
<h4 id="枚举的实现"><a class="header" href="#枚举的实现">枚举的实现</a></h4>
<p>枚举也是使用结构体实现。</p>
<p>假设有如下一个枚举：</p>
<pre><code class="language-js">enum Color
    Red
    Green
    Blue
end
</code></pre>
<p>编译器会自动生成如下结构体及其常量值：</p>
<pre><code class="language-js">@compileTypeCategory(TypeCategory::Enum)
@derive(std::trait::Enum)
struct Color
    Int Value
end

namespace Color
    const Color Red = Color::new(0)
    const Color Green = Color::new(1)
    const Color Blue = Color::new(2)
end
</code></pre>
<h4 id="元组的实现"><a class="header" href="#元组的实现">元组的实现</a></h4>
<p>::TODO</p>
<h3 id="值的复制"><a class="header" href="#值的复制">值的复制</a></h3>
<p>XiaoXuan 默认使用数据的引用计数来实现资源/垃圾回收。变量是一个指向存放在堆中的数据的指针，当将一个变量赋值给另外一个变量，以及作为参数传递给一个函数时，该变量所指向的数据的引用数便增加一个；当变量离开其作用范围时引用数则减少一个。当数据的引用数减少到 0 时，运行时就会回收这个数据资源。</p>
<p>但有些数据类型是不使用引用计数来管理的，这些数据直接在栈里参与计算，如果被赋值给另外一个变量，则直接复制一份。这些数据类型有：</p>
<ul>
<li>基本数据类型：整数、自然数、实数、逻辑、字符；</li>
<li>枚举</li>
</ul>
<p>它们具有 <code>复制</code> 特性。</p>
<h3 id="函数签名"><a class="header" href="#函数签名">函数签名</a></h3>
<p>::TODO</p>
<p>函数的签名由返回值（一个数据类型）和一个参数列表（一个元组数据类型）组成，函数的名称、各参数的名称都不属于函数签名的一部分，函数签名本身也是一种数据类型，也会登记在运行环境的 <code>数据类型记录表</code> 里，函数签名的第一个成员是返回值的数据类型，第二个成员是参数列表（元组数据类型）。</p>
<blockquote>
<p>函数的泛型、参数默认值（可选参数）、模式表达式等信息，在翻译成 IR 时已经会被丢弃（源码与 IR 码的映射信息存储在其他地方，不在 IR 代码里）。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="流程控制"><a class="header" href="#流程控制">流程控制</a></h1>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="control-flow.html#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">流程控制</a>
<ul>
<li><a href="control-flow.html#%E8%AF%AD%E5%8F%A5%E5%9D%97">语句块</a>
<ul>
<li><a href="control-flow.html#%E4%BD%BF%E7%94%A8%E6%8B%AC%E5%8F%B7%E8%A1%A8%E7%A4%BA%E8%AF%AD%E5%8F%A5%E5%9D%97">使用括号表示语句块</a></li>
</ul>
</li>
<li><a href="control-flow.html#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">条件语句</a>
<ul>
<li><a href="control-flow.html#%E5%A6%82%E6%9E%9C-%E8%AF%AD%E5%8F%A5"><code>如果</code> 语句</a>
<ul>
<li><a href="control-flow.html#%E5%A4%9A%E8%A1%8C%E6%A0%BC%E5%BC%8F">多行格式</a></li>
<li><a href="control-flow.html#%E7%9C%81%E7%95%A5-else-%E8%AF%AD%E5%8F%A5">省略 <code>else</code> 语句</a></li>
<li><a href="control-flow.html#%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E7%BB%84%E5%90%88">多个条件语句组合</a></li>
<li><a href="control-flow.html#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BD%93%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">条件表达当中的局部变量</a></li>
</ul>
</li>
<li><a href="control-flow.html#%E6%9D%A1%E4%BB%B6-%E8%AF%AD%E5%8F%A5"><code>条件</code> 语句</a>
<ul>
<li><a href="control-flow.html#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%87%8C%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%A7%BB%E5%8A%A8">条件表达式里的模式匹配(::移动)</a></li>
<li><a href="control-flow.html#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%B1%80%E9%83%A8%E8%AF%AD%E5%8F%A5">条件语句的局部语句</a></li>
</ul>
</li>
<li><a href="control-flow.html#%E9%80%89%E6%8B%A9-%E8%AF%AD%E5%8F%A5%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%9B%BF%E4%BB%A3"><code>选择</code> 语句（::不支持，使用模式匹配替代）</a></li>
</ul>
</li>
<li><a href="control-flow.html#%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%92%8C%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5">语句块和跳转语句</a></li>
<li><a href="control-flow.html#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">循环语句</a>
<ul>
<li><a href="control-flow.html#%E8%AE%BE%E6%9C%89-%E8%AE%A9-%E8%AF%AD%E5%8F%A5">&quot;设有 让&quot; 语句</a>
<ul>
<li><a href="control-flow.html#%E8%AE%BE%E6%9C%89-%E8%AE%A9-%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><code>设有 让</code> 的返回值</a></li>
</ul>
</li>
<li><a href="control-flow.html#%E8%AE%BE%E6%9C%89-%E5%8F%96%E8%87%AA-%E8%AF%AD%E5%8F%A5">&quot;设有 取自&quot; 语句</a>
<ul>
<li><a href="control-flow.html#%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6">设置过滤条件</a></li>
<li><a href="control-flow.html#%E7%BB%84%E5%90%88%E9%81%8D%E5%8E%86%E5%A4%9A%E4%B8%AA%E5%BA%8F%E5%88%97">组合遍历多个序列</a></li>
</ul>
</li>
<li><a href="control-flow.html#%E6%8C%87%E5%AE%9A%E6%AC%A1%E6%95%B0%E5%BE%AA%E7%8E%AFtodo-%E5%88%A0%E9%99%A4">指定次数循环(::TODO 删除)</a></li>
<li><a href="control-flow.html#%E6%98%A0%E5%B0%84%E8%AF%AD%E5%8F%A5">映射语句</a>
<ul>
<li><a href="control-flow.html#%E6%98%A0%E5%B0%84%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%9D%A1%E4%BB%B6">映射时设置条件</a></li>
<li><a href="control-flow.html#%E7%BB%84%E5%90%88%E6%98%A0%E5%B0%84%E5%A4%9A%E4%B8%AA%E5%BA%8F%E5%88%97">组合映射多个序列</a></li>
</ul>
</li>
<li><a href="control-flow.html#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E5%BD%93%E4%B8%AD%E5%B8%A6%E6%9C%89%E5%BE%AA%E7%8E%AF%E6%80%A7%E8%B4%A8%E7%9A%84%E6%96%B9%E6%B3%95">序列类型当中带有循环性质的方法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->
<h2 id="语句块"><a class="header" href="#语句块">语句块</a></h2>
<p>使用 <code>开始...以上</code>（<code>begin...end</code>） 包围起来的一条或多条语句被称之为语句块，一般语句块被用于：</p>
<ol>
<li>将一段语句打包起来作为一个整体，要么整体被执行，要么整体不执行。下面章节提到的条件语句、循环语句的各个组成部分其实都隐含者语句块。</li>
<li>有时候某些结构只允许一行语句，但想写上多行语句，则可以使用语句块把它们打包起来。</li>
<li>用于限制局部变量的有效范围。</li>
</ol>
<p>语句块的最后一个语句或者表达式的值会作为语句块的返回值。</p>
<p>示例：</p>
<pre><code class="language-js">let v = begin
        let i = 123
        let j = 456
    end
</code></pre>
<p>赋值语句会返回它本身的值，所以 <code>let j = 456</code> 会返回 <code>456</code>，然后因为它是语句块的最后一句，所以语句块的值也是 <code>456</code>，最后变量 <code>v</code> 接受语句块的返回值，所以它的值也是 <code>456</code>。</p>
<p>语句块可以嵌套，而且返回值会一层一层地往外传。</p>
<p>示例：</p>
<pre><code class="language-js">let v =
    begin
        begin
            begin
                123
            end
        end
    end
</code></pre>
<p>最后变量 <code>v</code> 的值为 <code>123</code>。</p>
<h3 id="使用括号表示语句块"><a class="header" href="#使用括号表示语句块">使用括号表示语句块</a></h3>
<p>可以使用一对圆括号 &quot;(...)&quot; 表示语句块，它跟 <code>开始...以上</code> 的作用是一样的。</p>
<p>示例：</p>
<pre><code class="language-js">let v = (
        let i = 123
        let j = 456
    )
</code></pre>
<p>它的意义跟上面的第一个示例完全一样。不过括号一般用在同一行需要区分运算优先级的情况。</p>
<p>示例：</p>
<pre><code class="language-js">let v = (a + b) * c
let p = (a :or b) :and c
</code></pre>
<p>而 <code>开始...以上</code> 格式一般用于多行语句。</p>
<p>注意如果一对括号里面的表达式或者语句之间有逗号，则该对括号表示一个元组而不是一个语句块。</p>
<p>示例：</p>
<pre><code class="language-js">let v = (
    let i = 123,
    let j = 456
)
</code></pre>
<p>变量 <code>v</code> 的值将会是一个元组，其值为 <code>(123, 456)</code>。特别地，如果在括号内的末尾处有一个逗号，将会表示单独一个元素的元组。</p>
<p>示例：</p>
<pre><code class="language-js">let a = (123)
let b = (123,)
</code></pre>
<p>变量 <code>a</code> 的值是一个整数 <code>123</code>，而变量 <code>b</code> 是一个只有一个成员的元组。</p>
<h2 id="条件语句"><a class="header" href="#条件语句">条件语句</a></h2>
<h3 id="如果-语句"><a class="header" href="#如果-语句"><code>如果</code> 语句</a></h3>
<p><code>如果</code>（<code>if</code>） 条件语句的语法：</p>
<ul>
<li><code>如果 ... 那么 ... 否则 ...</code></li>
<li><code>if ... then ... else ...</code></li>
</ul>
<p>语句有 3 个表达式：</p>
<ol>
<li>第一个表达式是一个值为 <code>逻辑</code>（<code>Boolean</code>） 的条件表达式；</li>
<li>如果条件表达式的值为 true，则返回第二个表达式的值；</li>
<li>如果条件表达式的值为 false，则返回第三个表达式的值。</li>
</ol>
<p>示例：</p>
<pre><code class="language-js">让 x = 90
让 a = 如果 x &gt;= 60 那么 &quot;及格&quot; 否则 &quot;不及格&quot;
</code></pre>
<p>需要注意：</p>
<ul>
<li>条件表达式只接受逻辑类型的返回值；</li>
<li><code>那么</code> 和 <code>否则</code> 两个表达式的返回值的数据类型必须一致；</li>
<li>如果忽略条件语句的返回值（即条件语句的返回值不赋值给一个变量），则对 <code>那么</code> 和 <code>否则</code> 表达式返回值的数据类型不作要求。</li>
</ul>
<h4 id="多行格式"><a class="header" href="#多行格式">多行格式</a></h4>
<p><code>如果</code> 语句可以写成多行格式，可以在 <code>那么</code>、<code>否则</code> 后面换行，然后最后加上 <code>以上</code> 表示语句块结束。另外，在条件表达式后面也是可以换行的。下列都是合法的多行格式：</p>
<pre><code class="language-js">如果 ...
那么 ...
否则 ...
</code></pre>
<pre><code class="language-js">如果 ...
那么
    ...
否则
    ...
以上
</code></pre>
<pre><code class="language-js">如果 ... 那么
    ...
否则
    ...
以上
</code></pre>
<pre><code class="language-js">if ...
then ...
else ...
</code></pre>
<pre><code class="language-js">if ...
then
    ...
else
    ...
end
</code></pre>
<pre><code class="language-js">if ... then
    ...
else
    ...
end
</code></pre>
<h4 id="省略-else-语句"><a class="header" href="#省略-else-语句">省略 <code>else</code> 语句</a></h4>
<p>如果忽略条件语句的返回值，也可以省略 <code>else</code> 语句，示例：</p>
<pre><code class="language-js">如果 x &gt; 90 那么
    书写行 (&quot;优秀&quot;)
以上
</code></pre>
<h4 id="多个条件语句组合"><a class="header" href="#多个条件语句组合">多个条件语句组合</a></h4>
<p>在 <code>否则</code> 后面，也可以追加另一个 <code>如果</code> 语句，比如：</p>
<pre><code class="language-js">让 x = 89
如果 x &gt;= 90 那么
    书写行 (&quot;优秀&quot;)
否则 如果 x &gt;= 80 那么
    书写行 (&quot;好&quot;)
否则 如果 x &gt;= 60 那么
    书写行 (&quot;良&quot;)
否则
    书写行 (&quot;加油&quot;)
以上
</code></pre>
<pre><code class="language-js">let x = 89
if x &gt;= 90 then
    writeLine (&quot;Excellent&quot;)
else if x &gt;= 80 then
    writeLine (&quot;Good&quot;)
else if x &gt;= 60 then
    writeLine (&quot;Fair&quot;)
else
    writeLine (&quot;Poor&quot;)
end
</code></pre>
<h4 id="条件表达当中的局部变量"><a class="header" href="#条件表达当中的局部变量">条件表达当中的局部变量</a></h4>
<p>条件表达式可以允许一小段局部的语句，只需在表达式后面加上 <code>其中</code>（<code>where</code>） 关键字即可。</p>
<p>示例：</p>
<pre><code class="language-js">let x = 89
if x &gt;= 90 and isEven where
    let isEven = x % 2 == 0 then
    ...
end
</code></pre>
<p>多条局部语句可以使用逗号分隔。</p>
<h3 id="条件-语句"><a class="header" href="#条件-语句"><code>条件</code> 语句</a></h3>
<p>当有多个条件时，除了可以使用多个 <code>如果</code> 语句组合，还能使用 <code>条件</code> 语句。</p>
<p><code>条件</code> 语句的语法：</p>
<pre><code class="language-js">条件
    情况 条件表达式1: 语句1
    情况 条件表达式2: 语句2
    ...
    默认: 语句N
以上
</code></pre>
<pre><code class="language-js">condition
    case expr1: statement1
    case expr2: statement2
    ...
    default: statementN
end
</code></pre>
<p>其中最后一个 <code>默认</code> 语句是可选的。</p>
<p>跟 <code>如果</code> 语句一样，条件语句也能返回值。示例：</p>
<pre><code class="language-js">让 x = 70
让 s = 条件
    情况 x&gt;=90: &quot;优&quot;
    情况 x&gt;=80: &quot;好&quot;
    情况 x&gt;=60: &quot;良&quot;
    默认: &quot;加油&quot;
以上
</code></pre>
<pre><code class="language-js">let x = 70
let s = condition
    case x&gt;=90: &quot;Excellent&quot;
    case x&gt;=80: &quot;Good&quot;
    case x&gt;=60: &quot;Fair&quot;
    default: &quot;Poor&quot;
end
</code></pre>
<h4 id="条件表达式里的模式匹配移动"><a class="header" href="#条件表达式里的模式匹配移动">条件表达式里的模式匹配(::移动)</a></h4>
<p>条件表达式除了可以是一个返回逻辑数值的表达式，还可以是一个模式匹配表达式 <code>让...匹配</code>。</p>
<p>示例：</p>
<pre><code class="language-js">let x = (70, 80)
let s = condition
    case let (a,b) match x:
        `got two numbers, {a} and {b}`
    end
</code></pre>
<p>因为 <code>让...匹配</code> 表达式返回一个 <code>逻辑型</code>（<code>Boolean</code>） 数值，所以该表达式还可以进一步跟其他条件表达组合。</p>
<p>示例：</p>
<pre><code class="language-js">let x = (70, 80)
let s = condition
    case let (a,b) match x :and a &gt;= 60:
        `got two numbers, {a} and {b}`
    end
</code></pre>
<h4 id="条件语句的局部语句"><a class="header" href="#条件语句的局部语句">条件语句的局部语句</a></h4>
<p>有时需要在条件的 <code>情况</code>（<code>case</code>） 里使用某些计算后的值，但这些值对于条件语句之外没有用处，这时可以使用 <code>其中</code>（<code>where</code>）关键字在条件里定义及计算局部变量。示例：</p>
<pre><code class="language-js">让 x = 70
让 s = 条件
    其中 让 isEven = x `余` 2 == 0,
         让 isOdd = x `余` 2 != 0
    情况 x &gt;= 90 :并且 isEven: &quot;优.偶数&quot;
    情况 x &gt;= 90 :并且 isOdd: &quot;优.奇数&quot;
    ...
以上
</code></pre>
<pre><code class="language-js">let x = 70
let s = condition
    where let isEven = x `rem` 2 == 0,
         let isOdd = x `rem` 2 != 0
    case x &gt;= 90 :并且 isEven: &quot;Excellent.Even&quot;
    case x &gt;= 90 :并且 isOdd: &quot;Excellent.Odd&quot;
    ...
end
</code></pre>
<p><code>其中</code> 关键字后面加上一个或多个变量的声明和赋值，多个变量之间使用逗号 &quot;,&quot; 分隔，或者使用 <code>begin...end</code> 关键字包围起来。</p>
<p><code>其中</code> 关键字也可以写在 <code>情况</code> 的后面，表示其声明的变量仅仅在当前情况下使用，比如上例可以写成：</p>
<pre><code class="language-js">让 x = 70
让 s = 条件
    情况 x &gt;= 90 :并且 isEven
        其中 让 isEven = x `余` 2 == 0
        :&quot;优.偶数&quot;
    情况 x &gt;= 90 :并且 isOdd
        其中 让 isOdd = x `余` 2 != 0
        :&quot;优.奇数&quot;
    ...
以上
</code></pre>
<pre><code class="language-js">let x = 70
let s = condition
    case x &gt;= 90 :并且 isEven
        where let isEven = x `rem` 2 == 0
        : &quot;Excellent.Even&quot;
    case x &gt;= 90 :并且 isOdd
        where let isOdd = x `rem` 2 != 0
        : &quot;Excellent.Odd&quot;
    ...
end
</code></pre>
<hr />
<p>(::移动)</p>
<p>需要注意，<code>其中</code> 部分的代码在条件判断之前，所以如果某条件分支里既包含模式匹配表达式，又包含 <code>其中</code> 语句，那么条件语句里是可以使用 <code>其中</code> 语句定义的局部变量，但 <code>其中</code> 语句里不能使用模式表达式创建的变量。</p>
<p>示例：</p>
<pre><code class="language-js">条件
    情况 让 (id, name) 匹配 User :并且
        id &gt;= 100 :并且  # 没问题, 变量 `id` 来自 `让...匹配` 表达式
        isEven           # 没问题, 变量 `isEven` 来自 `其中` 语句
        其中 开始
            让 isEven = id % 2 == 0
            # 错误，变量 `id` 还不存在，因为 `其中` 语句
            # 在其他所有条件表达式之前执行。
        以上:
        ...
end
</code></pre>
<pre><code class="language-js">condition
    case let (id, name) match User :and
        id &gt;= 100 :and  # OK, the variable `id` comes from the `let...match` expression
        isEven          # OK, the variable `isEven` comes from the `where` statement
        where begin
            let isEven = id % 2 == 0
            # ERROR, becuase the variable `id` does not exist yet
            # this `where` statement is executed before all other
            # conditional expressions
        end:
        ...
end
</code></pre>
<h3 id="选择-语句不支持使用模式匹配替代"><a class="header" href="#选择-语句不支持使用模式匹配替代"><code>选择</code> 语句（::不支持，使用模式匹配替代）</a></h3>
<p>如果需要一个值与多个候选值比较，可以使用 <code>选择</code>（<code>switch</code>）语句。</p>
<p><code>选择</code> 语句的语法：</p>
<pre><code class="language-js">选择 variable
    情况 value1: ...
    情况 value2: ...
    情况 value3: ...
    默认: ...
以上
</code></pre>
<pre><code class="language-js">switch variable
    case value1: ...
    case value2: ...
    case value3: ...
    default: ...
end
</code></pre>
<p>选择语句跟条件语句不同的地方在于，选择语句仅仅让指定的变量的值跟每个情况里的字面量或者常量进行相等比较。</p>
<p><code>情况</code> 后面可以跟一个或多个字面量或者常量，只需用逗号分隔即可。</p>
<p>示例：</p>
<pre><code class="language-js">让 d = 1
选择 d
    情况 1,2,3,4,5:
        书写行(&quot;工作日&quot;)
    情况 6,7:
        书写行(&quot;假日&quot;)
以上
</code></pre>
<pre><code class="language-js">let d = 1
switch d
    case 1,2,3,4,5:
        writeLine(&quot;Working days&quot;)
    case 6,7:
        writeLine(&quot;Holiday&quot;)
end
</code></pre>
<p>跟 <code>如果</code>，<code>条件</code> 语句一样，<code>选择</code> 语句也是可以返回值的，示例：</p>
<pre><code class="language-js">让 d = 2
让 s = 选择 d
    情况 1,2,3,4,5: &quot;工作日&quot;
    情况 6,7: &quot;假日&quot;
以上
书写行(s)
</code></pre>
<pre><code class="language-js">let d = 2
let s = switch d
    case 1,2,3,4,5: &quot;Working days&quot;
    case 6,7: &quot;Holiday&quot;
end
writeLine(s)
</code></pre>
<p>跟其他编程语言的 <code>switch</code> 语句不一样，XiaoXuan 的 <code>情况</code> 后面不需要 <code>break</code> 关键字。</p>
<h2 id="语句块和跳转语句"><a class="header" href="#语句块和跳转语句">语句块和跳转语句</a></h2>
<p><code>块</code>（<code>block</code>） 和 <code>回到</code>（<code>recur</code>） 语句是一个运行环境内部使用的语句。</p>
<p><code>块</code> 语句用于包围一组语句，跟匿名函数类似，语句块允许设置一个参数并设置其初始值，但跟匿名函数不同的是语句块无法被调用，它仅仅是用于标记一组语句。</p>
<p><code>回到</code> 语句用于携带一个数值重新回到语句块的起点，语句块的参数被赋予新值，并重新执行一次。<code>回到</code> 语句后面的语句将会被忽略（也就是永远不会被执行）。</p>
<p><code>块</code> 语句和 <code>回到</code> 语句是运行环境实现循环结构的方法。</p>
<p><code>回到</code> 语句还能携带一组数值返回到所在函数的函数，这组数值将会成为函数的新参数，再执行一次函数主体。运行环境使用 <code>回到</code> 语句实现尾部调用优化，当函数体的最后一句是调用函数自身（或者该语句后面只有 <code>如果</code> 语句的 <code>以上</code> 语句），则该调用语句会被语法解析器替换成 <code>回到</code> 语句。</p>
<blockquote>
<p>在用户代码里无法使用这两个语句。</p>
</blockquote>
<p><code>开始...以上</code>（<code>begin...end</code>）语句实际上是空参数的 <code>块</code> 语句的语法糖，两者作用一样，只是 <code>开始...以上</code> 是用户代码。</p>
<h2 id="循环语句"><a class="header" href="#循环语句">循环语句</a></h2>
<h3 id="重复-让-语句"><a class="header" href="#重复-让-语句">&quot;重复 让&quot; 语句</a></h3>
<p><code>重复 让</code>（<code>for/loop let</code>）是一种循环语句。</p>
<p>类似 Java 的 &quot;for&quot; 语句，Java 的 &quot;for&quot; 语句由一个或多个变量及其初始值、一个条件表达式、让变量变化的语句以及循环主体共 4 个部分组成，一个典型的 <code>循环 让</code> 语句则由一个变量及初始值、一个条件语句和一个让循环语句再次执行的语句共 3 个部分组成。</p>
<p>示例：</p>
<pre><code class="language-js">重复 让 i = 0 如果 i &lt; 100 那么
    ...
    书写行 (i)
    ...
    循环 i+1
以上
</code></pre>
<pre><code class="language-js">for let i = 0 if i &lt; 100 then
    ...
    writeLine(i)
    ...
    recur i+1
end
</code></pre>
<p>上面语句的作用等同以下的 JavaScript 语句：</p>
<pre><code class="language-JavaScript">for(let i=0; i&lt;100; i=i+1) {
    console.log(i)
}
</code></pre>
<p>在 <code>设有 让</code> 语句当中：</p>
<ul>
<li><code>让 i = 0</code> 是循环的变量名称及初始值，<code>设有 让</code> 语句只能设置一个变量（如果需要多个同时变化的变量，可以使用一个有多个成员的元祖作为变量）；</li>
<li><code>如果 i &lt; 100 那么 ... 以上</code> 是循环的条件语句（同时也是循环的主体），如果条件表达式返回 <code>真</code> 值，则执行循环主体，否则结束循环。</li>
<li><code>重做 i+1</code> 用于赋予循环变量新值，以及跳到循环开始的位置并再次执行循环的主体。</li>
<li>如果 <code>重做</code> 语句后面还有其他语句，这些代码将会被忽略。</li>
</ul>
<p><code>设有 让</code> 语句的原理实际上是 <code>块</code> 和 <code>回到</code> 语句的语法糖。<code>设有 让</code> 语句创建了一个有一个参数的 <code>块</code> 并赋予了初始值，而 <code>重做</code> 语句则是 <code>回到</code> 语句。</p>
<p>有时循环语句也可以使用匿名函数实现，如上例的等效代码如下：</p>
<pre><code class="language-js">01  让 f = 匿名函数 (整数 i)
02      如果 i &lt; 100 那么
03          ...
04          书写行 (i)
05          ...
06          f (i+1)
07      以上
08  以上
09
10  f (0)
</code></pre>
<p>显然，<code>设有 让</code> 语句更简洁明了。</p>
<p><code>设有 让</code> 语句后面也可以换行写条件语句，上面的示例代码将第一行换行之后得：</p>
<pre><code class="language-js">设有 让 i = 0
    如果 i &lt; 100 那么
        ...
        书写行 (i)
        ...
        重做 i+1
    以上
以上
</code></pre>
<pre><code class="language-js">for let i = a
    if i &lt; 100 then
        ...
        writeLine(i)
        ...
        redo i+1
    end
end
</code></pre>
<p>可见 <code>设有 让</code> 语句是一个语句块和一个条件语句的结合体，其中的条件语句还能省略，不过一个典型的循环语句一般有这些部分：</p>
<ol>
<li><code>设有 让</code> 关键字；</li>
<li>定义变量及赋予初始值；</li>
<li>一个条件语句；</li>
<li><code>重做</code> 关键字。</li>
</ol>
<p>需注意：</p>
<ul>
<li>要在在一定的条件下停止调用 <code>重做</code> 关键字，否则会陷入死循环。</li>
<li>如果漏写了 <code>重做</code> 关键字语句，循环体仍然会被执行一次（如果条件表达式的值为 <code>真</code> 的话）；</li>
<li><code>重做</code>（<code>redo</code>）是关键字，不是函数名称，后面直接跟着变量的新值，不需要加括号（不过即使加上括号也没错）。如果变量是元组，则需要加上括号（此时括号里面有逗号，表示元组）。</li>
<li><code>设有 让</code> 循环语句不支持 <code>continue</code> 和 <code>break</code> 等关键字。只要不调用 <code>重做</code> 则相当于 <code>break</code>，至于 <code>continue</code> 语句可以使用一个大范围的 <code>如果</code> 条件语句代替。</li>
</ul>
<p>下面演示如果通过元组实现在循环体里使用多个变量：</p>
<pre><code class="language-js">for let (x,y) = (0, 0) if x &gt; 10 :and y &lt; 100
    ...
    writeLine (y)
    ...
    redo (x+1, y+1)
end
</code></pre>
<h4 id="设有-让-的返回值"><a class="header" href="#设有-让-的返回值"><code>设有 让</code> 的返回值</a></h4>
<p>因为 <code>设有 让</code> 循环语句是一个语句块，所以也是可以有返回值的。</p>
<p>示例：</p>
<pre><code class="language-js">让 总和 =
    设有 让 (i, s) = (1, 0)
        如果 i &gt; 100 那么
            s
        否则
            让 t = s + i
            重做 (i+1, t)
        以上
    以上
</code></pre>
<pre><code class="language-js">let sum =
    for let (i, s) = (1, 0)
        if i &gt; 100 then
            s
        else
            let t = s + i
            redo (i+1, t)
        end
    end
</code></pre>
<p>上例代码实现从整数 1 累加到 100，然后将总和值（即变量 <code>s</code> 的值）。</p>
<h3 id="设有-取自-语句"><a class="header" href="#设有-取自-语句">&quot;设有 取自&quot; 语句</a></h3>
<p><code>设有 取自</code>（<code>for in</code>）用于遍历一个列表或者实现了 <code>序列</code> 特性的数据到一个指定的变量，相当于 Java 语言的 &quot;for each&quot; 语句。</p>
<p>示例：</p>
<pre><code class="language-js">设有 i 取自 [1..10]
    书写行 (i)
以上

// 或者
设有 i 取自 [1..10] 书写行 (i) // ::不一定支持
</code></pre>
<pre><code class="language-js">for i in [1..10]
    writeLine (i)
end

// or
for i in [1..10] writeLine (i) // ::不一定支持
</code></pre>
<p><code>设有 取自</code> 语句也是 <code>块</code> 和 <code>返回</code> 语句的语法糖。原理是使用模式 <code>[x,...xs]</code> 从一个 &quot;类列表&quot; （即 <code>取自</code> 关键字后面的数值）获取第一个元素及余下的元素，然后让第一个元素的值作为变量执行 <code>设有 让</code> 循环体，当循环体执行完成后，判断类列表是否仍然有剩余元素，有则再次使用模式 <code>[x,...xs]</code> 取第一个元素并重复这个过程，没有则结束语句。</p>
<p>上面的示例代码等效下面的代码：</p>
<pre><code class="language-js">让 c = [1..10]
块 (c)
    如果 非(是空的(c)) 那么
        让 [i, ...rest] = c
        # 循环体开始
        书写行(i)
        # 循环体结束
        返回 rest
    以上
以上
</code></pre>
<pre><code class="language-js">let c = [1..10]
block (c)
    if not(isEmpty(c)) then
        let [i, ...rest] = c
        # loop body start
        writeLine(i)
        # loop body end
        recur rest
    end
end
</code></pre>
<p>需要注意的是：</p>
<ul>
<li><code>设有 取自</code> 语句无返回值，如果想遍历一个列表且根据一定的关系返回值，可以使用 <code>映射</code>（<code>map</code>） 或者 <code>折叠</code>（<code>fold</code>） 等函数。</li>
<li>在 <code>设有 取自</code> 语句不支持 <code>continue</code> 和 <code>break</code> 等关键字。</li>
</ul>
<h4 id="设置过滤条件"><a class="header" href="#设置过滤条件">设置过滤条件</a></h4>
<pre><code class="language-js">for i in [1..10]
    filter i :mod: 2 == 0
    writeLine (i)
end

// or
for (i in [1..10]) filter (i :mod: 2 == 0) writeLine (i) // ::不一定支持
</code></pre>
<h4 id="组合遍历多个序列"><a class="header" href="#组合遍历多个序列">组合遍历多个序列</a></h4>
<p>示例：</p>
<pre><code class="language-js">for i in [1..10], j in [0.1,0.2,..1.0]
    writeLine (`{i},{j}`)
end

for i in [1..10], j in [0.1,0.2,..1.0]
    filter (i :mod: 2 == 0) :and: (j &gt;= 0.5)
    writeLine (`{i},{j}`)
end

</code></pre>
<h3 id="指定次数循环todo-删除"><a class="header" href="#指定次数循环todo-删除">指定次数循环(::TODO 删除)</a></h3>
<p>因为循环指定次数比较常见，所以还有一种重复指定次数的循环语句 <code>重复</code> 语句。</p>
<p>示例：</p>
<pre><code class="language-js">重复 10
    书写行 (&quot;你好&quot;)
以上
</code></pre>
<pre><code class="language-js">repeat 10
    writeLine (&quot;Hello&quot;)
end
</code></pre>
<p><code>重复</code> 关键字后面加一个自然数，表示循环的次数。在循环主体里可以使用特殊变量 <code>%</code> 获取当前循环的次数。</p>
<p><code>重复</code> 语句实际上是 <code>设有 取自</code> 语句的语法糖，上面的语句相当于：</p>
<pre><code class="language-js">设有 % 取自 [1..10]
    书写行 (&quot;你好&quot;)
以上
</code></pre>
<p><code>重复</code> 语句无返回值，不支持 <code>continue</code> 和 <code>break</code> 等关键字。</p>
<h3 id="映射语句"><a class="header" href="#映射语句">映射语句</a></h3>
<p>用于遍历一个序列的每个元素，然后返回一个列表。</p>
<pre><code class="language-js">let a = map i in [1..10]
            i * 2
        end

// or
let a = map i in [1..10] i * 2 // ::不一定支持
</code></pre>
<h4 id="映射时设置条件"><a class="header" href="#映射时设置条件">映射时设置条件</a></h4>
<pre><code class="language-js">let a = map i in [1..10]
    filter i :mod: 2 == 0
    i * 2
end

// or
let a = map i in [1..10] filter (i :mod: 2 == 0) i* 2 // ::不一定支持
</code></pre>
<h4 id="组合映射多个序列"><a class="header" href="#组合映射多个序列">组合映射多个序列</a></h4>
<pre><code class="language-js">let a = map i in [1..10], j in [0.1,0.2,..1.0]
            (i, j)
        end
</code></pre>
<p>返回 <code>[(1,0.1), (1,0.2), .., (2,0.1), (2,0.2), .., (10,0.9), (10,1.0)]</code></p>
<pre><code class="language-js">let a1 = map i in [1..10], j in [0.1,0.2..1.0]
            filter i :mod: 2 == 0
            (i, j)
        end

let a2 = [1..10].map(i=&gt;
            [0.1,0.2,..1.0].map(j=&gt;
                (i,j)
            )
        ).filter((i,j) =&gt; if i :mod: 2 == 0)
</code></pre>
<p>上面 2 句等效。</p>
<h3 id="序列类型当中带有循环性质的方法"><a class="header" href="#序列类型当中带有循环性质的方法">序列类型当中带有循环性质的方法</a></h3>
<p>比如 <code>map</code>，<code>fold</code>，<code>zip</code> 等方法，详细见《集合》一章。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式匹配和模式解构"><a class="header" href="#模式匹配和模式解构">模式匹配和模式解构</a></h1>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="pattern.html#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%92%8C%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%84">模式匹配和模式解构</a>
<ul>
<li><a href="pattern.html#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">模式匹配</a>
<ul>
<li><a href="pattern.html#%E5%8C%B9%E9%85%8Dmatch%E8%AF%AD%E5%8F%A5"><code>匹配</code>（<code>match</code>）语句</a>
<ul>
<li><a href="pattern.html#%E6%A8%A1%E5%BC%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F">模式表达式</a>
<ul>
<li><a href="pattern.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E5%AD%98%E5%9C%A8%E5%90%8C%E5%90%8D%E5%8F%98%E9%87%8F">作用域内存在同名变量</a></li>
<li><a href="pattern.html#%E6%A8%A1%E5%BC%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%98%E5%9C%A8%E5%90%8C%E5%90%8D%E5%8F%98%E9%87%8F">模式表达式存在同名变量</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="pattern.html#%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%84todo-%E5%BE%85%E4%BF%AE%E6%94%B9">赋值语句的模式解构(::TODO 待修改)</a>
<ul>
<li><a href="pattern.html#%E8%AE%A9-%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><code>让</code> 语句的返回值</a></li>
</ul>
</li>
<li><a href="pattern.html#%E5%A6%82%E6%9E%9C-%E8%AE%A9%E5%8C%B9%E9%85%8D-%E8%AF%AD%E5%8F%A5"><code>如果 让...匹配</code> 语句</a></li>
<li><a href="pattern.html#%E5%88%97%E8%A1%A8%E7%9A%84%E8%A7%A3%E6%9E%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E9%9C%80%E6%94%B9%E6%88%90-match-%E8%AF%AD%E5%8F%A5">列表的解构（示例代码需改成 match 语句）</a></li>
<li><a href="pattern.html#%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%84%E8%AE%BF%E9%97%AE%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0duplicated">使用模式解构访问列表的元素(::DUPLICATED??)</a></li>
<li><a href="pattern.html#%E6%98%A0%E5%B0%84%E8%A1%A8%E7%9A%84%E8%A7%A3%E6%9E%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E9%9C%80%E6%94%B9%E6%88%90-match-%E8%AF%AD%E5%8F%A5">映射表的解构（示例代码需改成 match 语句）</a></li>
<li><a href="pattern.html#%E5%85%83%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E9%9C%80%E6%94%B9%E6%88%90-match-%E8%AF%AD%E5%8F%A5">元组的解构（示例代码需改成 match 语句）</a></li>
<li><a href="pattern.html#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%A7%A3%E6%9E%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E9%9C%80%E6%94%B9%E6%88%90-match-%E8%AF%AD%E5%8F%A5">结构体的解构（示例代码需改成 match 语句）</a>
<ul>
<li><a href="pattern.html#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8C%B9%E9%85%8D%E5%86%85%E5%AE%B9%E8%B7%9F%E4%B8%8A%E4%B8%80%E6%AE%B5%E9%87%8D%E5%A4%8D%E5%BE%85%E7%BC%96%E8%BE%91">结构体匹配(::内容跟上一段重复，待编辑)</a></li>
<li><a href="pattern.html#%E8%81%94%E5%90%88%E4%BD%93%E5%8C%B9%E9%85%8D">联合体匹配</a></li>
<li><a href="pattern.html#%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D">部分匹配</a></li>
<li><a href="pattern.html#%E5%B8%A6%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">带条件的模式匹配</a></li>
<li><a href="pattern.html#%E5%B8%A6%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">带数据解析的模式匹配</a></li>
<li><a href="pattern.html#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">正则表达式模式匹配</a></li>
<li><a href="pattern.html#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">模板字符串模式匹配</a></li>
<li><a href="pattern.html#%E8%8C%83%E5%9B%B4%E5%8C%B9%E9%85%8D">范围匹配</a></li>
<li><a href="pattern.html#%E5%8C%B9%E9%85%8D%E6%97%B6%E4%BF%9D%E7%95%99%E5%8E%9F%E5%A7%8B%E5%80%BC">匹配时保留原始值</a></li>
</ul>
</li>
<li><a href="pattern.html#%E5%B5%8C%E5%A5%97%E5%8C%B9%E9%85%8D">嵌套匹配</a></li>
<li><a href="pattern.html#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%87%BD%E6%95%B0-new">模式匹配函数 (NEW)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->
<h2 id="模式匹配"><a class="header" href="#模式匹配">模式匹配</a></h2>
<p>模式匹配用于判断目标数据是否跟指定的数据模式相匹配，模式匹配发生于：</p>
<ol>
<li><code>匹配</code> 语句的 <code>情况</code> 关键字后面；</li>
<li><code>条件</code> 语句的 <code>情况</code> 关键字后面的 <code>让</code> 表达式；</li>
<li><code>分支</code> 语句的 <code>情况</code> 关键字后面的 <code>让</code> 表达式；</li>
<li><code>如果 让 ... 匹配</code> 语句；</li>
<li>模式函数。</li>
</ol>
<p>模式匹配不单单用于判断是否匹配问题，同时也用于按照模式获取目标数据的值（通常把这种模式匹配称为 &quot;解构&quot;），或者 &quot;同时判断部分数据的是否匹配，同时获取部分数据的值&quot;。XiaoXuan 所有具有 &quot;赋值&quot; 性质的语句实际上都是模式匹配（解构），包括：</p>
<ol>
<li><code>让</code>（<code>let</code>）赋值语句</li>
<li><code>现有 取自</code>（<code>for in</code>）循环语句 <!-- `遍历`（`iterate`）语句的 `到`（`to`）关键字之后、--></li>
<li><code>现有 让</code>（<code>for let</code>）循环语句的 &quot;值初始化&quot; 以及 &quot;值更新&quot;</li>
<li>函数的参数传值、</li>
</ol>
<h3 id="匹配match语句"><a class="header" href="#匹配match语句"><code>匹配</code>（<code>match</code>）语句</a></h3>
<p><code>匹配</code> 语句会对 &quot;待检查的数据&quot; 的数据类型、结构、值等进行比较，只有完全匹配的分支才被执行。</p>
<p>示例：</p>
<pre><code class="language-js">让 v = (&quot;foo&quot;,&quot;bar&quot;,&quot;foo&quot;)

匹配 v
    情况 (a,b,c):
        &quot;成功，a 的值将会是 'foo', b 是 'bar', c 是 'foo'&quot;
    情况 (&quot;foo&quot;, a, b):
        &quot;成功，第一个元素是 'foo', a 的值将会是 'bar', b 是 'foo'&quot;
    情况 (a,b,a):
        &quot;成功，a 的值将会是 'foo', b 是 'bar', 第一个和第三个元素的值相同&quot;
    情况 (a,...b):
        &quot;成功，a 的值将会是 'foo', b 是 ('bar','foo')&quot;
    情况 (a,_,_):
        &quot;成功，a 的值将会是 'foo', 丢弃第二个和第三个元素的值&quot;
    情况 (_,_,_):
        &quot;成功，丢弃所有元素的值&quot;
    情况 (a,a,b):
        &quot;失败，第一个和第二个元素的值不相同&quot;
    情况 (_,_):
        &quot;失败，因为 v 有 3 个元素&quot;
    默认:
        &quot;总是成功&quot;
end
</code></pre>
<pre><code class="language-js">let v = (&quot;foo&quot;,&quot;bar&quot;,&quot;foo&quot;)

match v
    case (a,b,c):
        &quot;OK, the value of 'a' will be 'foo', 'b' is 'bar', 'c' is 'foo'&quot;
    case (&quot;foo&quot;, a, b):
        &quot;OK, the first element is 'foo', the value of 'a' will be 'bar', 'b' is 'foo'&quot;
    case (a,b,a):
        &quot;OK, the value of 'a' will be 'foo', 'b' is 'bar', the first and third elements have the same value&quot;
    case (a,...b):
        &quot;OK, the value of 'a' will be 'foo', 'b' is ('bar','foo')&quot;
    case (a,_,_):
        &quot;OK, the value of 'a' will be 'foo', discard the values of the second and third elements&quot;
    case (_,_,_):
        &quot;OK, descard the values of all elements&quot;
    case (a,a,b):
        &quot;Failed, The first and second elements do not have the same value&quot;
    case (_,_):
        &quot;Failed, because 'v' has 3 elements&quot;
    default:
        &quot;Always OK&quot;
end
</code></pre>
<p>在上面示例代码中：</p>
<ul>
<li><code>匹配</code> 关键字后面的是待检查的数据</li>
<li>每一个 <code>情况</code> 关键字后面的是一个模式表达式，如果其中一个模式表达式匹配成功，则执行其分支的语句，然后跳出匹配语句。</li>
<li><code>默认</code> 关键字后面的是当上面的所有模式表达式都不匹配时，则执行默认部分的语句。</li>
<li>如果没有 <code>默认</code> 分支，且所有模式表达式都不匹配，则运行环境会抛出运行时异常。</li>
<li>匹配语句会返回匹配中的分支的语句（或表达式）的值。</li>
</ul>
<blockquote>
<p><code>模式</code> 语句是 <code>条件</code> 语句的语法糖。</p>
</blockquote>
<h4 id="模式表达式"><a class="header" href="#模式表达式">模式表达式</a></h4>
<p>模式表达式由字面量（包括列表的中括号、元组的括号、映射表的花括号）、常量及变量等组成。</p>
<p>其中字面量和常量用于跟 &quot;待检查的数据&quot; 作相等比较，而变量则作为占位符，当匹配成功时（即字面量和常量相等、结构相同、元素或成员个数相同），变量则会捕获其所对应的数值。</p>
<h5 id="作用域内存在同名变量"><a class="header" href="#作用域内存在同名变量">作用域内存在同名变量</a></h5>
<p>如果模式表达式当中存在其 <code>匹配</code> 语句所在的作用域同名的变量名，因为 XiaoXuan 语言不允许在作用域内存在同名变量，所以这条模式表达式会引起语法错误。<!-- 模式表达式当中的变量会覆盖外面的变量，新变量的作用域包括该分支的代码。--></p>
<p>示例：</p>
<pre><code class="language-js">让 i = 123
让 v = (77,88)
匹配 v
    情况 (i, j):
        // 上面一行会引起语法错误，因为在作用域内已经存在名称为 `i` 的变量
以上
</code></pre>
<pre><code class="language-js">let i = 123
let v = (77,88)
match v
    case (i, j):
        // syntax error,
end
</code></pre>
<h5 id="模式表达式存在同名变量"><a class="header" href="#模式表达式存在同名变量">模式表达式存在同名变量</a></h5>
<p>如有匹配式中存在两个或以上同名变量，则第一个会被赋值，第二个及之后的会当成常量来比较。示例：</p>
<pre><code class="language-js">让 v = (11, 22, 22, 11)
匹配 v
    情况 (a, a, b, b):
        书写行 (&quot;匹配失败&quot;)
    情况 (a, b, b, a):
        书写行 (&quot;匹配成功，变量 a 的值将会是 11, b 是 22&quot;)
以上
</code></pre>
<pre><code class="language-js">let v = (11, 22, 22, 11)
match v
    case (a, a, b, b):
        writeLine (&quot;Failed&quot;)
    case (a, b, b, a):
        writeLine (&quot;Ok, the value of 'a' will be 11, 'b' is 22&quot;)
end
</code></pre>
<p>上面例子中，当运行时检查第一个模式匹配表达式时，首先检查数据类型通过（都是元组），然后检查成员数量通过（都是 4），然后发现第一个成员是一个变量 <code>a</code>，则赋值 <code>11</code> 给它，然后发现表达式第二个成员还是变量，且名字是已经出现过的 <code>a</code>，这时就会取出 <code>a</code> 的值（也就是 <code>11</code>）跟实际数据（即 <code>22</code>）作相等比较，发现不通过，所以该表达式匹配失败。</p>
<!--
## 赋值语句（模式解构）
示例，现有如下数据：

```js
让 v1 = (123, 456)
让 v2 = (77, 88)
让 vv = [v1, v2]
```

赋值语句解构：

```js
让 (a, b) = v1
```

遍历语句解构：

```js
遍历 vv 到 (a, b)
    ...
以上
```

`现有` 循环语句解构：

```js
现有 让 (a,b) = v1 如果 a>0 :并且 b>0 那么
    ...
    让 i = ...
    让 j = ...
    重复 (i,j)
以上
```
-->
<h3 id="赋值语句的模式解构todo-待修改"><a class="header" href="#赋值语句的模式解构todo-待修改">赋值语句的模式解构(::TODO 待修改)</a></h3>
<p>XiaoXuan 的赋值语句实质是模式解构，比如 <code>让 4 = 4</code> 语句是合法的（并且返回字面量 4）。当赋值语句的左边是一个单纯的变量时，因为变量能匹配任何值，所以其作用就是单纯的 &quot;赋值&quot;。当赋值语句左边不是一个单纯的变量时，则发生模式匹配。</p>
<p>需要注意的是，因为缺少 <code>匹配</code> 语句的 <code>默认</code> 分支，如果赋值语句的模式不匹配，会直接引起运行时异常。</p>
<p>示例：</p>
<pre><code class="language-js">union User
    Student(String name)
    Teacher(String name)
end

let s = new User.Student(&quot;foo&quot;)
let Teacher t1 = s
let Teacher (name) = s
</code></pre>
<p>上面代码最后两行都会引起运行时异常，第一行很容易理解，跟很多编程语言一样，变量的类型不一致是不能赋值的，但 XiaoXuan 并不是简单地根据数据类型来判断，而是通过模式匹配来判断的。第二行则是标准的模式匹配失败。</p>
<p>再举一个数据类型匹配，但模式匹配失败的示例：</p>
<pre><code class="language-js">让 (a, b, b, a) = (1, 2, 3, 4)
</code></pre>
<p>上面的赋值语句（模式解构）虽然左右两边的数据类型一致（都是元组），但因为模式不匹配，所以会引起运行时异常。</p>
<!-- 模式解构可以应用于列表、映射表、结构体、元组等数据，但**无法解构**联合体，因为联合体的值是其多个成员的其中一个，只能通过模式匹配先匹配类型再解构，即只能使用 `匹配` 语句或者使用 `如果 让` 语句来获取其中的值。-->
<h4 id="赋值语句的模式解构语句的返回值"><a class="header" href="#赋值语句的模式解构语句的返回值">赋值语句的模式解构语句的返回值</a></h4>
<p>模式结构语句在成功匹配时，语句的返回值是成功解构后的值，而匹配失败时，则抛出运行时异异常。</p>
<p>示例：</p>
<pre><code>let v1 = (let a = 123)
let v2 = (let User(name) = new User(&quot;foo&quot;))
let v3 = (let User(99, name) = new User(99, &quot;foo&quot;))
let v4 = (let User u expand (id, name) = new User(88, &quot;bar&quot;))
</code></pre>
<p>以上的 4 个变量的值分别为：</p>
<ul>
<li>一个整数，值为 <code>123</code></li>
<li>一个字符串， 值为 <code>&quot;foo&quot;</code></li>
<li>一个元组，值为 <code>(99, &quot;foo&quot;)</code></li>
<li>一个嵌套的元组 <code>(User, (Int, String))</code>，值为 <code>(User(88, &quot;bar&quot;), (88, &quot;bar&quot;))</code></li>
</ul>
<h3 id="如果-让匹配-语句"><a class="header" href="#如果-让匹配-语句"><code>如果 让...匹配</code> 语句</a></h3>
<p>有时可能仅仅为了匹配一种模式，这时可以使用 <code>如果 让...匹配</code>（<code>if let...match</code>） 语句，而无必要使用完整的 <code>匹配</code> 语句。</p>
<p>示例：</p>
<pre><code>让 v = (123, 456)
如果 让 (a, b) 匹配 v 那么
    格式化书写行 (&quot;a 是: {}, b 是: {}&quot;, a, b)
以上

如果 让 (123, b) 匹配 v 那么
    格式化书写行 (&quot;a 是 123&quot;)
以上
</code></pre>
<pre><code>let v = (123, 456)
if let (a, b) match v then
    writeLineFormat (&quot;a is: {}, b is: {}&quot;, a, b)
end

if let (123, b) match v then
    writeLineFormat (&quot;a is 123&quot;)
end
</code></pre>
<p>在 <code>让</code> 关键字和 <code>匹配</code> 关键字之间除了可以是一个模式匹配表达式，也可以加入上面 <code>匹配</code> 语句当中提到的 <code>解析</code>、<code>展开</code> 和 <code>正则匹配</code> 等关键字。示例：</p>
<pre><code class="language-js">如果 让 解析 User(id, name) 匹配 v 那么 ...
如果 让 u 展开 解析 User(id, name) 匹配 v 那么 ...

如果 让 正则匹配 &quot;^(.+)@(.+)$&quot; [email, name, domain] 匹配 v 那么 ...
如果 让 u 展开 正则匹配 &quot;^(.+)@(.+)$&quot; [email, name, domain] 匹配 v 那么 ...
</code></pre>
<p><code>让...匹配</code> 表达式返回的是一个 <code>逻辑</code>（<code>Boolean</code>）类型的数值，所以有时还可以跟其他条件一起组合成更为复杂的条件语句。比如：</p>
<pre><code class="language-js">if let (id, name) match user1 :and id &gt; 100 then
    ...
end
</code></pre>
<blockquote>
<p><code>让...匹配</code> 表达式不能单独写成一条语句，因为这样很容易因为忘记判断其返回值而使用模式匹配表达式里的变量值，所以语法上规定  <code>让...匹配</code> 表达式只能写在 <code>如果</code> 语句、<code>分支</code> 语句、<code>条件</code> 语句里。</p>
</blockquote>
<h3 id="列表的解构示例代码需改成-match-语句"><a class="header" href="#列表的解构示例代码需改成-match-语句">列表的解构（示例代码需改成 match 语句）</a></h3>
<p>示例：</p>
<pre><code class="language-js"># 第一个 == 1, 第二个 == 2, 剩余 == [3,4,5,6]
让 [第一个, 第二个, ...剩余] = [1,2,3,4,5,6]

# 丢弃第一个和第二个元素的值， 第三个 == 3
让 [_, _, 第三个] = [1,2,3,4,5]

# 解构一个二维列表
# 第一个 == 1, 第二个 == 2, 第三个 == 3
让 [[第一个, 第二个], [第三个, _]] = [[1,2],[3,4],[5,6]]

# 使用索引来解构（::不支持）
# 注意索引从 1 开始，而不是从 0 开始
# x == 1, y == 6
让 [1:x, 6:y] = [1,2,3,4,5,6]
</code></pre>
<pre><code class="language-js"># first == 1, second == 2, rest == [3,4,5,6]
let [first, second, ...rest] = [1,2,3,4,5,6]

# drop the first and the second element value, third == 3
let [_, _, third] = [1,2,3,4,5]

# deconstructing a two-dimensional list
# first == 1, second ==2, third == 3
let [[first, second], [third, _]] = [[1,2],[3,4],[5,6]]

# Deconstructing using indexes (::not supported)
# Note that indexes start at 1, not 0
# x == 1, y == 6
let [1:x, 6:y] = [1,2,3,4,5,6]
</code></pre>
<p>在上例中：</p>
<ul>
<li>其中的 <code>...</code> 符号（三个点号）表示获取列表当中剩余的其他元素；</li>
<li>其中的 <code>_</code> 符号（下划线）表示仅匹配位置，丢弃其值。</li>
</ul>
<h3 id="使用模式解构访问列表的元素duplicated"><a class="header" href="#使用模式解构访问列表的元素duplicated">使用模式解构访问列表的元素(::DUPLICATED??)</a></h3>
<p>使用模式解构来获取列表的元素比使用函数的更加简单直观，示例：</p>
<pre><code class="language-js">让 a = [1,2,3,4,5]

# 获取第 1 个元素并赋值给变量 i，此时 i == 1
让 [i] = a

# 获取第 1 和第 2 个元素分别赋值给变量 i 和变量 j，此时 i == 1, j == 2
让 [i, j] = a

# 获取第 1 和第 2 个元素，第 1 个元素的值丢弃，第 2 个元素的值赋值给 i，此时 i = 2
让 [_, i] = a

# 获取第 1 个以及剩余的元素，第 1 个元素赋值给变量 i，
# 剩余的元素（是一个列表）赋值给变量 j，此时变量 j == [2, 3, 4, 5]。
让 [i, ...j] = a

# 获取第 1 和第 2 个以及剩余的元素，前两个元素分别赋值给变量 i 和 j，
# 剩余的元素（是一个列表）赋值给变量 k，此时变量 k == [3, 4, 5]
让 [i, j, ...k] = a
</code></pre>
<p>需注意的是<strong>剩余</strong>关键字 <code>...</code> （即三个点，同 &quot;展开&quot; 关键字）只能出现在中括号的末尾，诸如 <code>let [i, ...j, k]</code> 语句是有语法错误的。</p>
<h3 id="映射表的解构示例代码需改成-match-语句"><a class="header" href="#映射表的解构示例代码需改成-match-语句">映射表的解构（示例代码需改成 match 语句）</a></h3>
<p>示例：</p>
<pre><code class="language-js">让 名称 = {&quot;姓&quot;: &quot;张&quot;, &quot;名&quot;: &quot;三&quot;, &quot;辈&quot;: &quot;伯&quot;};

# a == &quot;张&quot;, b == &quot;三&quot;
let {&quot;姓&quot;: a, &quot;名&quot;: b} = 名称
</code></pre>
<pre><code class="language-js">let name = {&quot;firstName&quot;: &quot;foo&quot;, &quot;lastName&quot;: &quot;bar&quot;, &quot;middleName&quot;: &quot;D&quot;};

# a == &quot;foo&quot;, b == &quot;bar&quot;
let {&quot;firstName&quot;: a, &quot;lastName&quot;: b} = name
</code></pre>
<p>如果映射表的 key 是字符串，也可以省略其双引号，这样会得到跟 key 名称一样的变量。</p>
<p>示例：</p>
<pre><code class="language-js"># 姓 == &quot;张&quot;, 名 == &quot;三&quot;
让 {姓, 名} = name
</code></pre>
<pre><code class="language-js"># firstName == &quot;foo&quot;, lastName == &quot;bar&quot;
let {firstName, lastName} = name
</code></pre>
<h3 id="元组的解构示例代码需改成-match-语句"><a class="header" href="#元组的解构示例代码需改成-match-语句">元组的解构（示例代码需改成 match 语句）</a></h3>
<p>示例：</p>
<pre><code class="language-js">让 v = (123, &quot;foo&quot;, true)

# a == 123
让 (a) = v

# a == 123, b == &quot;foo&quot;, c == true
让 (a, b, c) = v

# a == true
让 (_, _, a) = v
</code></pre>
<pre><code class="language-js">let v = (123, &quot;foo&quot;, true)

# a == 123
let (a) = v

# a == 123, b == &quot;foo&quot;, c == true
let (a, b, c) = v

# a == true
let (_, _, a) = v
</code></pre>
<p>在上例中，其中的 <code>_</code> 符号（下划线）表示仅匹配位置，丢弃其值。</p>
<p>嵌套的元组也能解构，示例：</p>
<pre><code class="language-js">let t = (&quot;foo&quot;, (&quot;abc&quot;,&quot;xyz&quot;), &quot;bar&quot;)

# a == &quot;abc&quot;, b == &quot;xyz&quot;
let (_,(a, b),_) = t
</code></pre>
<h3 id="结构体的解构示例代码需改成-match-语句"><a class="header" href="#结构体的解构示例代码需改成-match-语句">结构体的解构（示例代码需改成 match 语句）</a></h3>
<p>结构体的解构必须使用其<strong>默认构造函数</strong>的各成员的顺序获取各个成员的值。</p>
<p>示例：</p>
<pre><code class="language-js">让 u = 用户(1, &quot;foo&quot;, 99)

# id == 1
让 User (id) = u

# id == 1, name == &quot;foo&quot;
让 User (id, name) = u

# id == 1, name == &quot;foo&quot;, score == 99
让 User (id, name, score) = u

# score == 99
让 User (_, _, score) = u
</code></pre>
<pre><code class="language-js">let u = User(1, &quot;foo&quot;, 99)

# id == 1
let User (id) = u

# id == 1, name == &quot;foo&quot;
let User (id, name) = u

# id == 1, name == &quot;foo&quot;, score == 99
let User (id, name, score) = u

# score == 99
let User (_, _, score) = u
</code></pre>
<p>在上例中，其中的 <code>_</code> 符号（下划线）表示仅匹配位置，丢弃其值。</p>
<p>联合体的结构体类型成员的解构方法跟结构体的解构一样。</p>
<p>注意，结构体的解构也可以按成员的名称来解构（假如成员有名称的话），示例：</p>
<pre><code class="language-js">让 User(id=a, name=b) = u
</code></pre>
<p>当一个结构体的成员数量比较多，且只需很少的部分成员的值时，按成员名称来解构（而不是按参数顺序来解构）能简便很多。</p>
<h4 id="结构体匹配内容跟上一段重复待编辑"><a class="header" href="#结构体匹配内容跟上一段重复待编辑">结构体匹配(::内容跟上一段重复，待编辑)</a></h4>
<p>结构体的匹配表达式一般为：按照该结构体的默认构造函数的成员的出现顺序，列出字面量、常量或者变量的组合，比如上例中的 <code>case Book(title, isbn)</code> 就是将 <code>Book</code> 的两个成员按顺序列出。</p>
<p>另外一种格式是，按照成员的名称列出字面量、常量或者变量，示例：</p>
<pre><code class="language-js">match v
    case Book(title=&quot;foo&quot;, isbn=&quot;123&quot;):
        ...
    case Book(title=&quot;bar&quot;, isbn=x):
        ...
end
</code></pre>
<p>跟调用普通函数的情况类似，可以混合按参数顺序和按参数名称书写结构体的匹配表达式，但必须先写完所有按顺序的参数，才可以开始写按名称的参数。</p>
<p>如果匹配表达式里的成员名称和变量名一样，也可以省略书写成员名称。</p>
<p><code>case Book(title, isbn)</code></p>
<p>等同于：</p>
<p><code>case Book(title=title, isbn=isbn)</code></p>
<h4 id="联合体匹配"><a class="header" href="#联合体匹配">联合体匹配</a></h4>
<p>在匹配一个模式表达式时，运行环境在编译截断会事先检查被匹配的数据和匹配表达式的数据类型是否一致，如果不一致则不通过编译。</p>
<p>但联合体因为可以有多个成员（为常量或者结构体），所以在运行时，首先会对子类型进行匹配，类型一致之后再对值进行匹配。</p>
<p>比如有一个联合体：</p>
<pre><code class="language-js">union Work
    Book(String title, String isbn)
    Album(String title, String artist)
end
</code></pre>
<p>模式匹配语句如下：</p>
<pre><code class="language-js">01  match v
02      case Book (title, isbn):
03          writeLineFormat (&quot;Book title: {}, ISBN: {}&quot;, title, isbn)
04      case Album (title, artist):
05          writeLineFormat (&quot;Album title: {}, artist: {}&quot;, title, artist)
06  end
</code></pre>
<p>当变量 <code>v</code> 的值为 <code>Book</code> 的实例，02 行会被匹配中，如果值为 <code>Album</code> 的实例，则 04 行会被匹配中。</p>
<h4 id="部分匹配"><a class="header" href="#部分匹配">部分匹配</a></h4>
<p>对于一个复合结构的数据（比如列表、映射表、结构体、联合体的成员），模式表达式中的对结构的要求是不可反驳的，即 &quot;实际数据的结构和组成&quot; 跟 &quot;模式匹配表达式要求的&quot; 必须严格地一一对应。</p>
<p>也就是说匹配一个复合结构的数据时，表达式必须把全部成员和元素都列出才能匹配成功。如果不想全员列出（比如有时只需要当中的部分数据），可以使用 “...” 符号（三个点号）表示省略余下成员或元素，即此部分匹配是可选的（换句话说，也就是能匹配 0 或者多项）。比如：</p>
<ul>
<li>
<p><code>case [first, second, ...remains]</code>
表示匹配具有两个或两个以上元素的列表，且从第三个开始的元素的值存储在 <code>remains</code> 列表中，这个列表有可能是空列表。</p>
</li>
<li>
<p><code>case {id, name, ...remains}</code>
表示匹配具有 &quot;id&quot; 和 &quot;name&quot; 两个 key 的映射表，且把其他 key 及值存储在 <code>remains</code> 映射表中，这个映射表有可能是空的。</p>
</li>
<li>
<p><code>case User(id, name, ...remains)</code>
表示匹配数据类型为 <code>User</code>，且具有 &quot;id&quot; 和 &quot;name&quot; 两个成员的结构体（或者联合体当中名称为 <code>User</code> 的结构体类型成员），结构体的其他成员的值会被存储到 <code>remains</code> 元组中，这个元组有可能是空元组。</p>
</li>
<li>
<p><code>case User(id = x, name = y, ...remains)</code>
表示匹配数据类型为 <code>User</code>，且具有 &quot;id&quot; 和 &quot;name&quot; 两个成员的结构体，这两个成员的值分别存储在变量 <code>x</code> 和 <code>y</code>，结构体的其他成员的值会被存储到 <code>remains</code> 元组中，这个元组有可能是空元组。</p>
</li>
<li>
<p><code>case (one, two, ...remains)</code>
表示匹配具有两个或两个以上成员的元组，且从第三个开始的成员的值存储在 <code>remains</code> 元组中，这个元组有可能是空元组。</p>
</li>
</ul>
<p>注意，如果对其余的数据不感兴趣（即上面示例当中的 <code>remains</code> 变量所存储的数据），也可以把 <code>remains</code> 变量名更改为 <code>_</code>（下划线符号），即 <code>..._</code> 表示丢弃其匹配所得的数据。为了简洁起见，甚至可以把 <code>_</code> 符号也省略，只保留 <code>...</code> 符号即可。比如 <code>case [first, second, ...]</code>。</p>
<h4 id="带条件的模式匹配"><a class="header" href="#带条件的模式匹配">带条件的模式匹配</a></h4>
<p>可以在模式匹配表达式后面加上 <code>如果</code> 条件语句，用于提供额外的匹配条件（也叫 &quot;守卫&quot; &quot;Guard&quot;），</p>
<p>(:: 考虑使用 <code>要求/仅当</code>（<code>require/when</code>）关键字替换 <code>如果</code> 关键字）</p>
<p>示例：</p>
<pre><code class="language-js">匹配 v
    情况 (x,y,z) 如果 x &gt; 10: # 仅当后面的条件表达式返回 `真` 时该分支才被匹配中。
       ...
以上
</code></pre>
<pre><code class="language-js">match v
   case (x,y,z) if x &gt; 10:
       ...
end
</code></pre>
<p><code>如果</code> 条件语句能够使用其作用域已存在的变量，包括写在匹配表达式里的变量。</p>
<h4 id="带数据解析的模式匹配"><a class="header" href="#带数据解析的模式匹配">带数据解析的模式匹配</a></h4>
<p>有时用于 &quot;被匹配的数据&quot; 并不是最终所需的数据，可能需要经过一定的转换后才是所需的数据。模式匹配支持同时 &quot;转换&quot; 和 &quot;匹配&quot;。</p>
<p>示例：</p>
<p>假设原始数据是 <code>String</code> 类型，既可以解析为 <code>Email</code> 类型，也能解析为 <code>Phone</code>，<code>Email</code> 和 <code>Phone</code> 是联合体 <code>SocialId</code> 的两个成员：</p>
<pre><code class="language-js">联合体 社交帐号
    电子邮箱(字符串 name, 字符串 domain)
    电话(字符串 countryCode, 字符串 number)
end

实现 解析器&lt;电子邮箱, 字符串&gt; 到 电子邮箱
    函数 可选&lt;电子邮箱&gt; 解析(字符串 s)
        匹配 正则(&quot;^(.+)@(.+)$&quot;).查找(s)
            情况 有([_, name, domain]): 有(电子邮箱(name, domain))
            情况 无: 无
        以上
    以上
以上

实现 解析器&lt;电话, 字符串&gt; 到 电话
    函数 可选&lt;电话&gt; 解析(字符串 s)
        匹配 正则(&quot;^(\\+\\d+)-(\\d+)$&quot;).查找(s)
            情况 有([_, countryCode, number]): 有(电话(countryCode, number))
            情况 无: 无
        以上
    以上
以上
</code></pre>
<pre><code class="language-js">Union SocialId
    Email(String name, String domain)
    Phone(String countryCode, String number)
end

implement Parser&lt;Email, String&gt; to Email
    function Option&lt;Email&gt; parse(String s)
        match Regex(&quot;^(.+)@(.+)$&quot;).find(s)
            case Some([_, name, domain]): Some(Email(name, domain))
            case None: None
        end
    end
end

implement Parser&lt;Phone, String&gt; to Phone
    function Option&lt;Phone&gt; parse(String s)
        match Regex(&quot;^(\\+\\d+)-(\\d+)$&quot;).find(s)
            case Some([_, countryCode, number]): Some(Phone(countryCode, number))
            case None: None
        end
    end
end
</code></pre>
<p>下面是测试代码：</p>
<pre><code class="language-js"># a == None
let a = Parser&lt;Email, String&gt;.parse(&quot;foobar&quot;)

# b == Some(Email(&quot;foo&quot;, &quot;bar&quot;))
let b = Parser&lt;Email, String&gt;.parse(&quot;foo@bar&quot;)

# c == None
let c = Parser&lt;Phone, String&gt;.parse(&quot;123&quot;)

# d == Some(Phone(&quot;+86&quot;, &quot;123456&quot;))
let d = Parser&lt;Phone, String&gt;.parse(&quot;+86-123456&quot;)
</code></pre>
<p>如果需要在 <code>匹配</code> 语句当中先对数据进行解析再匹配，则需要模式匹配表达式之前（或者说，在 <code>情况</code> 关键字之后）加上 <code>解析</code> 关键字。</p>
<p>示例：</p>
<pre><code class="language-js">让 s = &quot;foo@bar&quot;

# 注意变量 's' 是字符串类型，而
# 模式匹配表达式的分别是 Email 和 Phone 类型

匹配 s
    情况 解析 Email email
        书写行(&quot;一个电子邮箱&quot;)
    情况 解析 Phone phone:
        书写行(&quot;一个电话号码&quot;)
    默认:
        书写行(&quot;未检测到&quot;)
以上

// 或者在解析的同时进行解构

匹配 s
    情况 解析 Email (name, domain):
        书写行(&quot;一个电子邮箱&quot;)
    情况 解析 Phone (countryCode, number):
        书写行(&quot;一个电话号码&quot;)
    默认:
        书写行(&quot;未检测到&quot;)
以上
</code></pre>
<pre><code class="language-js">let s = &quot;foo@bar&quot;

# Note that the variable 's' is a String, while
# the data type in the matching pattern expression are Email and Phone.

match s
    case parse Email email:
        writeLine(&quot;It's an Email address&quot;)
    case parse Phone phone:
        writeLine(&quot;It's a phone number&quot;)
    default:
        writeLine(&quot;Not detected&quot;)
end

match s
    case parse Email (name, domain):
        writeLine(&quot;It's an Email address&quot;)
    case parse Phone (countryCode, number):
        writeLine(&quot;It's a phone number&quot;)
    default:
        writeLine(&quot;Not detected&quot;)
end
</code></pre>
<p>如果模式匹配发生在函数的参数，则 <code>解析</code> 关键字加在模式表达式之前，比如：</p>
<pre><code class="language-js">模式函数 测试 (解析 电子邮箱 email, 解析 电话 phone)
    ...
以上

// 或者

模式函数 测试 (解析 电子邮箱 (name, domain), 解析 电话 (countryCode, number))
    ...
以上
</code></pre>
<pre><code class="language-js">pattern function test (parse Email email, parse Phone phone)
    ...
end

// or

pattern function test (parse Email (name, domain), parse Phone (countryCode, number))
    ...
end
</code></pre>
<p>标准库里的很多基本类型都有从字符串转换到其类型的 <code>parse</code> 方法，比如 <code>Int::parse(String)</code>，<code>Boolean::parse(String)</code>, <code>Real::parse(String)</code>，其实它们都实现了 <code>parse</code> 特性，所以当然也就可以使用模式匹配的 <code>parse</code> 转换兼匹配的便利了，比如：</p>
<pre><code class="language-js">let tokens = // [...]
let symbols = tokens.map(s =&gt;
    match s
        case parse Int i:
            Symbol::Int(i)
        case parse Boolean b:
            Symbol::Boolean(b)
        case parse Real r:
            Symbol::Real(r)
        default:
            Symbol::Unknown
    end
)
</code></pre>
<h4 id="正则表达式模式匹配"><a class="header" href="#正则表达式模式匹配">正则表达式模式匹配</a></h4>
<p>正则函数 <code>正则(expression).查找(String)</code>（<code>Regex(expression).find(String)</code>） 成功时返回的是一个被 <code>可选</code>（<code>Option</code>）联合体的成员 <code>有</code>(<code>Some</code>) 封装的列表，列表的第一个元素是匹配中的内容（字符串），从第二个元素开始是各个匹配组的值。find 函数失败时返回的是 <code>无</code>（<code>None</code>）。</p>
<p>示例：</p>
<p>假设一个简单的 Email 地址正则表达式为 &quot;^(.+)@(.+)$&quot;：</p>
<pre><code class="language-js">让 s = &quot;foo@domain&quot;
让 ss = 正则(&quot;^(.+)@(.+)$&quot;).查找(s)
</code></pre>
<p>则 <code>ss</code> 的值为 <code>Some([&quot;foo@domain&quot;, &quot;foo&quot;, &quot;domain&quot;])</code>。</p>
<p>可以把正则函数 <code>查找</code> 的结果结合模式匹配：</p>
<pre><code class="language-js">匹配 ss
    情况 有([_, name, domain]):
        格式化书写行(&quot;名称是: {}, 域名是: {}&quot;, name, domain)
    默认:
        书写行(&quot;未侦测到电子邮箱&quot;)
以上
</code></pre>
<pre><code class="language-js">match ss
    case Some([_, name, domain]):
        writeLineFormat(&quot;Name is: {}, domain is: {}&quot;, name, domain)
    default:
        writeLine(&quot;No Email address detected&quot;)
end
</code></pre>
<p>因为这种匹配情况比较常见，所以模式匹配支持同时 &quot;正则匹配&quot; 和 &quot;模式匹配&quot;，跟 <code>解析</code> 关键字类似，只需把模式表达式换成正则表达式，然后在表达式前面加上 <code>正则匹配</code> 关键字。</p>
<p>示例：</p>
<pre><code class="language-js">让 s = &quot;foo@domain&quot;

匹配 s
    情况 正则匹配 /^(.+)@(.+)$/ [email, name, domain]:
        格式化书写行(&quot;是一个电子邮箱: {}&quot;, email)
    情况 正则匹配 /^(\\+\\d+)-(\\d+)$/ [phone, countryCode, number]:
        格式化书写行(&quot;是一个电话号码: {}&quot;, phone)
    默认:
        书写行(&quot;未侦测到&quot;)
以上
</code></pre>
<pre><code class="language-js">let s = &quot;foo@domain&quot;

match s
    case regular /^(.+)@(.+)$/ [email, name, domain]:
        writeLineFormat(&quot;It's Email: {}&quot;, email)
    case regular /^(\\w+):\/\/(.+)$/ [phone, countryCode, number]:
        writeLineFormat(&quot;It's phone number: {}&quot;, phone)
    default:
        writeLine(&quot;Not detected&quot;)
end
</code></pre>
<p>需要注意的是，使用正则匹配的模式匹配时，&quot;被检查的数据&quot; 必须是字符串类型。</p>
<!-- 如果需要指定正则匹配的参数，则使用 `(pattern_expression, option_value_or_list)` 元组代替正则表达式字符串。-->
<p><code>regular</code> 后面也能接受一个正则实例，使用正则构造函数 <code>Regex::new(String, Options)</code> 或者使用正则字面量 <code>/String/</code> 均可构建正则对象。</p>
<p>示例：</p>
<pre><code class="language-js">match s
    case regular Regex::new(&quot;[a-z]+&quot;, RegularConst.ignoreCase) [name]:
        ...
    case regular /[0-9]+/ [number]:
        ...
end
</code></pre>
<h4 id="模板字符串模式匹配"><a class="header" href="#模板字符串模式匹配">模板字符串模式匹配</a></h4>
<p>模板字符串模式匹配是 <code>正则匹配</code> 的简化版。</p>
<p>示例：</p>
<pre><code class="language-js">匹配 s
    情况 模板匹配 `/user/{userName:\w+}`:
        格式化书写行(&quot;Get user {}&quot;, userName)
    情况 模板匹配 `/user/{userName:\w+}/post/{postId:\d+}`:
        格式化书写行(&quot;Get post {}&quot;, postId)
end
</code></pre>
<pre><code class="language-js">match s
    case template `/user/{userName:\w+}`:
        writeLineFormat(&quot;Get user {}&quot;, userName)
    case template `/user/{userName:\w+}/post/{postId:\d+}`:
        writeLineFormat(&quot;Get post {}&quot;, postId)
end
</code></pre>
<p>其中的 <code>template ...</code> 会被解析为 <code>regular ...</code>，而模板字符串里面的占位符 <code>{...}</code> 是正则表达式以及其捕获值所存储的变量名，如果省略正则表达式部分，默认正则表达式是 <code>(.+)</code>。上面的代码会被解析为：</p>
<pre><code class="language-js">match s
    case regular /\/user\/(\w+)/ [userName]:
        ...
    case regular /\/user\/(\w+)\/post\/(\d+)/ [userName, postId]:
        ...
end
</code></pre>
<h4 id="范围匹配"><a class="header" href="#范围匹配">范围匹配</a></h4>
<pre><code class="language-js">匹配 i
    情况 位于 1..2:
        ...
</code></pre>
<pre><code class="language-js">match i
    case in 1..2:
        ...
</code></pre>
<pre><code class="language-js">match c
    case in 'a'..'f':
        ...
</code></pre>
<p>关键字 <code>范围匹配</code> 后面可以是一个 <code>Range</code>、一个 <code>List</code> 对象，只要是一个拥有 <code>Exist</code> 特性的对象都可以。比如：</p>
<pre><code class="language-js">匹配 i
    情况 位于 数列::新建(1, 100):
        ...
</code></pre>
<p>匹配时会使用被匹配的值传入目标对象的 <code>exist</code> 方法，如果方法返回 <code>true</code>，则该匹配式成立。</p>
<h4 id="匹配时保留原始值"><a class="header" href="#匹配时保留原始值">匹配时保留原始值</a></h4>
<p>当匹配一个复合结构的数据时，写在匹配表达式里的变量获取的是原始数据的某个部分，如果想获取完整的原始数据，可以在模式表达式之前加上一个 <code>展开</code>（<code>expand</code>）关键字。</p>
<p>示例：</p>
<pre><code class="language-js">让 v = 通过ID获取用户(123)
匹配 v
    情况 用户 u 展开 (id, name):
        格式化书写行(&quot;id: {}, 名称: {}&quot;, id, name)
        格式化书写行(&quot;{:?}&quot;, u)
以上
</code></pre>
<pre><code class="language-js">let v = getUserById(123)
match v
    case User u expand (id, name):
        writeLineFormat(&quot;id: {}, name: {}&quot;, id, name)
        writeLineFormat(&quot;{:?}&quot;, u)
end
</code></pre>
<p>显然变量 <code>u</code> 的值就是被匹配变量 <code>v</code> 的值，初看起来 <code>展开</code> 没什么用途，但在 <code>赋值</code> 性质的匹配场合里却非常有意义，比如模式匹配发生在函数的参数，则 <code>展开</code> 关键字加在模式表达式之前，比如：</p>
<pre><code class="language-js">函数 测试 (User u 展开 (id, name))
    ...
以上
</code></pre>
<pre><code class="language-js">function test (User u expand (id, name))
    ...
end
</code></pre>
<p>关键字 <code>展开</code> 也可以写在 <code>解析</code> 匹配里，比如：</p>
<pre><code class="language-js">匹配 v
    情况 解析 用户 u 展开 (id, name):
        ...
以上
</code></pre>
<pre><code class="language-js">match v
    case parse User u expand (id, name):
        ...
end
</code></pre>
<pre><code class="language-js">函数 测试 (解析 User u 展开 (id, name))
    ...
以上
</code></pre>
<pre><code class="language-js">function test (parse User u expand (id, name))
    ...
end
</code></pre>
<p>关键字 <code>展开</code> 也可以写在 <code>正则匹配</code>、<code>模板匹配</code> 里，比如：</p>
<pre><code class="language-js">case regular /^(.+)@(.+)$/ resultList expand [email, name, domain]: // ...
case template `/user/{userName:\w+}` resultList: // ...
</code></pre>
<p>因为 <code>正则匹配</code>、<code>模板匹配</code> 的结果都是字符串数组，所以变量 <code>resultList</code> 也是一个字符串数组，而不是一个元组或者映射表。</p>
<h3 id="嵌套匹配"><a class="header" href="#嵌套匹配">嵌套匹配</a></h3>
<p>可以匹配多层次数据：</p>
<pre><code class="language-js">match a
    case User(name, addr: {city, street}, id):
        ...
</code></pre>
<p><code>regular， in</code> 等关键字也可以用于嵌套内的变量值。</p>
<pre><code class="language-js">match a
    case User(name, score in 60..100):
        # got `name` and `score`
    case User(name regular /^foo/, score):
        # got `name` and `score`
</code></pre>
<h3 id="模式匹配函数-new"><a class="header" href="#模式匹配函数-new">模式匹配函数 (NEW)</a></h3>
<p>如果有一组函数的签名完全一样，即参数列表的参数数量和类型和顺序都一样，且这些函数 <!--加上了标注 `@模式`（`@pattern`）--> 定义语句前添加了 <code>模式</code>（<code>pattern</code>）关键字，则这组函数被称为 <code>模式匹配函数</code>。</p>
<p>普通函数（相对于模式函数来说）的每个参数只能是 <strong>单独的一个变量</strong>，而模式函数在定义参数时，就可以写上模式匹配表达式，通常用这个方法来在接收参数的同时 &quot;解构&quot; 其中的值（比如解构一个结构体、解构一个元组等）。</p>
<p>示例：</p>
<pre><code class="language-js">pattern function check(List&lt;Int&gt; [])
    writeLine(&quot;empty&quot;)
end

pattern function check(List&lt;Int&gt; [1,2])
    writeLine(&quot;there are two expected elements&quot;)
end

pattern function check(List&lt;Int&gt; [a,b])
    writeLine(`there are two elements {a} and {b}`)
end

pattern function check(List&lt;Int&gt; list)
    writeLine(&quot;a list&quot;)
end
</code></pre>
<p>模式函数会被运行环境自动解析为带有模式匹配的分支函数，即上面的代码等同于：</p>
<pre><code class="language-js">function check(List&lt;Int&gt; p) branch
    case let [] match p:
        begin
            writeLine(&quot;empty&quot;)
        end
    case let [1, 2] match p:
        begin
            writeLine(&quot;there are two expected elements&quot;)
        end
    case let [a, b] match p:
        begin
            writeLine(`there are two elements {a} and {b}`)
        end
    case let list match p:
        begin
            writeLine(&quot;a list&quot;)
        end
    end
end
</code></pre>
<p>需要注意，模式匹配函数的各子函数（第一个子函数可以省略）上面的 <code>@模式</code>（<code>@pattern</code>） 标注是必须的，否则运行环境会认为你重复定义了函数，并且会引起运行时错误以阻止运行。</p>
<p>当然模式匹配函数的各子函数里仍然能够使用条件分支，并且在该子函数的条件分支都不满足时，会自动跳到下一个个体，而不是（像分支函数那样）直接出错。也就是说在模式匹配函数里的子函数里的分支是该分支的一道防线（也叫函数守卫、Guard）。</p>
<p>(::TODO)
（::考虑在 pattern 函数里不再支持分支，而是增加 <code>要求</code>（<code>require</code>）关键字。）</p>
<p>示例：</p>
<pre><code class="language-js">function check(List&lt;Int&gt; [])
    writeLine(&quot;empty&quot;)
end

@pattern
function check(List&lt;Int&gt; [a,b]) branch
    case a &gt; b:
        writeLine(&quot;a &gt; b&quot;)
    case a &lt; b:
        writeLine(&quot;a &lt; b&quot;)
end

@pattern
function check(List&lt;Int&gt; list)
    writeLine(&quot;a list&quot;)
end
</code></pre>
<p>会被运行环境解析为：</p>
<pre><code class="language-js">function check(List&lt;Int&gt; p) branch
    case let [] match p:
        begin
            writeLine(&quot;empty&quot;)
        end
    case let [a, b] match p and passed where
        begin
            let (passed, value) = condition
                case a &gt; b:
                    let r = begin
                        writeLine(&quot;a &gt; b&quot;)
                    end
                    (true, r)
                case a &lt; b:
                    let r = begin
                        writeLine(&quot;a &lt; b&quot;)
                    end
                    (true, r)
                end
        end:
        value
    case let list match p:
        begin
            writeLine(&quot;a list&quot;)
        end
    end
end
</code></pre>
<p>注意如果在某个子函数的分支里存在 <code>默认</code>（<code>default</code>） 语句块，则显然一旦该子函数被匹配中，就不会因为分支条件不满足而跳到下一个子函数（因为 <code>默认</code> 语句块无条件接受了所有条件）。</p>
<p>示例：</p>
<pre><code class="language-js">function check(List&lt;Int&gt; [])
    writeLine(&quot;empty&quot;)
end

function check(List&lt;Int&gt; [a,b]) branch
    case a &gt; b:
        writeLine(&quot;a &gt; b&quot;)
    case a &lt; b:
        writeLine(&quot;a &lt; b&quot;)
    default:
        writeLine(&quot;equals&quot;)
end

function check(List&lt;Int&gt; list)
    writeLine(&quot;a list&quot;)
end
</code></pre>
<p>会被运行环境解析为：</p>
<pre><code class="language-js">function check(List&lt;Int&gt; p) branch
    case let [] match p:
        begin
            writeLine(&quot;empty&quot;)
        end
    case let [a, b] match p:
        begin
            condition
                case a &gt; b:
                    begin
                        writeLine(&quot;a &gt; b&quot;)
                    end
                case a &lt; b:
                    begin
                        writeLine(&quot;a &lt; b&quot;)
                    end
                case a &lt; b:
                    begin
                        writeLine(&quot;equals&quot;)
                    end
            end
        end
    case let list match p:
        begin
            writeLine(&quot;a list&quot;)
        end
    end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法范型和特性"><a class="header" href="#方法范型和特性">方法、范型和特性</a></h1>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="method-and-generic-and-trait.html#%E6%96%B9%E6%B3%95-%E8%8C%83%E5%9E%8B%E5%92%8C%E7%89%B9%E6%80%A7">方法、范型和特性</a>
<ul>
<li><a href="method-and-generic-and-trait.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95">数据类型的方法</a>
<ul>
<li><a href="method-and-generic-and-trait.html#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95">添加数据类型的方法</a>
<ul>
<li><a href="method-and-generic-and-trait.html#%E6%9C%AC%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><code>本型</code> 数据类型</a></li>
<li><a href="method-and-generic-and-trait.html#%E6%96%B9%E6%B3%95%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96todo-%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8-%E6%98%8E%E6%96%87%E7%9A%84%E9%83%A8%E5%88%86%E8%B0%83%E7%94%A8-%E6%9B%BF%E4%BB%A3%E6%9F%AF%E9%87%8C%E5%8C%96">方法的柯里化（::TODO 考虑使用 <code>明文的部分调用</code> 替代柯里化）</a></li>
<li><a href="method-and-generic-and-trait.html#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></li>
</ul>
</li>
<li><a href="method-and-generic-and-trait.html#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">实例方法</a>
<ul>
<li><a href="method-and-generic-and-trait.html#%E4%BD%BF%E7%94%A8%E7%82%B9%E5%8F%B7%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">使用点号调用实例方法</a></li>
<li><a href="method-and-generic-and-trait.html#%E5%BC%95%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">引用实例方法</a></li>
<li><a href="method-and-generic-and-trait.html#%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E5%89%8D%E7%BD%AE%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">方法名称前置调用实例方法</a></li>
<li><a href="method-and-generic-and-trait.html#%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E5%89%8D%E7%BD%AE%E8%B0%83%E7%94%A8%E7%9A%84%E6%84%8F%E4%B9%89">方法名称前置调用的意义</a></li>
</ul>
</li>
<li><a href="method-and-generic-and-trait.html#%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%84%E7%BB%87">方法的组织</a></li>
</ul>
</li>
<li><a href="method-and-generic-and-trait.html#%E8%8C%83%E5%9E%8B">范型</a>
<ul>
<li><a href="method-and-generic-and-trait.html#%E7%B1%BB%E5%9E%8B%E5%85%B7%E4%BD%93%E5%8C%96">类型具体化</a></li>
<li><a href="method-and-generic-and-trait.html#%E8%8C%83%E5%9E%8B%E5%87%BD%E6%95%B0">范型函数</a></li>
<li><a href="method-and-generic-and-trait.html#%E8%8C%83%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC">范型的类型自动推导</a></li>
<li><a href="method-and-generic-and-trait.html#%E7%A9%BA%E5%85%83%E7%BB%84-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><code>空元组</code> 数据类型</a></li>
<li><a href="method-and-generic-and-trait.html#%E4%B8%BA%E8%8C%83%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E8%B5%8B%E4%BA%88%E6%96%B9%E6%B3%95">为范型的数据赋予方法</a></li>
<li><a href="method-and-generic-and-trait.html#%E8%8C%83%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%96%B9%E6%B3%95%E5%BD%93%E4%B8%AD%E5%8C%85%E5%90%AB%E5%85%B6%E4%BB%96%E8%8C%83%E5%9E%8B">范型数据方法当中包含其他范型</a></li>
</ul>
</li>
<li><a href="method-and-generic-and-trait.html#%E7%89%B9%E6%80%A7">特性</a>
<ul>
<li><a href="method-and-generic-and-trait.html#%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7">定义特性</a></li>
<li><a href="method-and-generic-and-trait.html#%E8%B5%8B%E4%BA%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E7%89%B9%E6%80%A7">赋予数据类型以特性</a></li>
<li><a href="method-and-generic-and-trait.html#%E8%B5%8B%E4%BA%88%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E7%89%B9%E6%80%A7">赋予泛型数据类型以特性</a></li>
<li><a href="method-and-generic-and-trait.html#%E6%B4%BE%E7%94%9F-%E6%A0%87%E6%B3%A8"><code>派生</code> 标注</a></li>
<li><a href="method-and-generic-and-trait.html#%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96override">方法的覆盖（override）</a></li>
<li><a href="method-and-generic-and-trait.html#%E7%89%B9%E6%80%A7%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%96%B9%E6%B3%95">特性中的空方法</a></li>
<li><a href="method-and-generic-and-trait.html#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B">关联类型</a></li>
<li><a href="method-and-generic-and-trait.html#%E6%B3%9B%E5%9E%8B%E7%89%B9%E6%80%A7">泛型特性</a>
<ul>
<li><a href="method-and-generic-and-trait.html#%E8%B5%8B%E4%BA%88%E6%B3%9B%E5%9E%8B%E7%89%B9%E6%80%A7%E5%88%B0%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">赋予泛型特性到泛型数据类型</a></li>
</ul>
</li>
<li><a href="method-and-generic-and-trait.html#%E5%86%85%E7%BD%AE%E7%89%B9%E6%80%A7">内置特性</a></li>
</ul>
</li>
<li><a href="method-and-generic-and-trait.html#%E7%89%B9%E6%80%A7%E7%BA%A6%E6%9D%9F">特性约束</a>
<ul>
<li><a href="method-and-generic-and-trait.html#%E4%B8%BA%E8%8C%83%E5%9E%8B%E5%87%BD%E6%95%B0%E6%B7%BB%E5%8A%A0%E7%89%B9%E6%80%A7%E7%BA%A6%E6%9D%9F">为范型函数添加特性约束</a></li>
<li><a href="method-and-generic-and-trait.html#%E4%B8%BA%E8%8C%83%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B7%BB%E5%8A%A0%E7%89%B9%E6%80%A7%E7%BA%A6%E6%9D%9F">为范型数据类型添加特性约束</a></li>
<li><a href="method-and-generic-and-trait.html#%E4%B8%BA%E7%89%B9%E6%80%A7%E6%B7%BB%E5%8A%A0%E7%89%B9%E6%80%A7%E7%BA%A6%E6%9D%9F">为特性添加特性约束</a></li>
</ul>
</li>
<li><a href="method-and-generic-and-trait.html#%E7%89%B9%E6%80%A7%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8">特性作为数据类型使用</a></li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->
<h2 id="数据类型的方法"><a class="header" href="#数据类型的方法">数据类型的方法</a></h2>
<p>除了一般用途的函数（即在模块范围内定义的函数），还有一些函数是专门为某些数据类型所使用的。即某个函数跟某个数据类型紧密相关，而跟其他数据类型则关系不大。XiaoXuan 称这种函数为 &quot;数据类型的关联方法&quot;（&quot;data type association method&quot;），或者简称 <code>方法</code>（<code>method</code>）。相应地，其他非数据类型关联方法，即一般函数，可以称为 &quot;自由函数&quot;。</p>
<blockquote>
<p>XiaoXuan 标准库里的大部分函数都是以 &quot;数据类型的方法&quot; 的形式存在，而自由函数很少。</p>
</blockquote>
<blockquote>
<p>XiaoXuan 的数据类型的方法跟面向对象的方法不太一样，数据类型的方法仅仅是一种被自动分配到跟数据类型名称相同的名称空间中的普通函数，在技术上它跟数据类型之间没有关联。</p>
</blockquote>
<h3 id="添加数据类型的方法"><a class="header" href="#添加数据类型的方法">添加数据类型的方法</a></h3>
<p>使用 <code>赋予</code>（<code>assign</code>）(::TODO 考虑使用 <code>实现</code> <code>impl</code> 关键字)语句可以为指定的数据类型添加方法。<!--方法又可以分为 "静态方法" 和 "实例方法" 两种。--> 可以多次使用 <code>赋予</code> 语句为同一个数据类型添加方法。</p>
<p>需注意只能给当前模块的数据类型赋予方法，无法为非当前模块的数据类型赋予方法。比如标准库里有 <code>Int32</code> 类型，除了标准库模块自己，其他模块都无法为它 <code>赋予</code> 更多的方法（但可以添加特性方法，下面章节会讲述）。</p>
<p>示例：</p>
<pre><code class="language-js">赋予 类型名称
    函数 返回值数据类型 函数名称 (数据类型1 参数1, 数据类型2 参数2, ...)
        ...
    以上
以上
</code></pre>
<pre><code class="language-js">assign DataTypeName
    function ReturnDataType functionName (DataType1 param1, DataType2 parsm2)
        ...
    end
end
</code></pre>
<p>调用数据类型的方法跟调用一般函数（自由函数）没什么区别，只是在调用数据类型方法时，需要在方法名称前面添加其所属的数据类型的名称。（当然如果使用 <code>使用</code> 关键字把相关方法导入到当前名称空间，则可以免去这个前缀）</p>
<p>语法：</p>
<ul>
<li><code>数据类型名称::方法名称 (参数值1, 参数值2, ...)</code></li>
<li><code>DataTypeName::functionName (value1, value2, ...)</code></li>
</ul>
<p>即先写出数据类型的名称，然后加两个冒号 <code>::</code>，再写方法的名称。</p>
<p>注意 XiaoXuan 使用的名称空间分隔符是双冒号 <code>::</code>，而不是类似 Java 语言的点号 <code>.</code>。</p>
<p>示例：</p>
<p>现有结构体 <code>学生</code>（<code>Student</code>），要添加一个方法 <code>转换自</code>(<code>convertFrom</code>)，以实现从 <code>用户</code>（<code>User</code>） 类型数据转换到 <code>学生</code> 类型。代码如下：</p>
<pre><code class="language-js">结构体 学生
    整数 编号
    字符串 姓名
以上

赋予 学生
    函数 学生 转换自 (用户 u)
        新建 学生 (u.编号, u.姓名)
    以上
以上
</code></pre>
<pre><code class="language-js">struct Student
    Int id
    String name
end

assign Student
    function Student convertFrom (User u)
        new Student (u.id, u.name)
    end
end
</code></pre>
<p>调用该方法的代码如下：</p>
<ul>
<li><code>让 s1 = 学生::转换自(u1)</code></li>
<li><code>let s1 = Student::convertFrom(u1)</code></li>
</ul>
<h4 id="本型-数据类型"><a class="header" href="#本型-数据类型"><code>本型</code> 数据类型</a></h4>
<p>在为数据类型添加方法时，经常会在参数里出现该数据的自己数据类型，为了简便起见，XiaoXuan 提供一个叫做 <code>本型</code>（<code>Self</code>） 的特殊数据类型，代表着数据自己数据类型。</p>
<p>注意，<code>本型</code> 只是一个代号，并非是一个真正的数据类型，它只能用在数据类型的方法定义上。</p>
<p>示例：</p>
<pre><code class="language-js">赋予 学生
    函数 学生 转换自 (本型 u)
        ...
    以上
以上
</code></pre>
<pre><code class="language-js">assign Student
    function Student convertFrom (Self u)
        ...
    end
end
</code></pre>
<p>上例中的 <code>本型</code>（<code>Self</code>）代表着 <code>Student</code> 这个数据类型，语法解析器会自动把 <code>本型</code> 替换成实际类型，为了统一起见，XiaoXuan 推荐使用 <code>本型</code> 代替所有在数据类型方法中出现的自身数据类型，而不建议直接写具体的数据类型。</p>
<h4 id="方法的柯里化todo-考虑使用-明文的部分调用-替代柯里化"><a class="header" href="#方法的柯里化todo-考虑使用-明文的部分调用-替代柯里化">方法的柯里化（::TODO 考虑使用 <code>明文的部分调用</code> 替代柯里化）</a></h4>
<p>当方法有多个参数时，一般习惯上把 <code>本型</code> 参数放在参数列表的最后一个，这样的目的是为了让方法可以实现柯里化，即为方法提供部分调用的能力。也就是说，方法的最后一个参数一般代表着 &quot;数据&quot;，而前面的参数一般代表着 &quot;选项&quot;。</p>
<p>示例：</p>
<pre><code class="language-js">赋予 字符串
    # 数据类型方法
    函数 字符串 替换(正则 r, 字符串 s, 本型 self)
        ...
    以上

    # 柯里化的第 1 个方法重载
    函数 字符串 替换(正则 r, 字符串 s)
        匿名函数 (本型 self) = 替换(r, s, self)
    以上

    # 柯里化的第 2 个方法重载
    函数 字符串 替换(正则 r)
        匿名函数 (String s) = 替换(r, s)
    以上
以上
</code></pre>
<pre><code class="language-js">assign String
    # data type method
    function String replace(Regex r, String s, Self self)
        ...
    end

    # curry method overload 1
    function String replace(Regex r, String s)
        fn (Self self) = replace(r, s, self)
    end

    # curry method overload 1
    function String replace(Regex r)
        fn (String s) = replace(r, s)
    end
end
</code></pre>
<p>函数柯里化之后，有时能简化调用的代码。</p>
<p>示例：</p>
<pre><code class="language-js">让 姓名 = &quot;foo bar&quot;
让 地址 = &quot;abc def ghi&quot;

让 替换空格 = 字符串::替换(/\s+/, &quot;_&quot;)
让 n = 替换空格(姓名)
让 a = 替换空格(地址)
</code></pre>
<pre><code class="language-js">let name = &quot;foo bar&quot;
let addr = &quot;abc def ghi&quot;

let replace_space = String::replace(/\s+/, &quot;_&quot;)
let n = replace_space(name)
let a = replace_space(addr)
</code></pre>
<p>为了节省手动添加柯里化的方法重载，可以使用 <code>@柯里化</code>（<code>@curry</code>） 标注，把它标注在一个完整参数的函数上，运行环境会自动帮我们生成它的所有柯里化的方法重载。</p>
<p>比如上例当中的 3 个函数定义语句，实际上只需书写第 1 个。</p>
<p>示例：</p>
<pre><code class="language-js">赋予 字符串
    @柯里化
    函数 字符串 替换(正则 r, 字符串 s, 本型 self)
        ...
    以上
</code></pre>
<pre><code class="language-js">assign String
    @curry
    function String replace(Regex r, String s, Self self)
        ...
    end
end
</code></pre>
<h4 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h4>
<p>在结构体一章提到，其实构造函数就是数据类型的方法，其名称为 <code>新建</code>（<code>new</code>），运行环境会为每一个构造体自动生成一个默认的构造函数。比如上例的 <code>学生</code> 结构体，其自动生成的构造函数如下：</p>
<pre><code class="language-js">赋予 学生
    # 运行环境内部自动生成的代码
    本型 新建 (整数 编号, 字符串 姓名)
        ...
    以上
以上
</code></pre>
<pre><code class="language-js">assign Student
    # automatically generated code by the runtime
    Self new (Int id, String name)
        ...
    end
end
</code></pre>
<p>使用方法实例化一个结构体的代码如下：</p>
<ul>
<li><code>让 s = 学生::新建 (123, &quot;foo&quot;)</code></li>
<li><code>let s = Student::new (123, &quot;foo&quot;)</code></li>
</ul>
<p>XiaoXuan 提供了一个语法糖，可以 &lt;!-- 使用 <code>新建</code>（<code>new</code>）关键字来调用数据关联的 <code>新建</code> 方法：</p>
<ul>
<li><code>让 s = new 学生 (123, &quot;foo&quot;)</code></li>
<li><code>let s = new Student (123, &quot;foo&quot;)</code>
--&gt;</li>
</ul>
<p>直接将数据类型作为方法名称以调用构造函数，比如：</p>
<ul>
<li><code>让 s = 学生 (123, &quot;foo&quot;)</code></li>
<li><code>let s = Student (123, &quot;foo&quot;)</code></li>
</ul>
<h3 id="实例方法"><a class="header" href="#实例方法">实例方法</a></h3>
<p>实例方法就是一个数据类型方法当中的<strong>第一个参数</strong>的数据类型为 <code>本型</code> 的函数。相应地，非实例方法我们可以称之为 &quot;一般方法&quot;。</p>
<p>比如要在上例的 <code>学生</code> 结构体里添加一个 <code>显示姓名</code>（<code>showName</code>）的实例方法，用于显示学生的姓名，则代码如下：</p>
<pre><code class="language-js">赋予 学生
    函数 显示姓名 (本型 s)
        书写行 (!&quot;我的名字是 {s.name}&quot;)
    以上
以上
</code></pre>
<pre><code class="language-js">assign Student
    function showName(Self s)
        writeLine(!&quot;My name is {s.name}&quot;)
    end
end
</code></pre>
<p>调用 &quot;实例方法&quot; 的方法跟调用 &quot;一般方法&quot; 一样，只不过需要把数据实例作为第一个参数传入而已。</p>
<p>示例：</p>
<pre><code class="language-js">让 s = 新建 学生 (123, &quot;foo&quot;)
学生::显示姓名 (s)
</code></pre>
<pre><code class="language-js">let s = new Student (123, &quot;foo&quot;)
Student::showName (s)
</code></pre>
<p>注意：</p>
<ul>
<li>实例方法也允许有多个参数，但 <code>本型</code> 类型必须放在第 1 位；</li>
<li>实例方法一般不提供柯里化重载；</li>
<li>如果某个数据类型方法刚好只有一个参数，且其类型刚好是 <code>本型</code>，那么它既是 &quot;一般方法&quot; 也是 &quot;实例方法&quot;，其实无论是那种类型的方法，都是普通函数，只不过是我们约定俗成地按照某种特征为它们分类而已。</li>
</ul>
<h4 id="使用点号调用实例方法"><a class="header" href="#使用点号调用实例方法">使用点号调用实例方法</a></h4>
<p>对于实例方法，除了可以使用 &quot;一般方法&quot; 的格式来调用之外，还支持使用 &quot;点号调用&quot; 方式。格式是：</p>
<p><code>数据实例 .方法名称 (参数值1, 参数值2, ...)</code></p>
<p>它其实是数据类型方法调用的语法糖，即等同于：</p>
<p><code>数据类型名称::方法名称 (数据实例, 参数值1, 参数值2, ...)</code></p>
<p>习惯性将方法名称之前的点号跟数据实例连在一起写，即中间不加空格，比如：</p>
<p><code>数据实例.方法名称 (参数值1, 参数值2, ...)</code></p>
<p>因为使用点号调用格式可以省略书写数据类型名称，且显得该方法跟数据紧密相关（就像是这个数据的成员一样），所以一般使用 &quot;点号调用&quot; 方式来调用实例方法。</p>
<p>示例：</p>
<pre><code class="language-js">让 s = 新建 学生 (123, &quot;foo&quot;)
s .显示姓名 ()
s.显示姓名 ()
</code></pre>
<pre><code class="language-js">let s = new Student (123, &quot;foo&quot;)
s .showName ()
s.showName ()
</code></pre>
<h4 id="引用实例方法"><a class="header" href="#引用实例方法">引用实例方法</a></h4>
<!--
当我们使用 "点号调用" 的格式实行 "方法引用" 而非 "方法调用" 时，比如把它赋值给一个变量，或者作为参数传递给另外一个函数，运行环境会自动把它转换为一个绑定了数据实例的匿名函数。
-->
<p>虽然点号 &quot;.&quot; 同时也用来访问表示数据类型的成员，比如 <code>学生实例.姓名</code> 表示 <code>学生</code> 这个结构体的 <code>姓名</code> 成员，但点号调用当中的点号并非表示数据类型的成员，比如语句 <code>学生实例.显示姓名</code> 是错误的，它无法代表 <code>学生::显示姓名</code> 函数。</p>
<p>示例：</p>
<!--
```js
让 s = 新建 学生 (123, "foo")
让 f = s.显示姓名

# 调用引用的方法
f()
```

```js
let s = new Student (123, "foo")
let f = s.showName

# invoke the referenced method
f()
```

在这个例子里，变量 `f` 的值实际是：

* `匿名函数 () = 学生::显示姓名(s)`
* `fn () = Student::showName(s)`
-->
<pre><code class="language-js">让 s = 学生 (123, &quot;foo&quot;)
让 f = s.显示姓名
</code></pre>
<p>上面代码的第二句会引起语法错误（注意在某些编程语言里这样的写法是允许的，比如 JavaScript）。如果有时确实需要引用某个数据类型的方法（无论是普通方法还是实例方法），只能以数据类型方法的完整形式书写，即 <code>让 f = 数据类型名称::方法名称</code>。</p>
<h4 id="方法名称前置调用实例方法"><a class="header" href="#方法名称前置调用实例方法">方法名称前置调用实例方法</a></h4>
<p>除了使用 &quot;一般方法调用风格&quot; 和 &quot;点号调用风格&quot;，XiaoXuan 还支持使用 &quot;方法名称前置&quot; 这种格式来调用实例方法。</p>
<p>格式是在方法名称后面前面加上单引号（<code>'</code>），然后使用像自由函数方式书写调用语句。</p>
<p>比如 <code>学生::显示姓名 (s)</code> 语句，可以直接省略 <code>学生</code> 这个数据类型直接写成 <code>!显示姓名(s)</code>。</p>
<p>所以下面的 3 行语句是等效的：</p>
<pre><code class="language-js">01  学生::显示姓名(s)
03  s.显示姓名()
02  !显示姓名(s)
</code></pre>
<pre><code class="language-js">01  Student::showName(s)
03  s.showName()
02  !showName(s)
</code></pre>
<p>显然实例方法名称前置调用又是个语法糖，比如 <code>!name(s)</code> 语句会被解析成 <code>s.name()</code>，然后进一步解析为 <code>Student::name(s)</code>。</p>
<!--
> 注意使用名称前置格式调用方法时，名称前面不能加上任何前缀。

隠式调用的规则是：对于代码中出现的一般函数（即在函数名称前面无双冒号或点号）调用语句，运行环境会先根据名字查找当前上下文是否存在指定的函数，如果存在则调用它。如果不存在则根据第一个参数查找该数据类型是否存在同名的实例方法（包括下面讲到的特性方法），如果存在则使用该实例方法。
-->
<!--
比如对于表达式：

`2 + 3`

根据中置函数调用原则，上面的表达式会被翻译为：

`Int::add (2, 3)`

而 `add` 函数不是自由函数，也就是说它没有默认地被导入到当前的上下文，于是运行环境查找第一个参数的数据类型，即 `Int` 是否存在 `add` 实例方法。结果它找到了 `Int::add(Self left, Int right)`，于是最后语句被翻译为：

`Int::add(2, 3)`

注意使用隐式调用实例方法存在一定的名称冲突的风险，也就是说，如果恰好当前上下文存在一个 `显示姓名` 的函数，则运行环境执行到 `显示姓名 (s)` 这一行时，会优先使用当前上下文的 `显示姓名` 函数，这可能会导致非预期的结果。

在当前上下文存在同名函数的情况，如果确实要调用实例方法，这时只能把 "隐式调用" 改成实例方法的一般的 "点号调用" 方式即可。

幸好

> XiaoXuan 标准库的大部分函数都是以实例的方法形式存在，默认情况下被导入到当前上下文的自由函数很少。
-->
<h4 id="方法名称前置调用的意义"><a class="header" href="#方法名称前置调用的意义">方法名称前置调用的意义</a></h4>
<p>使用名称前置的格式调用实例方法比较接近动态脚本语言的风格。比如 <code>List&lt;Real&gt;</code> 和 <code>Matrix&lt;Real&gt;</code> 都实现了 <code>向上取整</code>（<code>ceil</code>） 方法，下面是点号方式调用和名称前置调用的比较：</p>
<pre><code class="language-js"># 点号调用风格

让 lc = l.向上取整()
让 mc = m.向上取整()

# 方法名称前置调用风格

让 lc = !向上取整(l)
让 mc = !向上取整(m)
</code></pre>
<pre><code class="language-js"># dot call style

let lc = l.ceil()
let mc = m.ceil()

# ...

let lc = !ceil(l)
let mc = !ceil(m)
</code></pre>
<p>显然，对于一般性的函数（比如数学函数）使用 &quot;名称前置&quot; 风格显得意义更明确。</p>
<h3 id="方法的组织"><a class="header" href="#方法的组织">方法的组织</a></h3>
<p>正如前面提到，标准库很多函数都是以 &quot;依附&quot; 到各个数据类型当中作为数据类型的关联函数的方式而存在，通用的数据类型其方法一般会提供 &quot;一般方法&quot; 和 &quot;实例方法&quot; 两个版本。而 &quot;一般方法&quot; 有时还会提供柯里化的重载，方法的实现代码主要都是写在 &quot;一般方法&quot; 之中，而 &quot;实例方法&quot; 内部则仅仅是调用其相应的 &quot;一般方法&quot;。</p>
<p>示例：</p>
<pre><code class="language-js">赋予 字符串
    # 一般方法
    @柯里化
    函数 字符串 替换(正则 r, 字符串 s, 本型 self)
        ...
    以上

    # 实例方法
    函数 字符串 替换(本型 self, 正则 r, 字符串 s)
        替换(r, s, self)
    以上
以上
</code></pre>
<pre><code class="language-js">assign String
    # normal method
    @curry
    function String replace(Regex r, String s, Self self)
        ...
    end

    # instance method
    function String replace(Self self, Regex r, String s)
        replace(r, s, self)
    end
end
</code></pre>
<h2 id="范型"><a class="header" href="#范型">范型</a></h2>
<p>范型（Generic）是生成代码的模板，用于避免重复写 &quot;仅数据类型不同&quot; 的代码，结构体、联合体、函数都支持范型。</p>
<p>示例，有如下两个结构体：</p>
<pre><code class="language-js">结构体 整数点坐标
    整数 x
    整数 y
以上

结构体 浮点数点坐标
    实数 x
    实数 y
以上
</code></pre>
<pre><code class="language-js">struct IntPoint
    Int x
    Int y
end

struct FloatPoint
    Real x
    Real y
end
</code></pre>
<p>它们的结构一样，仅数据类型不同，所以可以使用范型改写，代码如下：</p>
<pre><code class="language-js">结构体 点坐标&lt;甲型&gt;
    甲型 x
    甲型 y
以上
</code></pre>
<pre><code class="language-js">struct Point&lt;T&gt;
    T x
    T y
end
</code></pre>
<p>其中一对尖括号里面列出该结构体（或者联合体、函数）所有使用到的类型的代号（简称 &quot;类型代号&quot;）。然后把尖括号写在结构（或联合体、函数）名称之后。</p>
<p>类型代号中文一般使用 &quot;甲型&quot;、&quot;乙型&quot;、&quot;丙型&quot;、&quot;丁型&quot;，或者直接使用 &quot;甲、乙、丙、丁、戊、己、庚、辛、壬、癸&quot;，英文则使用单个大写的字母，比如 &quot;T&quot;、&quot;E&quot;、&quot;R&quot;、&quot;M&quot; 等，在语法上代号的写法无特殊的要求，只是传统上使用这样的写法。多个类型代号之间使用逗号分隔，比如 <code>结构体&lt;甲, 已, 丙&gt; 点坐标</code>。</p>
<h3 id="类型具体化"><a class="header" href="#类型具体化">类型具体化</a></h3>
<p>在实例化带有范型的结构体时，需要用实际的数据类型替代类型代号，我们将这个过程称之为<strong>类型具体化</strong>。</p>
<p>示例：</p>
<pre><code class="language-js">让 p1 = 新建 点坐标&lt;整数&gt; (10, 20)
让 p2 = 新建 点坐标&lt;实数&gt; (2.718, 1.618)
</code></pre>
<pre><code class="language-js">let p1 = new Point&lt;Int&gt; (10, 20)
let p2 = new Point&lt;Real&gt; (2.718, 1.618)
</code></pre>
<blockquote>
<p>泛型的每个具体类型都可以认为是完全不相干的类型，比如 <code>Point&lt;Int&gt;</code> 和 <code>Point&lt;Real&gt;</code> 可以认为是两个完全不同的类型；运行环境会为它们各自生成不同的代码，方法是 <!--把它们的名称当中的尖括号去掉，--> 创建一个具体类型的子命名空间，子命名空间的名称为具体类型的名称（如果有多个具体类型，则使用减号 <code>-</code> ———— 这是一个运行环境内部作为转义字符使用的符号，一个不允许用户用于定义数据类型的符号————进行连接），比如上例会生成 <!-- 数据类型的名称和具体类型的名称，则这两个类型就变成--> <code>Point::std-Int::Point</code> 和 <code>Point::std-Real::Point</code>，然后把代码都 &quot;复制，替换，粘贴（把类型代号替换成目标类型）&quot; 一遍。如下：</p>
</blockquote>
<pre><code class="language-js">namespace Point::std-Int

struct Point
    Int x
    Int y
end

namespace Point::std-Real

struct Point
    Real x
    Real y
end
</code></pre>
<p>实例化结构体时的实际代码：</p>
<pre><code class="language-js">let p1 = Point::std-Int::Point::new (10, 20)
let p2 = Point::std-Real::Point::new (2.718, 1.618)
</code></pre>
<p>可见使用泛型可以避免大量的手动编码。</p>
<blockquote>
<p>注意，减号是不允许出现在变量或者数据类型的名称里，所以用户是没法按照上面的格式书写代码。</p>
</blockquote>
<p>如果数据类型的泛型代号有多个，则会根据实际情况生成相应的具体类型，比如 <code>Point&lt;T, E&gt;</code> 针对 <code>Point&lt;Int, Real&gt;</code> 会生成 <code>Point::Point-Int-Real</code>。</p>
<h3 id="范型函数"><a class="header" href="#范型函数">范型函数</a></h3>
<p>范型也可以应用在函数上，跟应用到结构体类似，也是在一对尖括号列出该函数所有用到的数据类型。示例：</p>
<pre><code class="language-js">函数 最大值&lt;甲型&gt;(甲型 左, 甲型 右)
    如果 左 &gt; 右 那么
        左
    否则
        右
    以上
以上
</code></pre>
<pre><code class="language-js">function max&lt;T&gt;(T left, T right)
    if left &gt; right then
        left
    else
        right
    end
end
</code></pre>
<p>在调用范型函数时，将实际数据类型替代类型代号，示例：</p>
<pre><code class="language-js">让 a = 最大值&lt;整数&gt; (12, 34)
让 b = 最大值&lt;实数&gt; (3.142, 2.718)
</code></pre>
<pre><code class="language-js">let a = max&lt;Int&gt; (12, 34)
let b = max&lt;Real&gt; (3.142, 2.718)
</code></pre>
<p>跟泛型数据类型类似，当泛型函数被调用时，数据类型则会被具体化，运行环境实际上是生成多份完全不相干的函数复制。比如上例的两个 <code>max</code> 函数调用，实际上是生成如下两个函数：</p>
<pre><code class="language-js">function max-Int(Int x, Int y)
    ...
end

function max-Real(Real x, Real y)
    ...
end
</code></pre>
<p>调用语句的实际代码：</p>
<pre><code class="language-js">let a = max-Int(12, 34)
let b = max-Real(3.142, 2.718)
</code></pre>
<p>可见泛型函数不是方法重载。</p>
<!--，比如：

有范型函数 "sum" 的定义如下：

```js
function T sum<T>(List<T> numbers) type
    T limit Add
    let default = T.default()
    fold(numbers, (i, sum) => i + sum, default)
end
```

当使用不同的类型调用（比如分别使用 Int 和 Real 类型调用）该函数时，范型函数的两次调用可以认为是两个不相干的函数，也可以认为是一份（函数）代码更改了类型然后复制了一份。示例：

```js
let a1 = [1,2,3,4,5]
let a2 = [1.0, 2.1, 3.2, 4.3, 5.4]

# 调用了函数 function Int sum<Int>(List<Int> numbers) ...
let s1 = sum(a1)

# 调用了函数 function Real sum<Real>(List<Real> numbers) ...
let s2 = sum(a2)
```
-->
<p>对于范型函数，只有参数类型（而不是类型代号）不同时，才是函数重载。</p>
<p>示例：</p>
<pre><code class="language-js">function T sum&lt;T&gt;(List&lt;T&gt; numbers)...
function T sum&lt;T&gt;(Matrix&lt;T&gt; numbers) ...
</code></pre>
<h3 id="范型的类型自动推导"><a class="header" href="#范型的类型自动推导">范型的类型自动推导</a></h3>
<p>XiaoXuan 的自动类型推导机制在范型里同样有效，也就是说，在实例化范型结构体、调用范型函数时，运行环境会尽可能地推导出正确的数据类型，而在写代码时就可以省略类型了。</p>
<p>示例，上面的实例化结构体和调用函数可以写成如下：</p>
<pre><code class="language-js">让 p1 = 新建 点坐标 (10, 20)
让 p2 = 新建 点坐标 (2.718, 1.618)
让 a = 最大值 (12, 34)
让 b = 最大值 (3.142, 2.718)
</code></pre>
<pre><code class="language-js">let p1 = new Point (10, 20)
let p2 = new Point (2.718, 1.618)
let a = max (12, 34)
let b = max (3.142, 2.718)
</code></pre>
<p>上面的代码都省略了具体的数据类型。因为在实例化结构体（或者调用函数）时，运行环境会根据成员（参数）传入的实际数据（实参）来推导其数据类型，然后将这个数据类型替换类型代号，再使用这个类型代号应用到整个结构体（或函数），如此类推。</p>
<h3 id="空元组-数据类型"><a class="header" href="#空元组-数据类型"><code>空元组</code> 数据类型</a></h3>
<p>有时具体化一个泛型数据类型时，可能会遇到对具体类型不感兴趣的场景。比如在具体化 <code>Result&lt;T, E&gt;</code> 时，如果一个函数成功时无任何有意义的返回值，但希望能传回错误数据，这时可以使用 <code>空元组</code>（<code>Unit</code>） 数据类型具体化第一个泛型代号，空元型数据类型只有一个值 <code>空元</code>（<code>Empty</code>），其字面值是一对空括号 <code>()</code>，理解为空元组。</p>
<p>示例：</p>
<pre><code class="language-js">function Result&lt;Unit, std::io::Error&gt; saySomethine()
    # do something
    if errorOccured then
        Err(someError)
    else
        Ok(Empty)  # or `Ok(())`
    end
end
</code></pre>
<p>注意 XiaoXuan 的 <code>Unit::Empty</code> 跟其他编程语言的 <code>Null</code> 不是同一个概念，其他语言 <code>Null</code> 可能表示空指针或者空对象，在 XiaoXuan 里相似的数据类型是 <code>Option::None</code>。而 XiaoXuan 的 <code>Unit::Empty</code> 只能赋值给 <code>Unit</code> 数据类型，它表示的是一个空元组（一对空括号）。</p>
<!-- 在内置数据类型里还有一个叫 `Result<T>` 的数据类型，它是 `Result<T, std::io::Error>` 的别名，-->
<h3 id="为范型的数据赋予方法"><a class="header" href="#为范型的数据赋予方法">为范型的数据赋予方法</a></h3>
<p>在为具有范型的数据赋予方法时，需要注意是赋予给具体的某个数据类型，还是赋予给范型。比如上例的 <code>点坐标&lt;甲型&gt;</code>，现在需要添加 <code>显示坐标</code>（<code>showPoint</code>）实例方法，注意下面的两个赋予语句。</p>
<pre><code class="language-js">赋予 点坐标&lt;整数&gt;
    函数 显示坐标(本型 p)
        ...
    以上
以上

赋予&lt;甲型&gt; 点坐标&lt;甲型&gt;
    函数 显示坐标(本型 p)
        ...
    以上
以上
</code></pre>
<pre><code class="language-js">assign Point&lt;Int&gt;
    function showPoint(Self p)
        ...
    end
end

assign&lt;T&gt; Point&lt;T&gt;
    function showPoint(Self p)
        ...
    end
end
</code></pre>
<p>上面两个赋予语句非常相似，第二个仅仅在 <code>赋予</code> 关键字多了 &quot;&lt;甲型&gt;&quot;，但它们的意义完全不一样：</p>
<ul>
<li>第一个赋予语句仅仅为 <code>点坐标&lt;整数&gt;</code> 这种整数类型点坐标赋予了 <code>显示坐标</code> 方法，<code>本型</code> 代表的是 <code>点坐标&lt;整数&gt;</code> 这种特定类型；</li>
<li>第二个赋予语句则为 <code>点坐标</code> 范型（即任意具体类型的点坐标）赋予 <code>显示坐标</code> 方法，<code>本型</code> 代表的是 <code>点坐标&lt;甲型&gt;</code> 这种范型。</li>
</ul>
<p>注意第二个赋予语句不能写成 <code>赋予 点坐标&lt;甲型&gt;</code>，因为 XiaoXuan 不知道这个 <code>甲型</code> 究竟是具体数据类型的名称，还是泛型名称（即类型代号）。当然如果确实存在一个名字为 &quot;甲型&quot; 的数据类型，则这个赋予语句是合法的，如果不存在，则会抛出运行时错误。</p>
<p>如果要为结构体范型本身赋予方法，则需要在 <code>赋予</code> 关键字后面同样加上一对尖括号，然后把所有用到的类型代号列出。</p>
<h3 id="范型数据方法当中包含其他范型"><a class="header" href="#范型数据方法当中包含其他范型">范型数据方法当中包含其他范型</a></h3>
<p>有时在方法当中会传入其他范型的数据，这些额外的范型只需在方法的类型代号列表中列出即可，而不需要在 <code>赋予</code> 关键字后面的类型代号列表中列出。</p>
<p>示例，现在添加 <code>加</code>（<code>add</code>）方法到 <code>点坐标</code> 结构体，该方法接受另外一个点坐标类型的参数，但不要求这个点坐标的类型跟当前点坐标类型一致，代码如下：</p>
<pre><code class="language-js">赋予&lt;甲型&gt; 点坐标&lt;甲型&gt;
    函数 本型 加&lt;甲型, 乙型&gt; (本型 left, 点坐标&lt;乙型&gt; right)
        新建 本型 (
            left.x + right.x,
            left.y + right.y
            )
    以上
以上
</code></pre>
<pre><code class="language-js">assign&lt;T&gt; Point&lt;T&gt;
    function Self showPoint&lt;T, E&gt; (Self left, Point&lt;E&gt; right)
        new Self(
            left.x + right.x,
            left.y + right.y
            )
    end
end
</code></pre>
<p>注意：</p>
<ul>
<li>代码中，<code>赋予</code> 后面的类型代号列表只有 <code>甲型</code>，表明这个赋予语句是只针对 <code>点坐标&lt;甲型&gt;</code>，而方法名称后面的类型列表里有 <code>甲型</code> 和 <code>乙型</code>，说明这个方法将会使用到 <code>甲型</code> 和 <code>乙型</code> 两种数据类型。</li>
<li>代码中的 <code>新建 本型</code>（<code>new Self</code>）是合法的，在上例中，它代表着 <code>新建 点坐标&lt;甲型&gt;</code>（<code>new Point&lt;T&gt;</code>）。</li>
</ul>
<h2 id="特性"><a class="header" href="#特性">特性</a></h2>
<p><code>特性</code>（<code>trait</code>）是指多个类型数据共同具有的特性、或者共同具有的行为。</p>
<p>比如部分数据具有一个叫做 <code>可显示</code>（<code>Display</code>） 的特性，表示这类数据可以转换为字符串并提供给诸如 <code>书写行</code>（<code>writeLine</code>）等函数使用；又比如部分数字类型数据具有一个叫做 <code>可排序</code>（<code>Ordered</code>）的特性，表示这类数据可以通过 <code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code> 等函数进行大小比较。</p>
<p>特性在具体实现上，就是一组函数。</p>
<h3 id="定义特性"><a class="header" href="#定义特性">定义特性</a></h3>
<p>使用 <code>特性</code>（<code>trait</code>）关键字可以定义一个特性。</p>
<p>示例，假设有两个结构体 <code>用户</code>（<code>User</code>） 和 <code>学生</code>（<code>Student</code>），其都有一个名为 <code>姓名</code>（<code>name</code>）的成员。现要为它们都添加一个名为 <code>显示姓名</code>（<code>showName</code>） 的方法，则可以定义一个名字比如 <code>具名</code>（<code>Named</code>）的特性:</p>
<pre><code class="language-js">特性 具名
    函数 显示名字(本型 s)
        书写行 (s.姓名)
    以上
以上
</code></pre>
<pre><code class="language-js">trait Named
    function showName(Self s)
        writeLine (s.name)
    end
end
</code></pre>
<p>因为特性会被赋予给具体的数据类型，所以跟数据的实例方法类似，函数的第一个参数必须是其所属的数据的类型，但在定义特性时不知道它最后会被应用到哪个数据类型，所以使用 <code>本型</code>（<code>Self</code>）来代表将来会被应用到的数据类型。</p>
<blockquote>
<p>&quot;特性的定义&quot; 或者 &quot;目标数据类型的定义&quot;，两者中至少有一项必须在当前模块范围之内，才能在当前模块实现赋予方法。也就是说，如果某个特性和某个数据类型都是在其他模块，你是无法把那个特性赋予给那个数据类型的。</p>
</blockquote>
<h3 id="赋予数据类型以特性"><a class="header" href="#赋予数据类型以特性">赋予数据类型以特性</a></h3>
<p>示例：</p>
<p>赋予 <code>具名</code> 这个特性给结构体 <code>用户</code>（<code>User</code>） 和 <code>学生</code>（<code>Student</code>）：</p>
<pre><code class="language-js">赋予 用户 特性 具名
    # 这里无代码
以上

赋予 学生 特性 具名
    # 这里无代码
以上
</code></pre>
<pre><code class="language-js">assign User trait Named
    # no code here
end

assign Student trait Named
    # no code here
end
</code></pre>
<p>之后 <code>用户</code> 和 <code>学生</code> 示例都具有 <code>显示名字</code> 方法。</p>
<p>示例：</p>
<pre><code class="language-js">让 u = 新建 用户(123, &quot;foo&quot;)
让 s = 新建 学生(456, &quot;bar&quot;)
u.显示名字()
s.显示名字()
</code></pre>
<pre><code class="language-js">let u = new User(123, &quot;foo&quot;)
let s = new Student(456, &quot;bar&quot;)
u.showName()
s.showName()
</code></pre>
<p>需注意，可以赋予一个或多个特性给一个数据类型，换句话说，一个数据类型可以同时具有一个或多个特性。只需每个特性都使用 <code>赋予</code> 语句赋予到指定的目标数据类型即可。</p>
<blockquote>
<p>一个特性只能赋予<strong>一次</strong>给一个数据类型，也就是说，当使用 <code>赋予</code> 语句赋予一个特性到一个数据类型时，需要<strong>一次过</strong>把所有空方法都补齐，不能分多次书写。</p>
</blockquote>
<p>调用数据的特性方法时，需要把它具有的那个特性使用 <code>使用</code>（<code>use</code>）关键字导入到当前名称空间，否则使用不了。之所以有这个要求，是因为一个数据类型可能被赋予了多种不同的特性，如果这些特性刚好有重名的函数（同时参数列表相同，或者返回值不同）就会造成冲突，为了避免使用点号方式调用方法时的冲突，XiaoXuan 规定只有把数据类型所具有的特性导入到当前名称空间，则该特性的方法才可以使用。</p>
<p>也就是说，跟 <code>赋予</code> 语句为数据类型添加方法不同，<code>赋予</code> 数据类型的特性的方法的实现是放在 &quot;特性的名称::数据类型名称&quot; 的命名空间之下的，而数据方法是放在 &quot;数据类型名称&quot; 的命名空间之下。</p>
<p>所以上面例子的 <code>显示名字</code> 函数调用，实际上会被解析器转换特性的一般方法调用（即普通的函数调用）：</p>
<pre><code class="language-js">let u = new User(123, &quot;foo&quot;)
let s = new Student(456, &quot;bar&quot;)

Named::User::showName(u)     #  u.showName()
Named::Student::showName(s)  #  s.showName()
</code></pre>
<p>使用特性的一般方法调用方式可以解决方法冲突的问题。比如一个数据类型被赋予了两个特性，而这两个特性刚好有 &quot;同名、同参数、不同返回值类型&quot; 的方法，当把这两个特性都引入到当前名称空间时，显然直接使用数据的点号方法调用会引起运行时异常（因为解析器不知道该调用哪个特性的方法），这时可以把点号方法调用改为特性的一般方法调用。</p>
<h3 id="赋予泛型数据类型以特性"><a class="header" href="#赋予泛型数据类型以特性">赋予泛型数据类型以特性</a></h3>
<p>::TODO</p>
<p>一般需要为数据类型的泛型加上特性约束，否则会因为泛型名称（类型代号）无方法可用而变得没什么用途。</p>
<p>示例：</p>
<pre><code class="language-js">assign&lt;T&gt; Point&lt;T&gt; trait Display type
    T limit Display

    function toString(Self p)
        let sx = p.x.toString()
        let sy = p.y.toString()
        &quot;Point {x=&quot; ++ sx ++ &quot;, y=&quot; ++ sy ++ &quot;}&quot;
    end
end
</code></pre>
<h3 id="派生-标注"><a class="header" href="#派生-标注"><code>派生</code> 标注</a></h3>
<p>当赋予一个全部方法都<strong>非空</strong>的特性给一个数据类型时，除了使用 <code>赋予</code> 语句，还可以简单地使用 <code>派生</code>（<code>derive</code>） 标注直接在数据类型（比如结构体）上标注，使用标注的好处是避免写一个空主体的 <code>赋予</code> 语句，下面使用标注的方法重写前面第而个例子：</p>
<pre><code class="language-js">@派生(具名)
结构体 学生
    整数 编号
    字符串 姓名
以上
</code></pre>
<pre><code class="language-js">@derive(Named)
struct Student
    Int id
    String name
end
</code></pre>
<p>如果要赋予多个特性给一个数据类型，则在 <code>派生</code> 标注内，把所有特性名称列出，并使用逗号 &quot;,&quot; 分隔每个特性名称。</p>
<p>示例：</p>
<pre><code class="language-js">@派生(具名, 可显示, 可相等比较, 可大小比较)
结构体 学生
    整数 编号
    字符串 姓名
以上
</code></pre>
<h3 id="方法的覆盖override"><a class="header" href="#方法的覆盖override">方法的覆盖（override）</a></h3>
<p>当将一个特性赋予给某个数据类型时，可以在具体的 <code>赋予</code> 语句重写特性中已存在的方法。</p>
<p>比如在上例的 <code>学生</code> 里，我们可以覆盖方法 <code>显示名字</code>：</p>
<p>TODO::</p>
<h3 id="特性中的空方法"><a class="header" href="#特性中的空方法">特性中的空方法</a></h3>
<p>更多的时候，我们只在特性中定义需要的方法，而具体的方法代码则由实现赋予方法时才书写。这时侯，特性更多起一种 &quot;接口&quot; 作用。也就是说，我们定义特性时，只需描述我们所需要的大概轮廓，而具体实现则留给后面才做。</p>
<p>具体来说，我们只需在特性里确定方法的名称和签名，而方法主体则留空，这种方法叫做 &quot;空函数&quot;（或者说 &quot;空方法&quot;，相当于 Java 里的抽象方法），然后等到在书写 <code>赋予</code> 过程再写函数的具体实现代码。</p>
<p>&quot;空函数&quot; 跟普通函数一样，除了：</p>
<ol>
<li>函数没有主体代码；</li>
<li>定义函数的语句最签名添加 <code>空</code>（<code>empty</code>） 关键字。</li>
</ol>
<p>示例，现在在上例中的 <code>具名</code> 特性中添加 <code>显示摘要</code>（<code>showSummary</code>）方法：</p>
<pre><code class="language-js">01  特性 具名
02      函数 显示名字(本型 s)
03          书写行 (s.姓名)
04      以上
05
06      空 函数 显示摘要(本型 s)
07  以上
</code></pre>
<pre><code class="language-js">01  trait Named
02      function showName(Self s)
03          writeLine (s.name)
04      end
05
06      empty function showSummary(Self s)
07  end
</code></pre>
<p>上面代码的 06 行即空方法。</p>
<blockquote>
<p>空方法的参数只能使用 <code>本型</code> 代替目标数据类型，因为在定义特性时，我们无法得知以后会被赋予到哪个数据类型。</p>
</blockquote>
<p>在赋予特性给数据类型时，需要把空方法的主体补上，示例：</p>
<pre><code class="language-js">赋予 用户 特性 具名
    函数 显示摘要(本型 s)
        书写行 (!&quot;我是用户，编号： {s.id}，姓名： {s.name}&quot;)
    以上
以上

赋予 学生 特性 具名
    函数 显示摘要(本型 s)
        书写行 (!&quot;我是学生，编号： {s.id}，姓名： {s.name}&quot;)
    以上
以上
</code></pre>
<pre><code class="language-js">assign User trait Named
    function showSummary(Self s)
        writeLine(!&quot;I'm User, id: {s.id}, name: {s.name})&quot;)
    end
end

assign Student trait Named
    function showSummary(Self s)
        writeLine(!&quot;I'm Student, id: {s.id}, name: {s.name})&quot;)
    end
end
</code></pre>
<h3 id="关联类型"><a class="header" href="#关联类型">关联类型</a></h3>
<p>因为在定义特性时无法得知最终会被应用到哪个数据类型，所以需要使用 <code>本型</code> 代替将来会被赋予该特性的具体数据类型。但这样只有一个 &quot;可变&quot; 的数据类型，有时可能需要更多的 &quot;可变&quot; 数据类型待 <code>赋予</code> 时所使用。这种额外的，待将来指定为具体类型的数据类型称为 &quot;关联类型&quot;。</p>
<p>比如对于用于表示序列的特性 <code>序列</code>（<code>Sequence</code>），其中的函数 <code>第一个</code> 输出的数据类型显然不是 <code>本型</code>，而是其元素的类型，这种情况下需要在特性里定义多一个 &quot;可变&quot; 的数据类型。</p>
<p>使用 <code>关联</code>（<code>associate</code>） 关键字可以为特性定义一个或多个关联类型。</p>
<p>示例：</p>
<pre><code class="language-js">特性 序列 关联 子型
    空 函数 子型 第一个(本型 s)
以上
</code></pre>
<pre><code class="language-js">trait Sequence associate ItemType
    empty function ItemType first(Self s)
end
</code></pre>
<p>上面代码当中的 <code>子型</code>（<code>ItemType</code>）就是关联类型的代号，为了跟泛型的代号区分，中文一般使用 &quot;子型&quot; &quot;丑型&quot; &quot;寅型&quot; &quot;卯型&quot; 等名称，英文则使用一个描述具体作用的名称，比如 &quot;ItemType&quot;, &quot;TargetType&quot;, &quot;SourceType&quot; 等等。</p>
<p>在赋予带有关联类型的特性给一个具体的数据类型时，需要同时明文指出所有关联类型的实际类型。语法是 <code>子型名称 = 实际数据类型名称</code>，如果有多个关联类型，则使用逗号分隔它们。</p>
<p>示例：</p>
<pre><code class="language-js">assign MyList trait Sequence associate ItemType = String
    function String first(Self s)
        &quot;foo&quot;
    end
end
</code></pre>
<p>需注意，具有关联类型的特性仍然只能赋予一次给同一个数据类型。不支持通过更改关联类型的实际类型来多次赋予给同一个数据类型。</p>
<p>示例：</p>
<pre><code class="language-js">assign MyList trait Sequence associate ItemType = String
    ...
end

assign MyList trait Sequence associate ItemType = Int
    ...
end
</code></pre>
<p>上面的代码试图将 <code>Sequence</code> 特性赋予 2 次给 <code>MyList</code> 数据类型，所以会引起运行时异常。</p>
<p>如果需要在 <code>赋予</code> 语句块之外访问某个被赋予了特性的数据类型的关联类型，可以使用名称空间的方法访问。</p>
<p>示例：</p>
<pre><code class="language-js">
</code></pre>
<p>在定义特性的关联类型时，也可以指定其<strong>默认数据类型</strong>，这样在编写 <code>赋予</code> 语句时，可以省略关联类型的具体数据类型。</p>
<p>示例：</p>
<pre><code class="language-js">特性 可转换 关联 子型=字符串
    ...
以上

赋予 我的数据类型 可特性 转换  # 这里可省略关联类型的实际类型
    ...
以上
</code></pre>
<pre><code class="language-js">trait Convertable associate ItemType=String
    ...
end

assign MyDataType trait Convertable  # Omit the actual type of the association type here
    ...
end
</code></pre>
<h3 id="泛型特性"><a class="header" href="#泛型特性">泛型特性</a></h3>
<p>特性也支持泛型。跟数据类型的泛型一样，特性的泛型实际上也是代码的模板，泛型参数具体化之后实际上会产生多种完全不同的特性，所以一个带有泛型的特性是可以多次赋予在同一个数据类型。</p>
<p>比如有一个 <code>可加</code>（<code>Addable</code>） 特性，其中有 <code>加</code>（<code>add</code>）函数：</p>
<ul>
<li>其第一个参数是 <code>本型</code>；</li>
<li>为了可以跟多个其他数字数据类型相加，第二个参数定义为泛型；</li>
<li>当第一个和第二个参数的数据类型确定后，加法的结果其数据类型是确定的，但很有可能跟第一个和第二个数据类型都不一样。因为结果的数据类型是唯一的，所以函数的返回值数据类型必须定义为关联类型。</li>
</ul>
<pre><code class="language-js">特性 可加&lt;甲型&gt; 关联类型 子型
    空 函数 子型 加 (本型 left, 甲型 right)
以上
</code></pre>
<pre><code class="language-js">trait Addable&lt;R&gt; associate OutputType
    empty function OutputType add(Self left, R right)
end
</code></pre>
<p>比如现有一个 <code>MyNumber</code> 数据类型准备支持跟整数和实数相加，则大致的代码如下：</p>
<pre><code class="language-js">assign MyNumber trait Addable&lt;MyNumber&gt; associate ItemType = MyNumber
    function MyNumber add(Self left, MyNumber right)
        ...
    end
end

assign MyNumber trait Addable&lt;Int&gt; associate ItemType = MyNumber
    function MyNumber add(Self left, Int right)
        ...
    end
end

assign MyNumber trait Addable&lt;Real&gt; associate ItemType = MyNumber
    function MyNumber add(Self left, Real right)
        ...
    end
end
</code></pre>
<p>由此可见，使用泛型特性配合关联类型，可以实现 &quot;多数据类型输入，单数据类型输出&quot; 的目的。</p>
<p>需要注意：</p>
<ul>
<li>并不是输入参数就得定义为泛型，而输出值就得定义为关联类型，有些场合无论是输入参数还是输出值，都可以定义为泛型、或者都定义为关联类型。似乎具体情况而定。但上例不能把加法的第二个参数和函数返回值都定义为泛型，如果都定义为泛型，则表示当第一个、第二个数据类型确定后，返回值的数据类型可以有多个，显然这不符合算术加法的原则。</li>
<li>正如上面章节所描述，在调用数据类型具有的特性的方法时，需要事先把该特性导入到当前名称空间方可使用，所以为了使用上面示例代码当中的 <code>add</code> 方法，需要添加诸如 <code>use someNameSpace::Addable&lt;Real&gt;</code> 的语句。</li>
</ul>
<p>跟关联类型一样，泛型特性的类型代号也可以指定默认的数据类型，这样在赋予该特性给某些数据类型时，可以省略指定泛型的具体数据类型。</p>
<p>示例：</p>
<pre><code class="language-js">trait Addable&lt;R=Self&gt; associate OutputType
    empty function OutputType add(Self left, R right)
end
</code></pre>
<p>上面的 <code>R=Self</code> 即为泛型的默认数据类型。假设有如下 <code>赋予</code> 语句：</p>
<pre><code class="language-js">assign MyNumber trait Add associate OutputType = MyNumber
    # ...
end
</code></pre>
<p>实际的代码将会是：</p>
<pre><code class="language-js">assign MyNumber trait Add&lt;MyNumber&gt; associate OutputType = MyNumber
    # ...
end
</code></pre>
<h4 id="赋予泛型特性到泛型数据类型"><a class="header" href="#赋予泛型特性到泛型数据类型">赋予泛型特性到泛型数据类型</a></h4>
<p>::TODO</p>
<p>示例：</p>
<pre><code class="language-js">struct Point&lt;T&gt;
    Int x
    Int y
end

assign&lt;T&gt; Point&lt;T&gt; trait Add&lt;Self&gt; associate OutputType = Self type
    T limit Add&lt;T&gt; associate OutputType = T

    function Self add(Self left, Self right)
        let x = left.x + right.x
        let y = left.y + right.y
        Self (x, y)
    end
end
</code></pre>
<h3 id="内置特性"><a class="header" href="#内置特性">内置特性</a></h3>
<p>有一些运行环境内置的特性，比如 <code>可显示</code>（<code>Display</code>）、<code>可转字符串</code>（<code>ToString</code>）、<code>可相等比较</code>（<code>Equal</code>）等，当赋予一个结构体时，如果该结构体里的所有成员也被赋予了这些特性，则该结构体也会自动获得这些特性（而不需要手动写具体的实现代码）。</p>
<h2 id="特性约束"><a class="header" href="#特性约束">特性约束</a></h2>
<h3 id="为范型函数添加特性约束"><a class="header" href="#为范型函数添加特性约束">为范型函数添加特性约束</a></h3>
<p>特性不是数据类型，所以无法将变量、函数的参数等数据类型声明为特性，但在添加特性约束到范型中。</p>
<p>比如要实现一个 &quot;最大值&quot;（&quot;max&quot;）函数，该函数传入两个参数，需要支持整数、浮点数等数据类型，我们很自然会想到把这个函数定义为范型函数，主要代码如下：</p>
<pre><code class="language-js">函数 最大值&lt;甲型&gt; (甲型 left, 甲型 right)
    如果 left &gt; right 那么 left 否则 right
以上
</code></pre>
<pre><code class="language-js">function max&lt;T&gt; (T left, T right)
    if left &gt; right then left else right
end
</code></pre>
<p>不过用户在调用这个函数时有可能会传入一些不支持大小比较的数据，比如逻辑型数据。可以在定义范型时加入约束，仅让具有指定的一个或多个特性的数据通过。</p>
<p>示例：</p>
<pre><code class="language-js">函数 最大值&lt;甲型&gt; (甲型 left, 甲型 right) 类型
    甲型 限制 可大小比较
    如果 left &gt; right 那么 left 否则 right
以上
</code></pre>
<pre><code class="language-js">function max&lt;T&gt; (T left, T right) type
    T limit Ordered
    if left &gt; right then left else right
end
</code></pre>
<p>如上例所示，通过在函数的参数列表后面添加 <code>类型</code>（<code>type</code>）关键字，然后列出需要约束的类型代号，以及 <code>限制</code>（<code>limit</code>）关键字，再加上特性的名称即可。</p>
<p>如果需要限制多个特性，则在 <code>限制</code> 关键字后面使用元组把多个特性名称列出，示例：</p>
<pre><code class="language-js">函数 最大值&lt;甲型&gt; (甲型 left, 甲型 right) 类型
    甲型 限制 (可显示, 可大小比较)
    如果 left &gt; right 那么 left 否则 right
以上
</code></pre>
<pre><code class="language-js">function max&lt;T&gt; (T left, T right) type
    T limit (Display, Ordered)
    if left &gt; right then left else right
end
</code></pre>
<p>注意，<code>类型</code> 关键字后面除了用于列出范型的约束，同时也是用于列出 &quot;类型简写&quot; 的地方，如果需要约束多个范型或者需要声明多个类型，需要在它们之间使用逗号分隔，否则在第一个约束或声明之后的语句会被视为函数主体。详见 <a href="variables.html#%E7%B1%BB%E5%9E%8B%E7%AE%80%E5%86%99">变量-函数的类型简写</a></p>
<p>如果约束的特性是泛型特性，则还需把特性的泛型、关联数据类型都列出。</p>
<p>示例：</p>
<pre><code class="language-js">addPoint&lt;T&gt;(Point&lt;T&gt; left, Point&lt;T&gt; right) type
    T limit Add&lt;T&gt; associate OutputType = T

    let x = left.x + right.x
    let y = left.y + right.y
    Point&lt;T&gt; (x, y)
end
</code></pre>
<h3 id="为范型数据类型添加特性约束"><a class="header" href="#为范型数据类型添加特性约束">为范型数据类型添加特性约束</a></h3>
<p>除了可以为范型函数添加特性约束，还可以为范型数据方法添加特性约束。</p>
<p>比如为上例的 <code>点坐标</code> 添加 <code>显示摘要</code>（<code>showSummary</code>）方法：</p>
<pre><code class="language-js">赋予&lt;甲型&gt; 点坐标&lt;甲型&gt; 类型
    甲型 限制 可显示
    函数 显示坐标(本型 p)
        ...
    以上
以上
</code></pre>
<pre><code class="language-js">assign&lt;T&gt; Point&lt;T&gt; type
    T limit Display
    function showPoint(Self p)
        ...
    end
end
</code></pre>
<p>这样只有具有 <code>可显示</code> 的数据类型才能用于类型具体化 <code>点坐标</code> 结构体。</p>
<h3 id="为特性添加特性约束"><a class="header" href="#为特性添加特性约束">为特性添加特性约束</a></h3>
<p>即一个特性要求另外一个特性必须先存在，类似面向对象编程的 &quot;继承&quot;，比如 <code>HtmlDisplay</code> 继承 <code>Display</code>。</p>
<p>::TODO</p>
<h2 id="特性作为数据类型使用"><a class="header" href="#特性作为数据类型使用">特性作为数据类型使用</a></h2>
<p>::TODO</p>
<p>特性可以作为数据类型使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数的连续调用"><a class="header" href="#函数的连续调用">函数的连续调用</a></h1>
<!--
## 一般函数的连续调用

### 类型方法

:TODO

### 参数传参（::TODO 不再支持）

数据作为函数的最后一个参数传递

"hello" -> writeLine()
-->
<p>将一个数值（或者一个表达式的求值结果）作为下一个表达式的参数，如：</p>
<p><code>3 &gt;&gt; add(%, 2)</code></p>
<p>等同于</p>
<p><code>add(3, 2)</code></p>
<p>此方法可以将一串处理函数连接起来，就像管道一样</p>
<pre><code class="language-js">let result = tokenlize(&quot;1+2*3&quot;) &gt;&gt;
    parse(%) &gt;&gt;
    eval(%)
// result 的结果为 7
</code></pre>
<p>也可以一次将多个数值传递下去</p>
<p><code>(2, 3) &gt;&gt; add(%, %)</code></p>
<p>等同于</p>
<p><code>add(2, 3)</code></p>
<h2 id="方法的连续调用"><a class="header" href="#方法的连续调用">方法的连续调用</a></h2>
<p>即点号的连续调用，一个方法的返回值是一个数值，该数值也存在方法，可以一路点号调用。</p>
<pre><code>let a = [1..10]
    .map(i=&gt;i*3)
    .filter(i=&gt;(i :rem: 2) == 0)
</code></pre>
<h2 id="option-result-类型的连续调用"><a class="header" href="#option-result-类型的连续调用">Option, Result 类型的连续调用</a></h2>
<p>::todo 重新考虑运算符号</p>
<p>~|, ~&amp;</p>
<p>check_one(1) ~| check_two(2)
check_one(1) ~&amp; check_two(2)</p>
<p>Option, Result 此类数据扮演着 Functor 部分角色，但为了避免引入深奥理论，这里命名为 Container。</p>
<p><code>&gt;&gt;</code> 串联符号能将 &quot;单独一个值参数和一个 Container 类型返回值&quot; 的函数串联起来。</p>
<p>let f = Option &lt;- (T)</p>
<p>f1 &gt;&gt; f2 &gt;&gt; f3 &gt;&gt; f4</p>
<p>只要有一个环节的值为 Nothing，则链路直接跳到最后一环并输出 Nothing，否则返回 Some(value)。
只要有一个环节的值为 Err，则链路直接跳到最后一环并输出 Err，否则返回 Ok(value)。</p>
<h3 id="对于返回非-option-的函数可以使用匿名函数包装然后放进链路"><a class="header" href="#对于返回非-option-的函数可以使用匿名函数包装然后放进链路">对于返回非 Option 的函数，可以使用匿名函数包装然后放进链路</a></h3>
<p>function String sample(Int i) = ...</p>
<p>let f2b = v =&gt; new Some(sample(v))
let f2b = v =&gt; Some::new(sample(v))</p>
<p>然后就可以加入到链路了</p>
<p>f1 &gt;&gt; f2 &gt;&gt; f2b &gt;&gt; f3 &gt;&gt; f4</p>
<p>也可以在链路上当场转换：
f1 &gt;&gt; f2 &gt;&gt; v =&gt; Some::new(sample(v)) &gt;&gt; f3 &gt;&gt; f4</p>
<p>或者使用函数合并操作符：
f1 &gt;&gt; f2 &gt;&gt; Some::new &amp; sample &gt;&gt; f3 &gt;&gt; f4</p>
<h3 id="有时需要在中间一环提取部分数据而不是直接把上一环的数据传到下一环这时有两种方法"><a class="header" href="#有时需要在中间一环提取部分数据而不是直接把上一环的数据传到下一环这时有两种方法">有时需要在中间一环提取部分数据，而不是直接把上一环的数据传到下一环，这时有两种方法：</a></h3>
<ol>
<li>断链，即，将程序分成两段来写；</li>
<li>将剩下的链放在一个匿名函数里。</li>
</ol>
<p>示例：</p>
<p>f1 &gt;&gt; f2 &gt;&gt;
b =&gt; begin
let (i, j) = b
Ok::new(i) &gt;&gt; f3 &gt;&gt; f4
end</p>
<h3 id="两个或多个参数的情况"><a class="header" href="#两个或多个参数的情况">两个或多个参数的情况</a></h3>
<p>将 f1 的结果同时应用到 f2, f3 的参数
f1 &gt;&gt; (f2, f3)</p>
<p>将 f1, f2 的结果作为两个参数应用到 f3
(f1, f2) &gt;&gt; f3</p>
<p>连续调用，f4 接受两个参数 f2, f3
f1 &gt;&gt; (f2, f3) &gt;&gt; f4</p>
<p>连续调用，f4 接受一个 Point(x,y) 参数
f1 &gt;&gt; (f2, f3) &gt;&gt; (i, j) =&gt; Ok::new(Point::new(i, j)) &gt;&gt; f4</p>
<p>连续调用，丢弃中间的一个结果值，f4 接受一个参数
f1 &gt;&gt; (f2, f3) &gt;&gt; (i, _) =&gt; Ok::new(i) &gt;&gt; f4</p>
<h2 id="option-result-类型的短路拆封运算"><a class="header" href="#option-result-类型的短路拆封运算">Option, Result 类型的短路拆封运算</a></h2>
<p>a() || b() || c() || d</p>
<p>只要有一个返回非 Option::None 和 Result::Err 即立即返回其数值。</p>
<p>:TODO</p>
<h2 id="管道调用"><a class="header" href="#管道调用">管道调用</a></h2>
<p>用于创建绿色线程。</p>
<p>a() | b() | c()</p>
<p>:TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interface"><a class="header" href="#interface">interface</a></h1>
<p><code>接口</code>（<code>interface</code>） 是一种约定所有方法必须遵循以下规定的 <code>特性</code>：</p>
<ol>
<li>第一个参数必须为 <code>本型</code>（<code>Self</code>），且这个本型必须与所处理的数据无关，即这个本型是一个占位符，跟业务逻辑无关；</li>
<li>必须是空方法。</li>
</ol>
<p>相对于 <code>特性</code> 用于实现具体数据类型的特有方法，<code>接口</code> 则用于实现某个（或某组）业务逻辑的方法。</p>
<p>示例：</p>
<pre><code class="language-js">struct Ticket
    Int id
    String issue
end

interface TicketRepository
    empty function Result&lt;Unit, Error&gt; add(Self self, Int id, String issue)
    empty function Ticket get(Self self, Int id)
end
</code></pre>
<p>实际上 <code>接口</code> 在内部是一个被标上了额外的标记 <code>特性</code>，不过当需要表示业务逻辑的一组方法时，尽量使用 <code>接口</code> 而不是 <code>特性</code> 来定义，这样目的会更明确。</p>
<h2 id="组件"><a class="header" href="#组件">组件</a></h2>
<p>实现接口跟实现一个特性类似，不同的是，<code>特性</code> 是实现在一个数据类型（比如结构体、联合体）上，接口则是实现在 <code>组件</code>（<code>component</code>） 上。组件里必须包含有 &quot;实现该业务逻辑所需要的其他接口&quot; 的成员（如果没有则可以留空）。</p>
<p>示例：</p>
<pre><code class="language-js">component MemoryTicketRepository interface TicketRepository
    // the component members //

    Map&lt;Int, String&gt; records

    // the interface methods //

    function Result&lt;Unit, Error&gt; add(Self self, Int id, String issue)
        let ticket = Ticket::new(id, issue)
        self.records.set(id, ticket)
        Ok(Unit::Void)
    end

    function Option&lt;Ticket&gt; get(Self self, Int id)
        self.records.tryGet(id)
    end
end
</code></pre>
<p>实际上 <code>组件</code> 在内部就是一个被标上了额外标记的 <code>结构体</code>，上面的代码大致等同于：</p>
<pre><code class="language-js">struct MemoryTicketRepository
    Map&lt;Int, String&gt; records
end

impl MemoryTicketRepository interface TicketRepository
    // ...
end
</code></pre>
<p>不过在实现一个接口时，尽量使用 <code>组件</code> 而不是 <code>结构体</code>，这样目的会更明确。</p>
<p>实例化一个组件时，必须把其所需的所有成员通过默认构造函数传入。使用该组件的示例如下：</p>
<pre><code class="language-js">let records = Map&lt;Int, String&gt;::new()
let repo = MemoryTicketRepository::new(records)

repo.add(123, &quot;foo&quot;)?
repo.add(456, &quot;bar&quot;)?

writeLine(repo.get(123) || &quot;&quot;)
</code></pre>
<p>一个接口可以有多个实现（即组件），比如上述的 <code>TicketRepository</code> 除了可以有 <code>MemoryTicketRepository</code>，还可以有 <code>SQLiteTicketRepository</code>, <code>PostgreSQLTicketRepository</code> 等等实现。</p>
<h2 id="组件环境"><a class="header" href="#组件环境">组件环境</a></h2>
<p>一个业务系统往往包含多个接口，且这些接口有依赖关系，为了便于实例化一组接口，XiaoXuan 运行环境自带一个 <code>组件环境</code>（<code>ComponenetContext</code>），这是一个类似 SpringFramework 的 ApplicationContext IoC 的概念。</p>
<p>假设有一个 <code>IssueTrack</code> 系统，系统包含有 <code>UserRepository</code>, <code>StaffRepository</code>, <code>TicketRepository</code>, <code>SolutionRepository</code>, <code>RatingRepository</code>，其中的依赖关系如下：</p>
<pre><code>IssueTrack
  |
  |-- SolutionRepository
  |     |-- TicketRepository
  |     |-- StaffRepository
  |
  |-- RatingRepository
  |     |-- TicketRepository
  |     |-- StaffRepository
  |
  |-- TicketRepository
  |     |-- UserRepository
</code></pre>
<p>显然，在实例化时需要先实例化 <code>UserRepository</code>，<code>TicketRepository</code>，然后实例化 <code>StaffRepository</code>，再实例化 <code>SolutionRepository</code> 和 <code>RatingRepository</code>。（前两步的先后顺序可调换）</p>
<p><code>组件环境</code> 是一个组件的容器，我们需要把组件（也就是某个接口的某个实现）依次添加入 <code>组件环境</code>。示例：</p>
<pre><code class="language-js">let context = ComponenetContext::new()

// add UserRepository
let userRepository = MemoryUserRepository::new(
    Map&lt;Int, String, String&gt;::new())
context.add(typeOf(UserRepository), userRepository)

// add TicketRepository
let ticketRepository = MemoryTicketRepository::new(
    Map&lt;Int, String&gt;::new(),
    context.get(typeOf(UserRepository)))
context.add(typeOf(TicketRepository), ticketRepository)
)
</code></pre>
<p><code>组件环境</code> 提供了 <code>add</code> 方法用于添加组件，<code>get</code> 方法用于根据接口获取对应的组件。</p>
<p>接下来还要添加 <code>SolutionRepository</code> 和 <code>RatingRepository</code>，假如它们对应的组件的构造函数仅依赖 <code>TicketRepository</code> 和 <code>StaffRepository</code> 两个接口的组件，则可以使用宏 <code>addComponenet</code> 自动创建组件构造函数所需要的参数，自动调用构造函数，并加入到指定的 <code>ComponentContext</code>。示例：</p>
<pre><code class="language-js">addComponent(context, MemorySolutionRepository)
</code></pre>
<p>上面一句相当于：</p>
<pre><code class="language-js">let userRepository = context.get(typeOf(UserRepository))
let ticketRepository = context.get(typeOf(TicketRepository))
let solutionRepository = MemorySolutionRepository::new(userRepository, ticketRepository)
context.add(typeOf(SolutionRepository), solutionRepository)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包和模块"><a class="header" href="#包和模块">包和模块</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>只读流
无限延迟列表
只有 headAndTail() 函数
无大小
无 add/append/insert 等函数</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="可变性"><a class="header" href="#可变性">可变性</a></h1>
<p>e.g.</p>
<p>window.title := &quot;hello&quot;
box.width := 120
frame.rect.left := 10</p>
<p>运算符 <code>:=</code> 是函数 <code>!set</code> 的语法糖：</p>
<p>!set(window, #title, &quot;hello&quot;) &lt;-- 返回 window
!set(box, #width, 120) &lt;-- 返回 box
!set(get(frame, #rect), #left, 10) &lt;-- 返回 rect</p>
<p>这些对象的成员并不是普通的结构体成员，所以读取的方法跟其他普通结构体实例的不一样：</p>
<p>let String title := window.title
let Int width := box.width
let Int left := frame.rect.left</p>
<p>表达式 <code>let ... :=</code> 是函数 <code>!get</code> 的语法糖：</p>
<p>let String title = !get(window, #title)
let Int width = !get(box, #width)
let Int left = !get(get(frame, #rect), #left)</p>
<h2 id="内置的对象-prop"><a class="header" href="#内置的对象-prop">内置的对象 prop</a></h2>
<p>prop 即属性包，每个线程都会有一个独立的属性包</p>
<p>属性包也可以用 <code>:=</code> 操作符读写：</p>
<p>prop.a := 12
let Int a := prop.a</p>
<p>!set(prop, #a, 12)
let Int a = !get(prop, #a)</p>
<p>prop.set(#a, 12)
let Int a = prop.get(#a)</p>
<p>prop 不是一个普通对象，它会作为一个特殊关键字被语言限制，它本身无法作为一个值传递给其他变量或者作为参数传递给函数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并行"><a class="header" href="#并行">并行</a></h1>
<h2 id="线程变量"><a class="header" href="#线程变量">线程变量</a></h2>
<p>::TODO</p>
<p>core::variable</p>
<ul>
<li>
<p>void &lt;- set<T>(HashString name, T value)
更新</p>
</li>
<li>
<p>Option<T> &lt;- tryGet<T>(HashString name)
尝试读取</p>
</li>
<li>
<p>T &lt;- get<T>(HashString name)</p>
</li>
<li>
<p>void &lt;- delete<T>(HashString name)</p>
</li>
</ul>
<pre><code class="language-js">无返回 &lt;- 设值&lt;T&gt;(散列字符串 name, T value)
T &lt;- 读值&lt;T&gt;(散列字符串 name)
可选&lt;T&gt; &lt;- 尝试读值&lt;T&gt;(散列字符串 name)
无返回 &lt;- 删除&lt;T&gt;(散列字符串 name)
</code></pre>
<p>线程变量的实现方式由具体的运行环境决定。一般使用一个内置的线程关联的映射表 <code>Map&lt;HashString, T&gt;</code> 实现。</p>
<p>示例：</p>
<p><code>set(#foo, 123)</code>
<code>set(#bar, &quot;hello&quot;)</code></p>
<p><code>let i = get&lt;Int&gt;(#foo)</code>
<code>let j = get&lt;String&gt;(#hello)</code></p>
<p><code>let Int i = get(#foo)</code>
<code>let String j = get(#hello)</code></p>
<h3 id="线程变量的数据类型"><a class="header" href="#线程变量的数据类型">线程变量的数据类型</a></h3>
<p>对于每种数据类型的线程变量的读写，都会产生相应的一个独立映射表，比如：</p>
<pre><code class="language-js">set&lt;Int&gt;(#&quot;foo&quot;, 123)
set&lt;String&gt;(#&quot;foo&quot;, &quot;bar&quot;)
</code></pre>
<p>上面两句会分别产生一个 <code>Map&lt;HashString, Int&gt;</code> 和一个 <code>Map&lt;HashString, String&gt;</code>，两个映射表分别存储相应数据类型的值，所以即使看起来线程变量可以接受任何数据类型，但实际上还是严格遵守静态数据类型检查。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>注释和文档</p>
<p>行注释 //
块注释 /*
结构注释（结构开关） enable/disable/启用/禁用
markdown 富元素文档（图片：位图/矢量图svg/gif/apng/webp、视频、音频等）
包含inline 测试</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中文文法"><a class="header" href="#中文文法">中文文法</a></h1>
<ol>
<li>使用独立的 Lex 和 Parser</li>
<li>不使用空格分词；</li>
<li>不使用全角标点符号；</li>
<li>不使用书面上容易混淆的标点符号；</li>
<li>语句可连续写（使用分号分隔）</li>
<li>格式靠近普通文章，比如使用项目符号表示 case，使用括号表示进一步描述等。</li>
</ol>
<h2 id="分词规则"><a class="header" href="#分词规则">分词规则</a></h2>
<p>依据下面词语来分词：</p>
<ul>
<li>字面量</li>
<li>关键字</li>
<li>导入的名称</li>
</ul>
<p>示例：</p>
<p><code>赋值整数累加值予一二三</code></p>
<ol>
<li>
<p>&quot;赋值&quot;，&quot;予&quot; 是关键字，&quot;一二三&quot; 是整数字面量，所以句子被分词为：</p>
<p><code>赋值 整数累加值 予 一二三</code></p>
</li>
<li>
<p>&quot;整数&quot; 是预导入的（数据类型的）名称，所以句子被分词为：</p>
<p><code>赋值 整数 累加值 予 一二三</code></p>
</li>
</ol>
<h3 id="使用一对花括号单引号包围变量名函数名"><a class="header" href="#使用一对花括号单引号包围变量名函数名">使用一对花括号（单引号）包围变量名、函数名</a></h3>
<p>当变量名或函数名包含有关键字、或者导入名称时，可以使用一对花括号包围起来，示例：</p>
<pre><code class="language-js">赋值用户{用户甲}予用户::新建(100, &quot;张三&quot;)
赋值用户{用户乙}予用户::新建(101, &quot;李四&quot;)

函数用户{首个用户}(序列&lt;用户&gt;{用户列表})
    {用户列表}.第一个()
以上
</code></pre>
<pre><code class="language-js">赋值用户'用户甲'予用户::新建(100, &quot;张三&quot;)
赋值用户'用户乙'予用户::新建(101, &quot;李四&quot;)

函数用户'首个用户'(序列&lt;用户&gt;'用户列表')
    '用户列表'.第一个()
以上
</code></pre>
<h2 id="紧凑写法"><a class="header" href="#紧凑写法">紧凑写法</a></h2>
<p>使用分号可以将一行语句分为多行，示例：</p>
<pre><code class="language-js">使用数学::{平方,平方根}
令勾等于三;令股等于四;令弦等于平方根(平方(勾),平方(股))
格式化书写行(&quot;斜边长 {:D}&quot;,弦)
</code></pre>
<pre><code class="language-js">use Math::{square, sqrt}
assign x as 3; assign y as 4; assign z as sqrt(square(x), square(y))
writeLineFormat(&quot;distance {}&quot;,z)
</code></pre>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<pre><code class="language-js">让字符串变量甲=&quot;你好&quot;
让变量乙=`世界 {变量甲}`
书写行(变量甲)

赋值字符串变量甲予&quot;你好&quot;
赋值变量乙予`世界 {变量甲}`
书写行(变量甲)

让数甲=一二三
让数乙=四五六
让变量丙=最大值(数甲,数乙)

赋值甲予一二三
赋值乙予四五六
赋值变量丙予最大值(数甲,数乙)

函数整数最大值(整数左手值, 整数右手值)
    如果左手值:大于:右手值那么
        左手值
    否则
        右手值
    以上
以上

函数序列&lt;甲型&gt;排序&lt;甲型&gt;(序列&lt;甲型&gt;列)
    类型甲型限制(可排序,可比较)
    ...
以上

结构用户
    整数编号
    字符串姓名
以上

实现用户特性可比较
    关联类型目标类型=用户
    函数逻辑相等(本型左手值, 用户右手值)=左手值.编号==右手值.编号
以上

让用户甲=用户::新建(123,&quot;张三&quot;)
让用户乙=用户::新建(456,&quot;李四&quot;)
断定::相等(用户甲,用户乙)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
