# 包和名称空间

## 包

一个完整的程序或者库称为 `包`（`package`），包用于实现程序模块化以及代码重用。

具体来说，一个包对应着文件系统的一个文件夹，包基本的内容有：

* 包配置文件，文件名固定为 `package.toml`。该文件用于描述包的名称、版本、使用的语言以及依赖关系等；
* 文件夹 `src`，用于存放源代码文件；
* 文件 `src/main.xuan` 或者 `src/lib.xuan`，该文件是包的顶层源码文件，前者用于生成可执行程序，后者用于生成库，可以二选一，也可以同时存在。

另外一个典型的包通常还包含有（但不是必须的）：

* 说明文件，对包的简要说明，文件名一般是 `README`、`README.txt` 或者 `README.md`；
* 授权协议文件，描述包的授权方式，文件名一般是 `LICENSE`、`LICENSE.txt` 或者 `LICENSE.md`。

根据包配置文件指定的本地语言，文件夹和文件名也会作出相应的本地化。比如包指定本地语言为 `zh-CN`（简体中文），则上述的提到的文件名将会是：`源码/主要.xuan`、`源码/库.xuan`、`说明{,.txt,.md}`、`授权协议{,.txt,.md}` 等。

### package.toml 配置文件

一个基本的 `package.toml` 文件内容如下：

```toml
#lang=en

[package]
name = "my_first_package"
version = "0.1.0"
```

文件的第一行 `#!en` 用于标识当前配置文件使用哪一种本地语言，缺省的情况下是 `en`（表示英语），这是一个本地语言代码（locale code），常见有 `zh_CN`（简体中文）、`zh_HK`（繁体中文）、`ja`（日语）、`fr`（法语）、`de`（德语）等等。

如果指定了其他语言，则该配置文件的相应字段都要使用指定本地语言。

示例：

```toml
#lang=zh_CN

[包]
名称 = "我的第一个包"
版本 = "0.1.0"
```

为了便于本规格文档翻译成其他语言，下面全部使用默认的语言（即 `en`）说明该配置文件。

#### name 字段



## 命名空间

### 名称路径

std::math.floor(...)

### 隐含的命名空间

常量组、结构体、联合体、特性都会产生同名的名称空间，其中联合体的子类型、以及将特性赋予给结构体等会产生二级命名空间。所以不能创建跟这些数据类型同名的子命名空间。相应地，也不能创建跟子命名空间同名的常量组、结构体、联合体、特性。

示例：

```js
namespace Foo

    struct User
        Int id
        String name
    end

    namespace User  # Error
        # ...
    end

    unit Color
        RGB(Int red, Int green, Int blue)
        HSL(Int H, Int S, Int L)
    end

    namespace Color  # Error
        # ...
    end

    namespace Color::RGB  # Error
        # ...
    end
end
```

使用 use 引入
* 对于函数，一般引入其所在的名称空间，而不是把函数名称引入；
* 对于结构体、联合体、枚举、常量组、特性等其他项，习惯是指定它们的完整路径，即将它们本身引入。

## 语言相关代码

在模块级作用范围内，使用 `lang` 语句块可以定义语言专门的代码

```js
lang "zh-cn"
    运算符 ("+", "加", 优先级 = 99, 结合顺序值 = 结合顺序.左)
end
```

# 从 XiaoXuan Lang IR 挪过来，尚未整理的资料

<!--
::TODO 挪到 XiaoXuan Lang Spec
注：虽然 `命名空间路径` 在名称上存在层次关系（父子关系），但实际上每个命名空间都是同级的、并列的。
-->

<!--
::TODO 挪到 XiaoXuan Lang Spec
#### 使用 `use` 表达式简化标识符全称

有时一个标识符可能会被多次引用，重复书写完整名称会稍显繁琐，这种情况下可以使用 `use` 表达式将目标标识符引入到当前命名空间表达式（`namespace` 表达式）的代码范围之内，示例：

```clojure
(namespace app
    (use mylib.foo.B)
    (defn main () (do
        (let i B)
    ))
)
```

上面的 `use` 表达式将标识符完整名称 `mylib.foo.B` 引入到当前命名空间表达式的代码范围之内，在编译这段命名空间表达式的代码的 `预处理阶段`，所有出现符号 `B` 的地方都会被替换为 `mylib.foo.B`。

需注意的是：

- `use` 表达式仅仅在源代码层次实现标识符完整名称的简写的功能，而不像一些语言的 `use` 或者 `import` 语句那样，它们可能会从另外一个文件导入一个模块。
- 使用 `use` 表达式引入的标识符名称仅在当前 `namespace` 表达式的源码范围内有效，它不会覆盖到其他命名空间表达式，也不会覆盖到同名命名空间表达式。
- 跟 `namespace` 表达式类似，`use` 表达式是一个用于组织代码的特殊表达式，它在编译的 `预处理阶段` 执行，在预处理之后不再存在，所以 `use` 表达式没有返回值。

一般来说，机器生成的 XiaoXuan Lang IR 代码总是写标识符全称的（毕竟 XiaoXuan Lang IR 并不是设计给人直接阅读），使用 `use` 表达式的主要目的是便于手写和调试 XiaoXuan Lang IR 程序。
-->

<!-- 这时因为，正如前面所说，尽管父子命名空间名称上有层次关系，但实际上是相互独立的。-->

<!--

#### 命名空间的相对路径

为了方便访问同一个模块里不同命名空间里的标识符，XiaoXuan Lang IR 规定在命名空间路径里的第一个名称有几个特殊的名称：

- `module` 用于代表当前模块的名称，有时模块名称可能比较长，或者在开发过程中会改变，使用当前模块名称的 "代号" 显然比起实际名称更容易维护，比如在模块 `mylib` 里，`module.math` 表示 `mylib.math`。
- `current` 用于表示当前命名空间，通过 `current` 就可以使用 "相对路径" 来访问子命名空间。当命名空间路径比较长时，使用相对路径要比绝对路径更容易书写。
- `parent` 用于代表当前模块的父命名空间，通过 `parent` 就可以使用 "相对路径" 来访问父命名空间，还可以通过叠加 `parent` 表示任意层的父命名空间，比如 `parent.parent` 表示上两层命名空间。

这 3 个特殊名称是 XiaoXuan Lang IR 保留的名称，任何模块、命名空间都不能跟它们同名。

跟 `use` 表达式类似，这 3 个特殊名称会在编译之前的预处理阶段被替换成完整的路径，在编译之后这些特殊名称是不存在的。机器生成的 XiaoXuan Lang IR 代码总是写标识符全称的。


3. 在命名空间里不能定义跟直接子名称空间同名的标识符。

示例：

```clojure
(namespace foo
    (const bar 123)
)

(namespace foo.bar ;; 命名空间 `bar` 跟命名空间 `foo` 里面的常量 `bar` 有名称冲突
    ...
)
```

4. 在同一个 `namespace` 表达式里，不能定义跟使用 `use` 引入的标识符名称相同的标识符。

示例：

```clojure
(namespace foo
    (use mylib.A)
    (const A 123) ;; 常量 `A` 跟引入的标识符 `mylib.A` 名称冲突
)

(namespace foo
    (const A 456) ;; 因为位于另一个 namespace 表达式，这里的常量 `A` 不会跟上面的标识符 `mylib.A` 名称冲突
)
```

-->

