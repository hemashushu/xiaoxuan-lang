# 数据类型

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [数据类型](#数据类型)
  - [基本数据类型](#基本数据类型)
    - [整数](#整数)
    - [自然数](#自然数)
    - [实数](#实数)
    - [逻辑](#逻辑)
    - [字符](#字符)
  - [内置数据类型](#内置数据类型)
    - [字符串](#字符串)
      - [长字符串分行](#长字符串分行)
      - [模板字符串](#模板字符串)
        - [多行模板字符串](#多行模板字符串)
        - [自动截除前缀空白](#自动截除前缀空白)
      - [原始字符串（Raw String）](#原始字符串raw-string)
        - [多行原始字符串](#多行原始字符串)
        - [自动截除前缀空白](#自动截除前缀空白-1)
    - [散列字符串](#散列字符串)
    - [正则](#正则)
    - [有理数](#有理数)
    - [复数](#复数)
    - [二进制](#二进制)
    - [符号(::待挪走，挪到 “标准库-数学库” 里)](#符号待挪走挪到-标准库-数学库-里)

<!-- /code_chunk_output -->

## 基本数据类型

基本数据类型就是虚拟机（VM）能直接处理的数据类型。XiaoXuan 虚拟机只支持整型和浮点型两种，具体类型有：i8,i16,i32,i64,u8,u16,u32,u64 以及 f32, f64，XiaoXuan 的数据类型系统都是建筑于这些数据类型基础之上。

### 整数

整数的数据类型有：

* `整数64`（`Int64`）
* `整数32`（`Int32`）
* `整数16`（`Int16`）
* `整数8`（`Int8`）
* `整数`（`Int`），为 `整数64` 的别名。

类型后面的数字表示位宽，位宽决定能存储数字的范围，整数类型的比特（bit）最高有效位（MSB）用于表示符号（正负号），所以有一半用于表示负数，有一半表示正数。另外所有位全 1 表示 -1，所以负数的个数会比整数多 1 个，另外所有位全 0 表示 0 一般会跟正数一起用于表达无符号整数（即自然数）。

比如 8 位整数 `整数8` 能表示：

* \(-2^7\) 到 \(-1\) 共 128 个数；
* \(0\) 到 \(+2^7 - 1\) 共 128 个数。

加在一起总共能表示 \(2^8\) 即 256 个数。

整数的字面量（literals，即直接写在源码里的数据，硬编码数据）如 `123`，`1000` 等，默认类型是 `整数64`，为了方便书写，XiaoXuan 为 `整数64` 起了一个别名 `整数`。

XiaoXuan 支持的整数字面量写法如下：

* 支持在**数字之间**任意位置或者**末尾**插入任意数量下划线以表示分组，如 `123_000`，`4_56_7`，`12_34__56___` 等都是有效的整数字面量，但 `_123` 不是有效的整数字面量。
* 支持添加前缀 `0x`, `0b`，分别表示 16 进制和 2 进制，如 `0xff0011`，`0b1010`，`0b0000_1111`、`0x_a__b___c`。
* 支持汉字数字，包括“正负零一二三四五六七八九十点”，比如 `三点一四`，`一二三四`。

### 自然数

除了能表示正负数的整数类型（即有符号整数），还有只能表示正整数和零的，这种类型叫做无符号整数（Unsigned Integer），为简单起见 XiaoXuan 把该数据类型命名为 `自然数`（`Natural`）：

* `自然数64`（`Natural64`）
* `自然数32`（`Natural32`）
* `自然数16`（`Natural16`）
* `自然数8`（`Natural8`）
* `自然数`（`Natural`），为 `自然数64` 的别名。

自然数的所有比特位都用于表示数值，所以能表示 \(2^N\) （N 为位宽） 个数字。比如 8 位自然数 `自然数8` 能表示 0 到 \(2^8\) 即 256 共 256 个数字。

XiaoXuan 有一个动态的别名 `字宽`（`WordWidth`），它会根据机器的环境自动选择 `自然数64` 或者 `自然数32`。

### 实数

在 XiaoXuan 中，实数是指一定有小数部分的实数，一般也称为浮点数（Float）。实数的数据类型有：

* `实数64`（`Real64`）
* `实数32`（`Real32`）
* `实数`（`Real`） （为 `实数64` 的别名）。

实数字面量如 `3.14159`、`2.71828`、`123.4`、`1.23e4`、`-1.23e4`、`1.23e-4`，默认类型为 `实数`，即 `实数64`。

可以在字面量前面添加括号和类型名称以指定数据的类型，比如 `(Real32)321` 表示 `实数32` 类型。

XiaoXuan 支持的实数字面量写法如下：

* 支持在**数字之间**任意位置或者**末尾**插入任意数量下划线以表示分组，如 `1_234.56`、`12_.34__` 都是有效的实数字面量，但 `_12.34`、`12._34` 都不是有效的实数字面量。
* 支持 [IEEE 745-2008 标准](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)，实数包含正无穷、负无穷、正零、负零、还有一个 NaN（非数字）。正无穷 == 正无穷，负无穷 == 负无穷，NaN 跟任何数比较都不相等，包括跟自己比较也是不相等，即 NaN != NaN，而 (NaN != x) 总是返回 true。详细见 [IEEE 745](https://en.wikipedia.org/wiki/IEEE_754) 和 [NaN](https://en.wikipedia.org/wiki/NaN)。

### 逻辑

逻辑数据只有两个值：`真`（`true`）和 `假`（`false`），逻辑数据的数据类型是 `逻辑`（`Boolean`）。逻辑数据一般用在条件语句，用于判断条件是否成立。

XiaoXuan 不支持逻辑数据跟数字（整数、自然数、实数等）相互转换，也不支持跟字符、字符串、列表等等任何数据类型相互转换。有些编程语言用 0 表示 `假`，用非 0 表示 `真`，或者空字符串、空列表表示 `假`，非空字符串、非空列表表示 `真` 等等，XiaoXuan 皆不支持，也就是说条件语句只接受逻辑类型的值。

示例：

```julia
让 i = 123
如果 i 那么 # 这行会引起运行时错误
    ...
以上
```

在运行环境内部使用 `整数` 表示逻辑型数值，其中整数 `0` 表示 `false`，整数 `1` 表示 `true`。

逻辑数据类型是一种枚举类型，完整的值是 `Boolean::True` 和 `Boolean::False`，而 `true` 和 `false` 是关键字，在编译时会被自动替换为完整的值。

### 字节

`字节`（`Byte`） 是 `Natural8` 类型的别称。

### 字符

字符是用于存储单个字母、数字或者汉字等一个单独的 Unicode 码点，字符的数据类型是 `字符`（`Char`），<!-- 字符字面量使用一对单引号包围一个字符（TODO::考虑使用 `\C"` 格式），比如 `'a'`, `'8'`, `'中'` 等。--> 字符字面量使用 `\` 符号前导表示，比如：`\a`, `\8`, `\中`

有些字符无法用直接字面量表示，需要使用特殊的方式来表示，具体来说是使用一个反斜杠加一个字符的方式来转义。这些字符有：

* `\t`：制表符 ASCII 9
* `\n`：换行符 ASCII 10
* `\r`：回车符 ASCII 13
* `\\`：反斜杠

<!-- * `'\''`：单引号 -->

字符在运行环境内部使用 `自然数32`（`Natural32`） 来处理（即，在内存中的表示方式），但不是 `自然数32` 类型的别称，因为部分整数不是有效的 Unicode 码点，有效的 Unicode 码点范围是从 U+0000 到 U+D7FF 以及从 U+E0000 到 U+10FFFF。字符类型不能跟 `自然数32` 或者其他整数类型直接相互参与运算或者转换。

字符字面量也支持使用 16 进制的 Unicode 码点表示，有两种格式：

* `\xHH`：用于表示从 U+0000 到 U+007F 之间的字符，比如 `\x3A`；
* `\u{HHHHHH}`：用于表示从 U+0000 到 U+D7FF 以及从 U+E0000 到 U+10FFFF 之间的字符，比如 `\u{42}`。

字符字面量还支持希腊字母，比如：

* `\alpha` 表示 α
* `\beta` 表示 β
* `\psi` 表示 ψ
* `\omega` 表示 ω

希腊字符也可以通过常量 `希腊字母`（`GreekLetter`） 获取，比如 `GreekLetter.alpha` 的值为 \(\alpha\)，即字符 'α'，`GreekLetter.omega` 的值为 \(\omega\)，即字符 'ω'。详细可以参见[希腊字母列表](https://en.wikipedia.org/wiki/Greek_alphabet)，以及希腊字母对应的[中文读音](https://zh.wikipedia.org/zh-cn/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D)。

需要注意的是，一个 `字符` 类型数值只能表示 Unicode 上的一个码点，但视觉上的 "一个字" （有时也称为 `符文`、`rune`，或者称为 `字素`、`Grapheme`） 有时是由多个 `字符` 类型数值合在一起表示的，比如国旗符号 🇨🇳，它由 2 个 Unicode 码点 （U+1F1E8 U+1F1F3） 表示，又比如家庭符号 👨‍👩‍👧‍👦，它由 7 个 Unicode 码点（U+1F468 U+200D U+1F469 U+200D U+1F467 U+200D U+1F466）表示。在显示、编辑（比如移动光标）及打印文本时，应该以 `字素` 而不是一个 Unicode 码点作为 "一个字" 的单位，具体见 [Unicode 标准](https://en.wikipedia.org/wiki/Unicode)。

> 错误的 Unicode 码点将以符文 U+FFFD 来代替。

## 内置数据类型

内置数据类型即标准库里一部分数据类型，它们建筑在基本数据类型基础之上，是 XiaoXuan 语言层级直接支持的数据类型。

### 字符串

字符串即一系列字符，也就是常说的文本，字符串类型为 `字符串`（`String`），字符串字面量使用双引号（"）包围一串字符，如 `"abc"`，`"你好"`。字符串字面量必须在一行之内写完，不能分成多行。

在字符串字面量里，有些字符也是需要转义，这些字符有：

* `"\t"`：制表符
* `"\n"`：换行符
* `"\r"`：回车符
* `"\\"`：反斜杠
* `"\""`：双引号

在运行环境内部，`字符串` 使用 `数组<字节>` （`Array<Byte>`）存储，也就是说 `字符串` 类型实际上是对 `数组<字节>` 做了一层薄薄的包装（之所以需要包装，是因为在诸如 first(), each 等运算时，必须以 Unicode 码点作为单位）。一个字符串会使用 UTF-8 编码为一系列的 Byte 数组，跟一般 C 的字符串不同，XiaoXuan Lang 的字符串最末尾不包含 `\0` 字符。

#### 长字符串分行

当字符串比较长时，可以通过在行末写单独一个反斜杠符号 `\` （作分行符），表示下一行仍然是当前字符串的组成部分。注意分行符下一行的所有前缀空格符（包括制表符、换行符等）会被忽略，直到第一个非空格字符。注意这跟 JavaScript 不完全相同，JavaScript 里分行符的下一行字符串的前面空格会被包含进来。

```js
let s = "hello \
         world \
           foo\
           bar"

s == "hello world foobar"
```

#### 模板字符串

模板字符串是指允许在字符串中间插入其他数据的字符串，模板字符串同样使用 "`...`" 符号（即一对反单斜杠）包围。

示例：

```js
让 name = "张三"
让 s1 = `你好, {name}`
```

```js
let name = "foo"
let s1 = `hello, {name}`
```

其中 `{...}` 为模板字符串占位符，占位符里面可以是其他数据的字面量，可以是一个上下文存在的变量，<!-- ::TODO:: 暂时不考虑表达式，实现起来有难度:: 也可以是一个表达式，甚至可以是一段有返回值的语句 只要返回一个字符串即可。-->

模板占位符支持格式化，在数据之后添加一个冒号 `:`，然后加上格式表达式。

示例：

* `{name:15}`：name 是一个字符串变量，表示字符串最小宽度为 15 个字符（不足 15 个字符会在右侧补空格）；
* `{name:.6}`：name 是一个字符串变量，表示限制字符串最大宽度为 6 个字符，超出 6 个的字符直接被截除。

XiaoXuan 支持大部分 Rust 字符串格式化格式，可以参考《Programming Rust》 P337 "格式化值" 一节。（同时也参考 https://docs.python.org/3/library/string.html#format-string-syntax）

在模板字符串字面量里，有些字符也是需要转义，这些字符有：

* `"\t"`：制表符
* `"\n"`：换行符
* `"\r"`：回车符
* `"\\"`：反斜杠
* `"\`"`：反单引号
* `"\{"`：左花括号
* `"\}"`：右花括号

##### 多行模板字符串

模板字符串跟普通字符串一样，也允许使用分行符（即位于行末的单独一个反斜杠符号 `\`）写成多行。不过模板字符串还支持直接写成多行，直到遇到一个没有转义的反单引号才表示模板字符串结束。

示例：

```js
let html =
    `<div class="item" data-id="{item.id}">
       <div class="id">{item.id}</div>
       <div class="name">{item.name}</div>
     </div>`
```

> 模板字符串会保留所有换行符和空白字符。

##### 自动截除前缀空白

在第一个单反斜杠后面换行，则第一行正文前缀的空白将会被截除（trim），正文其他行的前缀空白将会按照第一行的前缀空白数量自动截除。

示例：

```js
01  let html =`
02      <div class="item" data-id="{item.id}">
03        <div class="id">{item.id}</div>
04        <div class="name">{item.name}</div>
05      </div>`
```

上面 02 行为正文开始行，它前面的 4 个空白将会被截除，从第 03 行开始到 05 行都是正文，每行前面都会被截除 4 个空白。

##### 自定义处理模板字符串的函数

模板字符串默认返回的是模板字面量和其中的占位符的值所连接起来的字符串，其实也可以指定处理的函数，只需在模板字符串字面量前面加上函数名称即可。模板字符串字面量实际上返回的是两个数组：一个是字符串字面量，另一个是占位符表达式。如果字面量没有指定处理字符串，则默认处理函数为 `std::String::template`。

示例：

```js
let foo = "cat"
let bar = "dog"
let s = someFunc `hello {foo} world {dog:5}`
```

会转换为：

```js
let foo = "cat"
let bar = "dog"
let s = someFunc (["hello ", " world"],[foo, String::paddingRight(dog, 5)])
```

上例中的 `someFunc` 为自定义的模板字符串处理函数，只要参数是两个 `String` 数组类型的函数都可以作为处理函数，函数的功能和返回值没有限制。

可以在模板字符串后面加入一个值，用于向模板处理函数传入数据，这种情况下 XiaoXuan 将不会解析模板字符串的内容，而是完全由模板字符串自己处理，比如 `handlebars` 函数：

```js
let data = JsonMap {
    user: ["foo","bar"]
    };

let s = handlebars `
    <ul class="people_list">
      {{#each people}}
          <li>{{this}}</li>
      {{/each}}
    </ul>` data
}
```

XiaoXuan 运行时调用 handlebars 如下：

```js
let s = handlebars(text, data)
```

其中 `text` 是在处理转义字符和截除前缀空白后的字符串，它将会连同 `data` 参数传递给 handlebars 函数。

更多的 Handlebars 语法请参阅：[handlebarsjs](https://handlebarsjs.com/)

#### 原始字符串（Raw String）

原始字符串即原样表示的字符串，在源码当中原始字符串是怎样的呈现，其值就是怎样。即原始字符串不会对其中的内容进行转义。

原始字符串字面量使用三个双引号包围一串字符。

示例：

* `"""你好\😄/"""`
* `"""hello\😄/"""`

在书写正则表达式时，使用原始字符串能避免频繁转义表达式内部的特殊字符。

示例：

```js
01  # 为了匹配类似 `\"123"/` 这样的字符串
02  let s1 = Regex("^\\\\\\"\\d{3}\\"\/$")
03  let s2 = Regex("""^\\"\d{3}"\/$""")
```

上面例子中 02 行使用普通字符串格式，03 行使用原始字符串格式，它们的值相同。

##### 多行原始字符串

原始字符串允许直接写成多行，直到遇到连续的三个双引号才表示结束。

示例：

```js
01  让 s = """第一行
02      第二行
03      第三行"""
```

```js
01  let s = """line one
02      line two
03      line three"""
```

其值为 `"第一行\n🈳🈳🈳🈳第二行\n🈳🈳🈳🈳第三行"`

##### 自动截除前缀空白

在第一个三双引号后面换行，则正文部分的第一行（即上面例子的 02 行）的第一个非空白字符表示正文的开始，正文部分其他行的前缀空白字符会根据正文第一行的前缀空白个数**自动截除**（空白字符不足的话则只截除实际个数空白）。

```js
01  让 s = """
02      世界
03        你好"""
```

```js
01  let s = """
02      hello
03        world"""
```

上面示例的字符串的值为 `世界\n🈳🈳你好`（`"hello\n🈳🈳world"`）。

### 散列字符串

因为字符串常用于映射表的键，但 `字符串` 类型 <!-- 只是 `数组<字符>`（`Array<Char>`）的别称，--> 缺少散列值，所以使用字符串作为映射表的键时，可以使用 `散列字符串`（`HashString`）。`散列字符串` 基本上跟 `字符串` 一模一样，只不过在构造时自动计算了一个散列值。

示例：

```js
让 map1 = 新建 映射表<HashString, Int>()
让 key1 = 新建 HashString("abc")
让 map2 = map1.添加(key1, 100)
让 value1 = map2[key1]  // value1 == 100
```

散列字符串的字面量是使用 `#` 前导的一个字符串组成。

示例：

```js
让 key1 = #abc
让 key2 = #foo
让 key3 = #abc

断定(key1 != key2)
断定(key1 == key3)
```

如果字符串里面含有诸如空格，标点符号等，则可以使用双引号包围起来。

示例：

```js
let key1 = #"foo bar"
let key2 = #"hello \" world!"
```

散列字符串依据其字符串本身所计算的散列值进行相等或者大小比较，使用散列字符串字面量时，无需事先赋值给一个变量，可以直接使用。

下面使用散列字符串重写前一个示例：

```js
让 map1 = 新建 映射表<HashString, Int>()
让 map2 = map1.添加(#abc, 100)
让 value1 = map2[#abc]
```

### 正则

字面量格式 `/正则表达式/`

```js
let r1 = /[a-zA-Z]+/
let m1 = r1.match("hello world");
```

正则构造函数 `Regex(String, Options)` 和 `Regex(Regex, Options)`，用于构造带有选项的正则对象。

// TODO::

也可以使用正则表达式生成器构造正则对象，示例：

```js
use RegBuilder::new as rb

let r1 = rb()
    .startOfLine()
    .then(\[)
    .or(
        rb("http"),
        rb("https")
    )
    .then("://")
    .group(
        rb()
            .oneOrMore(RegBuilder::notSpace)
    )
    .maybe(
        rb(RegBuilder::space)
            .then(\")
            .oneOrMore(RegBuilder::Any)
            then(\")
    )
    .then(\])
    .endOfLine()
    .build()

// equals to:

let r2 = /^\[(http|https):\/\/(\S+)( ".+")?\]$/
```

类似的工具：
https://github.com/VerbalExpressions/JSVerbalExpressions

### 有理数

有理数的数据类型是 `有理数`（`Rational`）。字面量使用符号 `'/` 分隔分子和分母，分子和分母必须是整数（对应 XiaoXuan 的 `整数` 和 `自然数` 这两种类型）。

::TODO
可以考虑 数字+r 的表示方法，类似：2r / 3，与复数的表示方法一致（如 2 + 3i）

示例：

```julia
让 i = 2r / 3
让 j = 1r / 2
让 k = i + j        # k == 7r / 6
```

```julia
let i = 2r / 3
let j = 1r / 2
let k = i + j        # k == 7r / 6
```

符号 `\` 前后的空格可有可无。

有理数也可以使用构造函数构建：

```julia
让 i = 有理数(2, 3)  # 2r / 3
让 j = 有理数(1, 2)  # 1r / 2
让 k = i + j        # k == 7r / 6
```

```julia
let i = Rational(2, 3)  # 2r / 3
let j = Rational(1, 2)  # 1r / 2
let k = i + j        # k == 7r / 6
```

为了避免分子分母跟表达式的其他数据混淆，可以使用一对括号把有理数包围起来。

示例：

`let i = (2r / 3) / 2`

实际上符号 `/` 是运算符，所以该符号前后可以是字面量，也可以是变量。

示例：

```julia
let i = 123
let j = 456
let k = i \ j  # k == 123\456
```

### 复数

复数的数据类型是 `复数`（`Complex`），字面量使用格式 `X + Yi` 的格式表示，其中的 `+` 和 `i` 是固定格式，`X` 和 `Y` 是实数，分别表示复数的实部和虚部，对于 XiaoXuan 来说，`X` 和 `Y` 可以是 `整数`、`自然数` 或者 `实数` 的字面量。

示例：

```julia
let i = 3+4i
let j = 1+4i
let k = i+j     # k == 4+8i
```

其中实部可以省略，表示实部为 0 的纯虚数。

示例：

```julia
let i = 4i
let j = 3.45i
```

需要注意的是，复数字面量当中的符号 `+` 不表示加法，而是固定的格式，也就是说实部和虚部的数字都必须是字面量，而不能是变量。

示例：

```julia
let n = 123
let i = n + 4i  # `+` 号前面不是数字字面量
let j = 4 + ni  # `i` 前面不是数字字面量
```

上面例子都无法构建出复数。

复数也可以使用构造函数构建。

示例：

```julia
let i = Complex(3, 4) # 3+4i
let j = Complex(1, 4) # 1+4i
let k = i+j           # k == 4+8i
```

为了避免复数的实部跟表达式的其他数据混淆，可以使用一对括号把复数字面量包围起来。

示例：

`let i = 2 * (3+4i)`

注意复数只能作相等比较而不能作大小比较，参见[复数的介绍](https://en.wikipedia.org/wiki/Complex_number)。

### 二进制

二进制数据类型是 `二进制`（`Binary`）。跟 `整数` 类型的二进制字面量不一样，`二进制` 是单独的一种数据类型，而 `整数` 的二进制字面量仍然是 `整数` 类型。

`二进制` 字面量使用 `位宽 + 数制符号 + 数值` 的格式表示。

示例：

```js
let a = 8b0000_1111 // 等同 8b1111
let b = 8h0F
let c = 8d15
```

二进制值可以使用 `获取`（`get`）函数读取每一位的值。

示例：

```
let a = 8b0000_1111
let b1 = a.get(1)
let b2 = a.get(5)
```

`获取` 函数的参数是指定比特位的位置值，二进制字面量最右边为第 1 位，即最低有效位，从 1 开始数（不是从 0 开始数）。注意位置值不能超出该二进制数值的有效范围，否则会引起运行时异常。

上例变量 `b1` 的值为 `1b0`，变量 `b2` 的值为 `1b1`。

二进制值还可以通过 `选取`（`slice`） 函数读取其中的部分值。

示例：

```js
let a = 8'b0000_1111
let b = a.slice(3, 6)
```

`选取` 函数的两个参数分别表示选择范围的开始位置值以及选取比特的数量。上例表示从二进制变量 `a` 的第 3 位开始，取 6 位比特，结果变量 `b` 的值为 `6'000011`。

也可以使用一对中括号 `[...]` 替代调用 `选取` 函数。

示例：

* `让 b = a[3:6]`
* `let b = a[3:6]`

结果跟上例是一样的。

需注意，开始位置和数量不能超出有效范围，否则会引起运行时异常。

二进制数还支持位运算、连接等函数，详细见语言参考手册。

### 符号(::待挪走，挪到 “标准库-数学库” 里)

`符号`（`Symbol`）类型的数据用于生成一个代号，代号可以用作代数的变量。符号类型数据没有字面量，只能通过构造函数构建。

示例：

```js
让 x = 符号('x')
让 x_alt = 符号("x'")
让 x1 = 符号("x1")
让 y = 符号('y')
```

```js
let x = Symbol('x')
let x_alt = Symbol("x'")
let x1 = Symbol("x1")
let y = Symbol('y')
```

`符号` 构造函数接受一个字符或者一个字符串，上面代码分别生成了符号 \(x\)，\(x'\)，\(x1\) 和 \(y\)。

常数 `希腊字母符号`（`GreekLetterSymbol`） 列出了从 α 到 ω 的 `符号` 实例。比如 `GreekLetterSymbol.beta` 的值为 `Symbol('β')`。

符号实例可以通过 `下标`（`subscript`）方法添加下标。

示例：

```js
let a = Symbol('a')
let a1 = a.subscript('1')
```

变量 `a1` 的值就是 \(a_1\)，注意它的值跟由字符串 `a1` 构成的符号实例是不相同的。

构造时传入相同的字符或者字符串而产生的两个符号数据的值相等，符号数据的值可以用其包含的字符串表示，但不能跟字符串直接比较，也无法排序。

符号数据可以用于产生算式对象。

示例：

```js
let z = x^2 + 2*x*y + y^2
```

上面例子的变量 `z` 的值为一个算式，其值为：

$$
z = x^2 + 2xy + y^2
$$

示例：

```js
let x = Symbol('x')
let N = 100
let y = sum([1..N].map(fn (n) x ^ n / n))
```

上面的代码会产生如下算式：

$$
y = \frac{x^1}{1} + \frac{x^2}{2} + \frac{x^3}{3} + \cdots + \frac{x^n}{n}
$$

算式对象可以用于计算值，也可以用于解方程，求微分和积分等，可以参考 [SymPy 函数库](https://www.sympy.org/en/)。
