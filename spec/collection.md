# 数据集合

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [数据集合](#数据集合)
  - [列表](#列表)
    - [使用构造函数构建列表](#使用构造函数构建列表)
    - [获取列表的长度](#获取列表的长度)
    - [访问列表的元素](#访问列表的元素)
      - [获取第一个元素](#获取第一个元素)
      - [获取第一个元素之外的元素](#获取第一个元素之外的元素)
      - [获取最后一个元素](#获取最后一个元素)
      - [获取最后一个之外的元素](#获取最后一个之外的元素)
      - [根据位置获取元素](#根据位置获取元素)
        - [使用中括号获取指定位置的元素](#使用中括号获取指定位置的元素)
    - [选取指定范围的元素](#选取指定范围的元素)
      - [使用中括号选取指定范围的元素](#使用中括号选取指定范围的元素)
        - [省略 "元素个数"](#省略-元素个数)
        - [省略 "开始位置"](#省略-开始位置)
    - [修改列表](#修改列表)
    - [增加元素](#增加元素)
    - [追加元素或列表](#追加元素或列表)
    - [删除元素](#删除元素)
    - [过滤元素](#过滤元素)
    - [拆分列表](#拆分列表)
    - [连接列表](#连接列表)
    - [裁剪](#裁剪)
    - [补齐](#补齐)
    - [重复序列](#重复序列)
      - [重复字符串](#重复字符串)
    - [平分列表](#平分列表)
    - [分隔列表](#分隔列表)
    - [`拼接` ::TODO](#拼接-todo)
    - [插入元素或列表](#插入元素或列表)
    - [替换元素或列表](#替换元素或列表)
    - [排序列表 ::TODO](#排序列表-todo)
    - [反转列表 ::TODO](#反转列表-todo)
    - [查找元素或（子）列表的出现位置](#查找元素或子列表的出现位置)
    - [reverseFindPosition](#reversefindposition)
    - [查找元素](#查找元素)
    - [检查指定元素是否存在](#检查指定元素是否存在)
      - [存在开始 ::TODO](#存在开始-todo)
      - [存在结束 ::TODO](#存在结束-todo)
    - [`全部匹配` ::TODO](#全部匹配-todo)
    - [`逐个` 函数](#逐个-函数)
    - [`映射` ::TODO](#映射-todo)
    - [折叠 ::TODO](#折叠-todo)
    - [右折叠 ::TODO](#右折叠-todo)
    - [构建随机数列表](#构建随机数列表)
  - [数列](#数列)
    - [步进值](#步进值)
    - [线性值](#线性值)
    - [动态指定开始值、结束值和步进值](#动态指定开始值-结束值和步进值)
    - [浮点数数列](#浮点数数列)
    - [字符数列 (::未支持)](#字符数列-未支持)
    - [延迟执行](#延迟执行)
    - [省略结束值](#省略结束值)
  - [数集](#数集)
  - [数组](#数组)
    - [字符数组](#字符数组)
      - [toUpperCase](#touppercase)
      - [toLowerCase](#tolowercase)
      - [裁剪空白 ::TODO](#裁剪空白-todo)
      - [全部替换 ::TODO](#全部替换-todo)
    - [多维数组](#多维数组)
    - [矩阵](#矩阵)
  - [列表、数组、列表的比较](#列表-数组-列表的比较)
    - [使用场景](#使用场景)
  - [序列的常用函数](#序列的常用函数)
    - [数字列表](#数字列表)
    - [字符列表](#字符列表)
  - [表格](#表格)
  - [映射表](#映射表)
    - [访问映射表的元素](#访问映射表的元素)
      - [使用中括号获取指定键的值](#使用中括号获取指定键的值)
      - [使用模式解构获取指定键的值](#使用模式解构获取指定键的值)
    - [添加新的 "键-值对"](#添加新的-键-值对)
    - [更新已存在的键值](#更新已存在的键值)
    - [添加或更新 "键-值对"](#添加或更新-键-值对)
      - [使用三个点来添加或更新 "键-值对"](#使用三个点来添加或更新-键-值对)
    - [检查指定键是否存在](#检查指定键是否存在)
    - [删除 "键-值对"](#删除-键-值对)
    - [删除多个 "键-值对"](#删除多个-键-值对)
    - [过滤 "键-值对"](#过滤-键-值对)
    - [遍历映射表元素](#遍历映射表元素)
  - [集](#集)
    - [转换为普通列表](#转换为普通列表)

<!-- /code_chunk_output -->

## 列表

多个数据类型相同的数据依次连接便形成 `列表`（`List`）。

列表的字面量使用一对中括号 `[...]` 包围所有数据，每项数据称为 "元素"，元素之间使用逗号分隔。

示例：

```js
让 a = [1, 2, 3]
让 b = [3.14, 2.718, 0.618]
让 c = ["天地玄黄", "宇宙洪荒", "日月盈昃", "辰宿列张"]
让 d = [真, 假, 假, 真]
```

```js
let a = [1, 2, 3]
let b = [3.14, 2.718, 0.618]
let c = ["twinkle", "twinkle", "little", "star"]
let d = [true, false, false, true]
```

上面的语句分别构建了四个列表：

* `列表<整数>`（`List<Int>`）
* `列表<浮点数>`（`List<Float>`）
* `列表<字符串>`（`List<String>`）
* `列表<逻辑>`（`List<Boolean>`）

一个列表里不能同时存在不同类型的元素，比如下列的语句是错误的：

```js
让 a = [100, 200, 2.9979e8, 6.67e-11]  # 前两个元素是整数型，后两个是浮点型。
让 b = ["寒来暑往", 真, "秋收冬藏"]     # 前后两个是字符串型，中间是逻辑型。
```

```js
let a = [100, 200, 2.9979e8, 6.67e-11] # there are both Int and Float
let b = ["hickory", true, "dickory"]  # there are both String and Boolean
```

注意：

* 列表最后一个元素后面可以加逗号，也可以不加。
* 列表的元素可以分行写。

### 使用构造函数构建列表

使用构造函数也可以构建一个列表。

示例：

* 让 a1 = 新建 数组(5, 0)
* let a1 = new Array(5, 0)

构造函数的第一个参数指定列表的长度，第二个参数指定元素的初始值。

上面示例构建了一个有 5 个元素，且所有元素的值都是整数 0 的列表，即 `[0, 0, 0, 0, 0]`。

需要注意的是，列表一旦构建之后，其长度和元素的值都是无法更改的。

### 获取列表的长度

使用 `长度`（`length`）函数可以获取列表元素的数量（有时也称为列表的 `大小`，`size`）。

示例：

```js
让 i = a.长度()
# 让 i = 长度 (a)
```

```js
let i = a.length()
# let i = length (a)
```

注意上面列出的两句是等效的，即 `长度` 这个函数既能单独调用，也能够以列表的方法的方式调用，详细见 [函数](function.md) 一章。

### 访问列表的元素

XiaoXuan 的列表虽然跟函数式编程语言（Clojure, Haskell, Lisp 等）的列表概念相似，但对列表操作的函数名称有所不同，比如常见的 "head，tail，init，last" 函数分别表示获取 "第一个"、"第一个之外"、"最后一个之外"、"最后一个" 元素，XiaoXuan 使用更接近日常生活习惯的名称。

#### 获取第一个元素

使用 `第一个`（`first`）函数可获取列表的第一个元素。

示例：

```js
让 a = [1, 2, 3, 4, 5]
让 i = 第一个 (a)
# 让 i = a.第一个()
```

```js
let a = [1, 2, 3, 4, 5]
let i = first (a)
# let i = a.first()
```

上例中变量 `i` 的值将会是整数 `1`。

对一个空列表执行 `第一个` 函数会引发运行时异常。

有时想试探性地获取第一个元素（即免去检测列表是否为空这个步骤），可以使用 `尝试第一个`（`tryFirst`）函数，其返回值是 `可选<T>`（`Option<T>`），列表为空时它返回 `可选::无`，而不是直接抛出运行时错误。当列表不为空时，则返回 `可选::有(value)`

示例：

```js
let v1 = [1, 2, 3, 4, 5].tryFirst()  # Option::Some(1)
let v2 = [].tryFirst()               # Option::None
```

#### 获取第一个元素之外的元素

使用 `其余`（`rest`）函数可获取列表中除了第一个元素之外的其余元素，函数返回由其余元素组成的一个新列表。

示例：

```js
让 a = [1, 2, 3, 4, 5]
让 i = a.其余()
# 让 i = 其余 (a)
```

```js
let a = [1, 2, 3, 4, 5]
let i = a.rest()
# let i = rest (a)
```

上例中变量 `i` 的值将会是 `[2, 3, 4, 5]`。

对一个空列表执行 `其余` 函数总会返回空列表。

> 通过循环地依次使用 `添加`->`第一个`->`其余` 三个函数，可以实现经典的 `FILO` 栈功能。

#### 获取最后一个元素

使用 `最后一个`（`last`）函数可获取列表的最后一个元素。

```js
让 a = [1, 2, 3, 4, 5]
让 i = a.最后一个()
# 让 i = 最后一个 (a)
```

```js
let a = [1, 2, 3, 4, 5]
let i = a.last()
# let i = last (a)
```

上例中变量 `i` 的值将会是整数 `5`。

对一个空列表执行 `最后一个` 函数会引发运行时异常。

有时想试探性地获取最后一个元素，可以使用 `尝试最后一个`（`tryLast`）函数，其返回值是 `可选<T>`（`Option<T>`），列表为空时它返回 `可选::无`，而不是直接抛出运行时错误。当列表不为空时，则返回 `可选::有(value)`

示例：

```js
let v1 = [1, 2, 3, 4, 5].tryLast()  # Option::Some(5)
let v2 = [].tryLast()               # Option::None
```

#### 获取最后一个之外的元素

使用 `最后一个除外`（`exceptLast`）函数可以获取列表中除了最后一个元素之外的其他元素，函数返回一个除了最后一个元素的新列表。

示例：

```js
let a = [1, 2, 3, 4, 5]
let b1 = a.exceptLast()
let b2 = b1.exceptLast()
```

最后变量 `b1` 的值为 `[1, 2, 3, 4]`（列表），变量 `b2` 的值为 `[1, 2, 3]`。

对一个空列表执行 `最后一个除外` 函数总会返回空列表。

> 通过循环地依次使用 `添加`->`最后一个`->`最后一个除外` 三个函数，可以实现经典的 `FIFO` 列表功能。

#### 根据位置获取元素

使用 `获取`（`get`）函数可根据指定的位置获取元素。`获取` 函数的原型是：

* `获取 (位置, 列表实例)`
* `get (position, listInstance)`

函数的第一个参数表示指定元素的位置值。

需注意：

* 位置值从数字 1 开始，而不是从 0 开始；
* 位置值的最大值为列表的长度，也就是说，位置值的有效范围是从 "0" 到 "列表的长度"；
* 位置值不能超出列表的范围，即小于 1 或者大于列表长度，否则会引起运行时错误。

示例：

```js
让 a = [1, 2, 3, 4, 5]
让 i = a.获取(2)
# 让 i = 获取 (2, a)
```

```js
let a = [1, 2, 3, 4, 5]
let i = a.get(2)
# let i = get (2, a)
```

上例中变量 `i` 的值将会是整数 `2`。

> 因为列表一般通过使用单向链表来实现，所以按位置来访问元素的效率比较低，函数需要逐个元素遍历直到指定的位置为止，我们应该尽量避免高频次使用位置值来访问列表元素。如果需要高频次按位置访问元素，可以使用下面将会讲述的 `数组` 数据类型。

有时想试探性地获取一个位置的值（即免去实现检查有效范围的步骤），则可以使用 `尝试获取`（`tryGet`）函数。函数返回 `可选<T>`（`Option<T>`），如果指定的位置在有效范围之内，则返回 `可选::有(value)`，否则返回 `可选::无`。

示例：

```js
let a = [1, 2, 3, 4, 5]
let i = tryGet(2, a)
let j = tryGet(10, a)
```

上例中变量 `i` 的值为 `可选::有(2)`，变量 `j` 的值为 `可选::无`。

##### 使用中括号获取指定位置的元素

除了使用 `获取` 函数，还可以在列表后面使用中括号表达式 `[N]` 方便地按位置访问列表元素。

示例：

* `让 i = a[2]`
* `let i = a[2]`

中括号里面写上需要获取的元素的位置值，表达式会被解析为调用函数 `获取`。

> 使用中括号访问列表元素在外观上很像 C、Java 等语言的数组按索引值访问元素，不过索引值表示的是相对第一个元素的偏移量，所以是从 0 开始的。而 XiaoXuan 使用我们日常生活中的次序概念，也就是位置值而不是索引值或者偏移量，所以从数字 1 开始。

### 选取指定范围的元素

使用 `选取`（`slice`） 函数可以选取指定范围的元素，并返回一个新列表。函数的原型是：

* `选取 (开始位置, 元素个数, 列表实例)`
* `slice (startPosition, count, listInstance)`

`选取` 函数各参数的含义：

* 第 1 个参数表示选取范围的开始位置，取值范围从 1 到 "列表的长度"，选取的结果包括此位置的元素；
* 第 2 个参数表示选取元素的个数，取值范围从 0 到 "列表长度 - 开始位置 + 1"。比如假设一个列表有 10 个元素，开始位置值为 `2`，则有效的选取元素个数为 `0` 到 `9`（9 = 10 - 2 + 1）。
* 第 3 个参数为源列表。

需注意：

* 如果 "元素个数" 参数传入 `0`，则会返回一个空列表 `[]`；
* "开始位置" 以及 "元素个数" 都不能超出列表的范围，否则都会引起运行时异常。

示例：

```js
让 a = [1, 2, 3, 4, 5]
让 b2 = a.选取 (2, 3)
# 让 b1 = 选取 (2, 3, a)
```

```js
let a = [1, 2, 3, 4, 5]
let b2 = a.slice (2, 3)
# let b1 = slice (2, 3, a)
```

上面示例表示从列表 `a` 的第 2 个元素开始（包括第 2 个元素），选取 3 个元素，因此变量 `b` 的值将会是 `[2, 3, 4]`。

`选取` 函数有一个省略 "元素个数" 参数的重载，表示选取从 "开始位置" 到列表的最后一个元素，示例：

* `让 c = 选取 (4, a)`
* `let c = slice (4, a)`

变量 `c` 的值将会是 `[4, 5]`。

对于获取列表后面任意 N 个元素的代码如下：

```js
let N = 3
let c = a.slice(a.length() - N + 1)
# let c = slice(a.length() - N + 1, a)
```

#### 使用中括号选取指定范围的元素

除了使用 `选取` 函数，还可以在列表后面使用中括号表达式 `[Position:Count]` 选取列表指定范围的元素。

示例：

```js
让 a = [1, 2, 3, 4, 5]
让 b = a[2:3]
```

```js
let a = [1, 2, 3, 4, 5]
let b = a[2:3]
```

中括号里分别位选取的开始位置以及选取的元素个数，表达式会被解析为调用函数 `选取`。

上面示例的语句表示从列表 `a` 的第 2 个元素开始（包括第 2 个元素），选取 3 个元素，变量 `b` 的值将会是 `[2, 3, 4]`。

##### 省略 "元素个数"

如果省略 "元素个数"，表示选取从 "开始位置" 到列表的最后一个元素，示例：

* `让 c = a[4:]`
* `let c = a[4:]`

上例中变量 `c` 的值将会是 `[4, 5]`。

##### 省略 "开始位置"

如果省略 "开始位置"，则表示选取列表最后指定个数的元素。

示例：

* `让 b = a[:3]`
* `let b = a[:3]`

上面示例表示选取列表 `a` 的最后 3 个元素，所以变量 `b` 的值将会是 `[3, 4, 5]`。

表达式 `a[:N]` 会被解析为函数调用 `slice(a.length() - N + 1, a)`。

### 获取开始部分的元素

::TODO::
 `开始部分` `take`
  `序列<T> <- 开始部分 (整数 数量, 序列<T> 目标)`
  `Seq<T> <- take (Int count, Seq<T> target)`

### 修改列表

XiaoXuan 所有类型的数据都不支持更改，自然也无法对一个列表增加、修改或者删除元素。或者说，所有对列表的更改都会产生一个新的列表。比如向一个列表增加一个元素将会返回一个 "包含有新增的那个元素" 的新列表，而原先那个列表仍保持不变。

运行环境内部一般采用单向链表来实现列表，在单向链表的头部（最新元素的那端，有时也称为开始端）添加元素能在常数时间内完成，所以如果要增加列表元素，一般都是往列表的头部添加。另一方面，往列表末尾追加元素的效率则非常低（因为要重新构建一次列表）。

为了简化应用，XiaoXuan 运行环境一般使用两个单向链表，让它们尾尾相连的组成一个列表，其中一个链表的头作为列表的尾，因此无论是在列表的头部还是尾部添加或删除元素，都能在常数时间内完成。

下面表示一个有 3 个元素的列表，其中元素 `a` 这一端是列表的 "头部"，元素 `a` 称为 `第一个` 元素；元素 "c" 那端是列表的 "尾部"，元素 `c` 称为 `最后一个` 元素。

| a | b | c |
|---|---|---|
| 1 | 2 | 3 |

上表第二排表示元素的位置（次序），第一个元素的位置值是 1，第二个元素的位置值是 2，如此类推。

使用 `添加` 函数往这个列表增加元素 "n"，得到一个如下的新列表：

| n | a | b | c |
|---|---|---|---|
| 1 | 2 | 3 | 4 |

现在列表的头部，也就是第一个元素变成了 `n`，应该注意到原有元素（即 `a`、`b`、`c`）的位置值都被改变了，这是因为新增加的元素是以 "插队" 的形式被添加到列表的头部，原有的元素的位置都被往后挪了一个。

### 增加元素

使用一对中括号和 `展开符号` "..."（即三个点号）的表达式可以实现往列表头部添加一个元素。

示例：

假设有列表 `a`：

* `让 a = [1, 2, 3]`
* `let a = [1, 2, 3]`

现在要添加整数 `88` 到列表头部，则语句如下：

* `让 b = [88, ...a]`
* `let b = [88, ...a]`

上例将会得到一个新的列表并赋值给变量 `b`，其值为 `[88, 1, 2, 3]`。

也可以一次添加多个元素，比如：

* `让 c = [77, 88, 99, ...a]`
* `let c = [77, 88, 99, ...a]`

这样又会产生一个新的列表，并赋值给变量 `c`，其值为 `[77, 88, 99, 1, 2, 3]`。

需注意:

* 新添加的元素总是以 "插队" 的形式出现在列表的头部。
* 关键字 `...` 只能出现在中括号的末尾，比如语句 `[...a, 4, 5]` 语法是错误的。

表达式 `[x, ...a]` 会被解析为调用函数 `添加`（`add`）。

函数 `添加` 的原型是：

* `Seq<T> <- add (T, Seq<T>)`
* `Seq<T> <- add (Seq<T> additional, Seq<T> target)`

示例：

```js
让 b = [8, ...a]  # 这条语句会被解析为如下两句的其中一个
让 b = a.添加(8)
# 让 b = 添加 (8, a)

让 c = [77,88,99, ...a]  # 这条语句会被解析为如下两句的其中一个
让 c = a.添加([77,88,99])
# 让 c = 添加 ([77,88,99], a)
```

```js
let b = [8, ...a]  # This statement will be parsed as one of the following two statements
let b = a.add(8)
# let b = add (8, a)

let c = [77,88,99, ...a]  # This statement will be parsed as one of the following two statements
let c = a.add([77,88,99])
# let c = add ([77,88,99], a)
```

需注意表达式 `[x, y, z, ...a]` 也可能会被解析为多次调用 `添加(T, seq<T>)` 函数，具体由运行时决定，但无论如何结果都是一样的。

### 追加元素或列表

使用 `追加`（`append`） 函数可以在一个列表的末尾追加元素或者另一个列表。

`追加` 函数的原型是：

* `Seq<T> <- append (T, Seq<T>)`
* `Seq<T> <- append (Seq<T> additional, Seq<T> target)`

示例：

```js
让 a = [1,2,3,4,5]
让 aa = a.追加(99)
让 ab = a.追加([77,88,99])
```

```js
let a = [1,2,3,4,5]
let aa = a.append(99)
let ab = a.append([77,88,99])
```

最后变量 aa 的值为 `[1,2,3,4,5,99]`，ab 的值为 `[1,2,3,4,5,77,88,99]`。

> 跟 `添加` 函数不同，往列表 `追加` 元素不会改变原有元素的位置值。

### 删除元素

对列表调用 `删除`（`remove`）函数将会返回一个新的 "且删除了指定元素的" 列表。

`删除` 函数的原型是：

* `Seq<T> <- remove (position, Seq<T>)`
* `Seq<T> <- remove (startPos, count, Seq<T>)`
* `Seq<T> <- remove (Boolean <- (T), Seq<T>)`

示例：

```js
让 a = [1,2,3,4,5]
让 e = a.删除(2)
```

上例中 `删除` 函数的参数表示待删除的元素的位置值。结果变量 `e` 的值为 `[1,3,4,5]`。

注意位置值必须在合法的范围，否则会抛出运行时异常。

`删除` 函数的第二个重载用于删除指定范围的元素，两个参数的含义跟`选取` 函数的一样，分别表示 "开始位置" 和待 "删除元素的个数"。

示例：

```js
让 a = [1,2,3,4,5]
让 e = 删除(2, 3, a)
# 让 e = a.删除(2, 3)
```

```js
let a = [1,2,3,4,5]
let e = remove(2, 3, a)
# let e = a.remove(2, 3)
```

上面示例表示从列表 `a` 的第 2 个元素开始，共删除 3 个元素，结果变量 `e` 的值将会是 `[1, 5]`。

运行环境使用获取部分元素的方法实现 `删除` 函数的功能，下面演示的是等效代码：

```py
# 目的：删除列表的第 1 个元素
# 方法：获取除了第 1 个元素之外的剩余元素
让 b = a.其余()
让 [_, ...b] = a

# 目的：删除列表的前 N 个元素（0 <= N <= 列表长度 - 1）
# 方法：获取从位置 N+1 开始往后的所有元素
让 c = a.选取(N+1)
让 c = a[N+1 :]

# 目的：删除列表的后 N 个元素（0 <= N <= 列表长度）
# 方法：获取从位置 1 开始，获取 "总个数 - N" 个元素
让 d = a.选取(1,  a.长度() - N)
让 d = a[1 : a.长度() - N]
```

```py
# expected: delete the first element of the list
# solution: get the remaining elements except for the 1st element
let b = a.rest()
let [_, ...b] = a

# expected: delete the first N elements of the list (0 <= N <= list length - 1)
# solution: get all elements from position N+1
let c = a.slice(N+1)
let c = a[N+1 :]

# expected: delete the last N elements of the list (0 <= N <= list length)
# solution: get the elements start from position 1, count "Total - N".
let d = a.slice(1, a.length() - N)
let d = a[1 : a.length() - N]
```

此外还可以向 `删除`（`remove`） 函数传入一个签名为 `Boolean <- (T)` 的函数，用于实现根据条件删除一个或多个元素，返回剩余的元素。

示例：

```js
让 a = [1,2,3,4,5]
let e1 = a.remove(x => x > 3)  # `[1,2,3]`
let e2 = a.remove(x => x % 2 == 0)  # `[1,3,5]`
```

### 过滤元素

使用 `过滤`（`filter`） 函数可以根据条件过滤掉一个或多个元素，只保留满足条件的元素（跟 `删除` 函数刚好相反）。

`过滤` 函数的原型是：

* `过滤 (逻辑 <- (T), seq)`
* `filter (Boolean <- (T), seq)`

示例：

```js
let a = [1,2,3,4,5]
let e1 = a.filter(x => x > 3)       # `[4, 5]`
let e2 = a.filter(x => x % 2 == 0)  # `[2, 4]`
```

### 拆分列表

使用 `拆分`（`separate`）函数可以在指定位置将一个列表拆分为两个子列表。

`拆分` 函数的原型是：

* `拆分 (位置之前, 列表实例)`
* `separate (positionBefore, listInstance)`

示例：

* `让 (x, y) = a.拆分(3)`
* `let (x, y) = a.separate(3)`

`拆分` 函数返回一个元组，元组有两个成员，分别是拆分而得的前后两个列表。其中参数表示从该位置开始分开，该位置之前的元素形成一个列表，该位置以及该位置之后的元素形成后一个列表。

所以上面的示例将会得到：

```js
(
    [1, 2],
    [3, 4, 5]
)
```

"位置之前" 参数的取值范围是从 `1` 开始到 "列表长度"。

* 如果 "位置之前" 参数值为 1，因为位置 1 前面已经没有其他元素，所以返回一个空列表和一个跟源列表一样的列表，即 (`[]`, `[1,2,3,4,5]`)；
* 如果 "位置之前" 参数值为 "列表长度"，则返回一个除了最后一个元素之外的列表，跟一个只有最后一个元素的列表，即 (`[1,2,3,4]`, `[5]`)。

如果 "位置之前" 值超出允许范围，则会引起运行时异常。

`拆分` 函数也支持传入一个签名为 `Boolean <- (T)` 的函数作为参数，当该函数的返回值为 `真` 时，该元素被划分到第一个列表，否则划分到第二个列表。

示例：

```js
let s = [1,2,3,4,5]
let (a, b) = s.separate(i=> i % 2 == 0)
# a == [2,4]
# b == [1,3,5]
```

### 连接列表

使用 `连接`（`concat`）函数可以将两个列表连接起来，并返回连接后的新列表。

示例：

* `让 a = 连接([1,2,3], [7,8,9])`
* `let a = concat([1,2,3], [7,8,9])`

上例将会得到一个新的列表 `[1,2,3,7,8,9]`。

`连接` 函数有一个纯符号的别名 `++` （即两个加号），使用 `++` 符号重写上例的代码如下：

* `让 a = [1,2,3] ++ [7,8,9]`
* `let a = [1,2,3] ++ [7,8,9]`

需注意：

* 待连接的列表的数据类型必须相同；
* 连接操作是从右到左结合，如 `[1,2] ++ [5,6] ++ [8,9]` 先连接后两个列表得 `[5,6,8,9]` 然后再连接第一个列表；

> 因为字符串实际上是 `列表<字符>`（`List<Char>`） 数据类型，所以字符串的连接也是使用 `++` 函数，比如： `"hello" ++ "world"` 得到 `"helloworld"`。

### 裁剪

`裁剪`（`trim`）
trim/trimStart/trimEnd

  `Seq<T> <- trim (T, Seq<T>)`
  `Seq<T> <- trim (Boolean <- T, Seq<T>)`
  `Seq<T> <- trimStart (T, Seq<T>)`
  `Seq<T> <- trimStart (Boolean <- T, Seq<T>)`
  `Seq<T> <- trimEnd (T, Seq<T>)`
  `Seq<T> <- trimEnd (Boolean <- T, Seq<T>)`

### 补齐
padStart/padEnd

  `Seq<T> <- padStart(T, Int length, Seq<T>)`
  `Seq<T> <- padEnd(T, Int length, Seq<T>)`

### 重复序列

重复序列是指将一个序列复制多遍，然后形成值重复的序列。在被复制的序列使用**表示复制**的符号 `**` 可以重复一个列表。

示例：

```js
let a = [1] ** 4
let b = [0.0] ** 4
let c = ['a'] ** 3
let d = [true] ** 3
let e = ["foo"] ** 3
let f = [0, 1] ** 2
let g = [false, true] ** 2
let h = ['a','b','c'] ** 2
```

结果生成如下等效数列：

* `[1, 1, 1, 1]`
* `[0.0, 0.0, 0.0, 0.0]`
* `['a', 'a', 'a']`
* `[true, true, true]`
* `["foo", "foo", "foo"]`
* `[0, 1, 0, 1]`
* `[false, true, false, true]`
* `['a', 'b', 'c', 'a', 'b', 'c']`

符号 `**` 后面的数字表示复制的次数，为了跟乘法一致，规定复制 1 次表示得出原先的列表。

符号 `**` 对应的函数是 `重复`（`replicate` ::remove`duplicate`）函数：

* `让 a = 重复(4, [1,2,3])`
* `let a = replicate(4, [1,2,3])`

#### 重复字符串

`字符串`（`String`） 类型实际上是 `数组<字符>`（`Array<Char>`）的别称，所以字符串也是可以重复的。

示例：

"abc" 的实际值是 `!['a', 'b', 'c']`，当使用 `**` 复制这个数组时，比如复制 2 次，结果值为 `!['a', 'b', 'c', 'a', 'b', 'c']`，恰好就是 "abcabc"。所以 `**` 运算符号同样可以直接用于重复字符串。

示例：

`let s1 = "=" ** 3`
`let s2 = "abc" ** 2`

变量 `s1` 的值为 "==="， 变量 `s2` 的值为 "abcabc"。

### 平分列表

使用 `平分`（`part`）函数可以将一个列表平分为多个子列表。函数的参数用于指定需要划分为多少个部分。

示例：

```js
let a = [1,2,3,4,5,6]
let b1 = a.part(2)
let b2 = a.part(3)
```

结果变量 `b1` 的值为 `[[1,2,3],[4,5,6]]`，变量 `b2` 的值为 `[[1,2], [3,4], [5,6]]`。

注意：

* 当平分的数量比元素总数量要大时，将会有连续几个空列表出现在结果的末尾，比如 `[1,2].part(4)` 将会得出 `[[1], [2], [], []]`
* 当元素的总数量不是平分数量的整数倍时，结果当中靠后的子列表的数量会比靠前的子列表要少。比如将 14 分成 4 组，先计算 `int(14 / 4)` 得出每组有 3 个元素，最后一组会多出 2 个元素。这时函数会将这多出来的 2 个元素优先给靠前的小组加 1，也就是说前 2 个小组的元素数量会多 1 个。

### 分隔列表

使用 `分隔`（`split`）函数可以将一个列表根据指定的值分隔为若干份，指定的值将会作为 "分隔符"，所以不会出现在结果集里。

示例：

* `让 s = [1,2,0,3,0,4,5,6].分隔(0)`
* `let s = [1,2,0,3,0,4,5,6].split(0)`

则 `s` 的值为：

```js
[
    [1, 2],
    [3],
    [4, 5, 6]
]
```

注意：

* 如果找不到指定的值，则返回仅有一个元素的列表，该元素的值跟原列表一样，即 `[[...]]`；
* 如果指定的值出现在第一个元素，则返回的列表的第一个元素是空列表，即 `[[], ...]`；
* 如果指定的值出现在最后一个元素，则返回的列表的最后一个元素是空列表，即 `[..., []]`。

示例：

```js
让 s1 = [1, 2, 3].分隔(0)
让 s2 = [1, 2, 3].分隔(1)
让 s3 = [1, 2, 3].分隔(2)
让 s4 = [1, 2, 3].分隔(3)
让 s5 = [0].分隔(0)
让 s6 = [0, 0].分隔(0)
```

则它们的值分别为：

* `s1 == [[1,2,3]]`
* `s2 == [[], [2, 3]]`
* `s3 == [[1], [3]]`
* `s4 == [[1, 2], []]`
* `s5 == [[], []]`
* `s6 == [[],[],[]]`

因为字符串实质是字符列表，所以也可以使用 `分隔` 函数对字符串进行分隔，示例：

```js
让 a = "123,456,789"
让 s = a.分隔(',')
```

得出结果为：

```js
["123", "456", "789"]
```

`分隔` 函数也支持传入一个列表，表示根据这个子列表的值分隔源列表，示例：

```js
让 a = "123abc456abc789"
让 s = a.分隔("abc")
```

得出结果为：

```js
["123", "456", "789"]
```

`分隔` 函数还支持传入一个签名为 `Boolean <- (T item)` 的函数，用于根据该函数的返回值（如果返回 true 则从该位置分隔）分隔列表。

示例：

```js
let a = [1, 2, 3, 4, 5, 6, 7]
let b = a.split(x => x % 3 == 0)
```

上例中的 `x % 3 == 0` 表示如果 `x` 能被 3 整数，则返回 `真`。所以结果为：

```js
[[1, 2], [4, 5], [7]]
```

### `拼接` ::TODO

如果列表是空的，则返回空列表。如果列表只有一个元素项目，那么将返回该元素而不使用分隔符。

### 插入元素或列表

插入元素可以由 "拆分列表" 和 "连接列表" 两个操作完成，为了简化操作，可以使用 `插入`（`insert`） 函数来完成。

`插入` 函数的原型是：

* `插入 (位置之前, 新元素, 列表实例)`
* `insert (positionBefore, newElement, listInstance)`

参数 "位置之前" 跟 `拆分` 函数一样，其有效取值范围是从 "1" 到 "列表的长度"，表示插入的位置（即把新元素以 "插队" 的形式放到该位置之前）。

示例，假设有列表 `[1,2,3,4,5]`，现分别有新元素 `99` 和新列表 `[77,88,99]` 准备插入到位置 N，假设 N = 3，代码如下：

```js
函数 宽容拆分(p, list)
    如果 p == list.长度() + 1 那么
        (list, [])
    否则
        拆分(p, list)
    以上
以上

让 N = 3

让 (x, y) = 宽容拆分(N, a)
让 aa = x ++ [99, ...y]
让 ab = x ++ [77,88,99] ++ y

# 使用 `插入` 函数
让 aa = a.插入(N, 99)
让 ab = a.插入(N, [77,88,99])
```

```js
function permissivePart(p, list)
    if p == list.length() + 1 then
        (list, [])
    else
        part(p, list)
    end
end

let N = 3
let (x, y) = a.permissivePart(N)
let aa = x ++ [99, ...y]
let ab = x ++ [77,88,99] ++ y

# by using `insert` function
let aa = a.insert(N, 99)
let ab = a.insert(N, [77,88,99])
```

最后变量 aa 的值为 `[1,2,99,3,4,5]`，ab 的值为 `[1,2,77,88,99,3,4,5]`。

### 替换元素或列表

替换元素可以由两次 "拆分列表" 和两次 "连接列表" 共 4 个操作完成，为了简化操作，可以使用 `替换`（`replace`） 函数。

`替换` 函数的原型是：

* `替换 (开始位置, 元素个数, 新元素, 列表实例)`
* `replace (startPosition, count, newElement, listInstance)`

示例，假设有列表 `[1,2,3,4,5]`，现分别有新元素 `99` 和新列表 `[77,88,99]` 准备替换从位置 M 开始的 N 个元素，假设 M = 2，N = 3，代码如下：

```js
让 M = 2
让 N = 3

让 (x, y) = 宽容拆分(M, a)
让 (_, z) = 宽容拆分(M + N, y)
让 b1 = x ++ [99, ...z]
让 b2 = x ++ [77,88,99] ++ z

# 使用 `替换` 函数
让 b1 = a.替换(M, N, 99)
让 b2 = a.替换(M, N, [77,88,99])
```

```js
let M = 2
let N = 3

let (x, y) = permissivePart(M, a)
let (_, z) = permissivePart(M+N, y)
let b1 = x ++ [99, ...z]
let b2 = x ++ [77,88,99] ++ z

# by using `replace` function
let b1 = a.replace(M, N, 99)
let b2 = a.replace(M, N, [77,88,99])
```

结果变量 `b1` 的值为 `[1,99,5]`，`b2` 的值为 `[1,77,88,99,5]`。

### 排序列表 ::TODO

### 反转列表 ::TODO

### 查找元素或（子）列表的出现位置

`查找位置`（`findPosition`）函数可以在指定的列表中查找指定的元素或者子列表，并返回找到的位置（位置值将会被 `可选` 类型的 `有` 封装）。如果没发现目标，则返回 `无`（`None`）。

示例：

```js
让 i = a.查找位置(4)        # 得 `有(4)`
让 j = a.查找位置(99)       # 得 `无`
让 m = a.查找位置([3,4])    # 得 `有(3)`
让 n = a.查找位置([77,88])  # 得 `无`
```

```js
let i = a.findPosition(4)        # get `Some(4)`
let j = a.findPosition(99)       # get `None`
let m = a.findPosition([3,4])    # get `Some(3)`
let n = a.findPosition([77,88])  # get `None`
```

查找位置也支持传入一个签名为 `Boolean <- (T item)` 的函数，查找过程会从列表逐个元素取出然后传递给这个函数，当函数返回 `真`（`true`）时，查找过程中断，并且返回当时的位置。如果查到最后一个元素这个函数仍未返回 `真`，则查找过程返回 `无`（`None`）。

假设现有一个结构体 `用户`（`User`）及几个实例如下：

```js
struct User
    String name
    String email
end

let u1 = User("foo", "foo@domain.local")
let u2 = User("bar", "bar@domain.local")

let uu = [u1, u2]
```

下面的代码用于查找用户名为 "bar" 的元素的位置值：

```js
let i = uu.findPosition(item => item.name === "bar")  # get `Some(2)`
let j = uu.findPosition(item => item.name === "John") # get `None`
```

### reverseFindPosition

### 查找元素

`查找`（`find`）函数可以根据传入的 `Boolean <- (T item)` 查找符合的元素，找到后返回被 `可选` 类型的 `有` 封装的元素，如果没发现目标，则返回 `无`（`None`）。

示例，继续上例当中的列表 `uu`，下面的代码用于查找用户名为 "bar" 的元素：

```js
let m = uu.find(item => item.name === "bar")    # get `Some(User("foo", ...))`
let n = uu.find(item => item.name === "John")   # get `None`
```

### 检查指定元素是否存在

使用 `存在`（`exist`）函数可以检查是否存在指定的元素，如果存在则返回 `真`（`true`），否则返回 `假`（`false`）。

示例：

```js
let a = [1,2,3,4,5]
let e1 = a.exist(3)
let e2 = a.exist(6)
```

结果变量 `e1` 的值为 `真`，变量 `e2` 的值为 `假`。

`存在` 函数也接受一个签名为 `Boolean <- (T)` 或者 `Boolean <- (Int, T)` 的函数，`存在` 函数会从列表里逐个元素，然后调用参数函数，当参数函数返回值为 `真` 时，函数立即返回 `真`。

```js
let i = uu.exist(item => item.name === "bar")  # true
let j = uu.exist(item => item.name === "John") # false
```

#### 存在开始 ::TODO

existStart

#### 存在结束 ::TODO

existEnd

### `全部匹配` ::TODO

allMatch

### `逐个` 函数

`逐个`（`each`）函数用于遍历一个序列的每一个元素。

`逐个` 函数的原型是：

* `逐个 (void <- (T), seq)`
* `each (void <- (T), seq)`

示例：

* `逐个(i => 书写行 (i),  [1..10])`
* `each(i => writeLine (i), [1..10])`

上面的示例将会输出数列 `[1..10]` 的每一个元素，也就是数字 `1` 到 `10`。

`逐个` 函数跟 `设有 取自` 语句的作用一样，不同的是 `逐个` 是一个函数，而 `设有 取自` 是语句，它们都没有返回值。

### `映射` ::TODO

跟 `设有 取自` 语句一样，`逐个` 函数也是没有返回值，如果向遍历一个列表且有返回值，可以参考 `映射`（`map`） 和 `折叠`（`fold`） 函数。

### 折叠 ::TODO

### 右折叠 ::TODO

### 构建随机数列表

使用列表的函数 `newRandom` 还能创建一个随机数的列表。

示例：

```js
let r = List::newRandom<Int>(25, 1, 100)
```

上例将会产生一个含有 25 个随机整数的数列，其中随机数的范围从整数 `1`（包括、即闭区间） 到整数 `100` （包括、即闭区间）。

下例演示计算 25 个随机数的标准差，已知标准差的公式是：

$$
\text{variance} = \frac{\sum_{i=1}^n(x_i - x_{avg})^2}{n}
$$

$$
\text{standard deviation} = \sqrt{\text{variance}}
$$

对应的代码是：

```js
let v = new List::newRandom<Int>(25, 1, 100)
let variance = sum((v - average(v)) ^ 2) / 25 # Both subtraction and power have broadcast behavior
let sd = sqrt(variance)
```

> 跟随机函数情况类似，如果要产生随机实数，范围值当中的开始值是闭区间，结束值是开放区间，比如 `List::newRandom<Real>(25, 0.0, 1.0)`，结果当中的元素有可能存在值为 `0.0` 的元素，但永远不会有值为 `1.0` 的元素。

`newRandom` 函数还可以指定随机数的分布规律，比如是否要正态分布等，详细见标准库文档。

## 数列

`数列`（`Range`）指在指定范围内的一系列等差数字。在中括号内使用**表示范围**的符号 `..` （即两个点号）可以构建一个等差数列，比如：

`[1..10]`

将会生成一个含有从 "开始值" （整数 1） 到 "结束值" （整数 10） 的列表，即 `[1,2,3,4,5,6,7,8,9,10]`。

开始值和结束值和符号 `..` 之间的空格有无均可。

如果开始值和结束值一样，则会构建一个只有一个元素的数列。比如 `[10..10]`。

### 步进值

* `让 n = 新建 数列(1,10)`
* `let n = new Range(1,10)`

相邻元素间的差值（即步进值）默认是整数 `1`,如果想设置其他步进值，则除了 "开始值" 和 "结束值"，还需要额外提供第 2 个元素，则步进值将会是 "第 2 个元素 - 第 1 个元素（即开始值）"。

比如：

* `[1, 3, ..9]`
* `[10, 20, ..50]`

分别生成列表 `[1,3,5,7,9]` 和 `[10,20,30,40,50]`，步进值分别是 `3-1=2` 和 `20-10=10`。

注意

* 第 2 个元素与第 1 个元素不能相同，否则会抛出运行时异常；
* 当存在第 2 个元素时，第 1 个和 第 2 个元素之间需要加上逗号，第 2 个元素后面的逗号可加可不加；
* 当存在第 2 个元素时，结束值必须符合步进的结果，比如 `[1,3,..10]` 表达式当中的结束值 `10` 不符合步进的结果，运行环境会抛出运行时异常。（::考虑宽容）

也可以使用数列的构造函数来构建等差数列：

* `让 n = 新建 数列(1, 9, 2)`  # `== [1, 3, ..9]`
* `let n = new Range(1, 9, 2)`  # `== [1, 3, ..9]`

注意构造函数的第三个参数是步进值，也就是相当于字面量表达式的第 2 元素与第 1 个元素之差。如果省略步进值，则默认值为 1。

示例：

* `让 n = 新建 数列(1, 5)`  # `== [1,2,3,4,5]`
* `let n = new Range(1, 5)`  # `== [1,2,3,4,5]`

### 线性值

::TODO

```js
let n = Range::lineSpace(-1,1,0.1)
```

### 动态指定开始值、结束值和步进值

开始值、结束值和步进值除了接受字面值，也可以是变量，比如

```js
let start = 10
let end = 14
let step = 2
let a = [start .. end]
let b = [start, step, .. end]
```

则 `a` 的结果是 `[10,11,12,13,14]`，`b` 的结果是 `[10,12,14]`。

### 浮点数数列

如果想生成浮点数数列，则必须提供第 2 个元素以确定步进值，比如：

`[0.1, 0.2 .. 0.5]`

将会生成 `[0.1, 0.2, 0.3, 0.4, 0.5]`

或者使用构造函数构建：

* `让 n = 新建 数列(0.1, 0.5, 0.1)`
* `let n = new Range(0.1, 0.5, 0.1)`

### 字符数列 (::未支持)

字符数据类型存储的是 Unicode 字符，在运行时实际上是 `UInt32`，所以开始值、结束值也可以是 `字符`。

示例：

`['a' .. 'f']`

将会生成字符数列 `['a','b','c','d','e', 'f']`。需要注意的是 Unicode 的码点（code point）并不是连续的，所以在生成字符数列时会自动跳过那些无效的 Unicode 字符。另外，字符列表**不支持**指定步进值。

### 延迟执行

当 XiaoXuan 运行环境执行诸如 `[1 .. 2^63-1]` 语句时，不用担心机器的内存会被消耗光，因为运行环境并不会立即产生这个数列的每个元素，而是在真正需要时才产生并返回相应的数据。技术地说，这个数列跟普通数列有一样的访问接口，但实际上它只是一个函数。

### 省略结束值

当省略结束值时，数列的结束值会被设定为起始值数据类型的最接近最大值的最后一个合法数字。不同类型数据的最大值是不相同的，比如对于默认的 `整数` 类型，其默认值为 2^63-1。

示例：

```js
让 a = [1, ..]
让 b = [1, 3, ..]
```

```js
let a = [1, ..]
let b = [1, 3, ..]
```

分别产生数列 `1, 2, 3, ...` 和 `1, 3, 5, 7, ...` 一直到 `Int64` 最后一个符合等差值的数字。

注意：

* 对于 `浮点数` 和 `字符` 类型，不允许省略结束值。
* 省略结束值并不是构建了一个无限数列，虽然数列的元素数量很大，不过仍然是有限的。

## 数集

`数集`（`NumberList`）即包含一个或多个 `数列` 的集合。

示例：

```js
let n = [1..10, 50, 90..100]
```

显然往 `数列` 添加或追加元素，或者两个 `数列` 连接（`++`）的结果就是一个 `数集`；往 `数集` 添加或追加元素，或者两个 `数集` 连接，或者重复 `数集` 的整体或部分，结果仍然是一个 `数集`。

上例的等同代码如下：

```js
let n = [1..10].append(50) ++  [90..100]
```

注意对数列集合元素的访问得到的是其中的数字，而不是组成它的各个子数列。

示例：

```js
let n = [1..10, 50, 90..100]
let f1 = n.first()  # f1 == 1
let f2 = n.get(1)   # f2 == 1
let f3 = n.get(11)  # f3 == 50
let f4 = n.get(12)  # f4 == 90
let f5 = n.get(13)  # f5 == 91
```

## 数组

`数组`（`Array`）是一种对针具有连续存储整特性的数据而优化的序列。数组的字面量跟列表类似，不同的是需要在第一个中括号之前添加一个感叹号，也就是 `![...]`。

示例：

```js
let a1 = ![1,2,3,4,5]
```

数组具有下列特点：

* 数组使用连续的内存储存数据，所以如果需要批量处理数据，使用数组的运行效率要高一些（数据缓存命中率也较高）；
* 通过元素位置访问数组元素能在常数时间内完成，效率很高；
* 对数组的任何 "更改" 操作都是整体数据复制的，效率很低。所以数组不适合频繁增删改的场合，也就是说，数组适合只读的场合。

使用构造函数也能构建数组，示例：

* 让 a1 = 新建 数组([1,2,3,4,5])
* let a1 = new Array([1,2,3,4,5])

使用 `长度`(`length`) 函数可以获取数组的大小，即数组的元素数量。

示例：

```js
let len1 = a1.length()  # 5
```

> 注意数组的长度是在创建时就确定的，数组创建后，其长度和元素的值均不可改变。

使用构造函数还能创建初始值相同的数组，示例：

```js
let a2 = new Array(4, 1)
let a3 = new Array(4, 0.1)
```

上面例子分别创建了一个长度为 4 初始值为整数 1 的数组，即 `![1, 1, 1, 1]`，另一个是长度为 4 初始值为实数 0.1 的数组，即 `![0.1, 0.1, 0.1, 0.1]`。

`数组` 还提供创建初始值为随机数的函数 `newRandom`。

示例：

```js
let r2 = Array::newRandom(4, 0.0, 1.0)
```

结果会产生一个长度为 4，值在 `0.0`（包括） 到 `1.0`（不包括）之间的随机数数组。另外还可以指定随机数的分布规律，比如是否要正态分布等，详细见标准库文档。

### 字符数组

`字符串`（`String`）实际上是字符数组，即 `数组<字符>`（`Array<Char>`）的别称，所以字符串的连接效率很低，如果需要多次连接/累加字符串，一般是使用列表作为缓冲，在列表完成全部连接/累加操作后再转换为字符串。

因为字符串是字符数组，所以对字符串的索引访问能在常数时间内完成。

XiaoXuan 为字符串添加了一些额外的函数。

#### toUpperCase

#### toLowerCase

#### 裁剪空白 ::TODO
裁剪开始空白
裁剪结束空白

#### 全部替换 ::TODO

replaceAll(Regex, "..", String)

### 多维数组

数组的元素可以是任何数据类型，显然也能再放入一组数组。当一个数组里直接包含一层或多层子数组时，则可称为 "多维数组"（NDArray，Multi-Dimensional Array，N-Dimensional Array）。

示例，下面使用字面量构建二维数组：

```js
let nd1 = ![[1,2,3],
            [4,5,6]]
```

注意多维数组字面量里面的子数组需要使用 `![...]` 符号包围，XiaoXuan 语法约定，一个数组或者多维数组使用 `!` 符号前缀字面量时，内部的 `[...]` 符号都会被解析为数组而不是列表。

这个数组的类型是 `Array<Array<Int>>`，跟列表一样，可以使用 `[n]` 符号访问第 N 个元素的值。示例：

```js
let e1 = nd1[1]
```

将会返回 `![1,2,3]`，如果想访问子数组的元素，可以累加中括号，比如：

`let e = [n][m]`

也可以简写为（语法糖）：

`let e = [n, m]`

使用 `形状`（`shape`） 函数可以获得一个多维数组的各个维度的大小，比如：

```js
let s1 = nd1.shape()  # [2,3]
```

多维数组也可以使用构造函数构建：

```js
let nd2 = Array::new<Array<Int>>([2], 0)          # get an Array<Array<Int>>
let nd3 = Array::new<Array<Array<Int>>>([2,3], 0) # get an Array<Array<Array<Int>>>
```

构造函数的第一个参数表示各维的长度，第二个参数是初始值。

为了简化书写，XiaoXiao 为二维到六维数组创建了类型别名，分别是：`二维数组`（`N2Array`）、`三维数组`（`N3Array`）、一直到 `六维数组`（`N6Array`）。

注意多维数组只是多层嵌套的普通数组，所以使用 `头`（`first`）函数将会获取多维数组第一维（最外一维）第一个子维度，示例：

```js
let n1 = first(nd1)  # n1 == ![1,2,3]
```

显然使用 `长度`（`length`） 函数也只能获取第一维的大小，而不是整个多维数组的元素总数。

下例是一个 3 维数组：

设有一张 RGB 图片，像素是 2 x 2 pixel，像素的顺序是从左到右，从上往下，4 个点的颜色分别是 "橙-青-紫-绿"。

<svg width="40px" height="40px">
  <rect x="0" y="0" width="10" height="10" fill="rgb(240,160,30)" />
  <rect x="10" y="0" width="10" height="10" fill="rgb(30,240,240)" />
  <rect x="0" y="10" width="10" height="10" fill="rgb(240,30,240)" />
  <rect x="10" y="10" width="10" height="10" fill="rgb(160,240,30)" />
</svg>

将颜色作为第 1 维，将 x, y 坐标（即行，列坐标）作为第 2 维和第 3 维，像素点上的颜色分量值（0～255）作为数组元素的值，则该图片的数据大致如下：

```js
let rgb = ![
    [              # 红色（R）
        [240, 30], # 第一行的两个像素点的红色（R）分量
        [240, 160] # 第二行的两个像素点的红色（R）分量
    ],
    [              # 绿色（G）
        [160, 240],
        [30, 240]
    ],
    [              # 蓝色（B）
        [30, 240],
        [240, 30]
    ]
]
```

其 3 维图示大致如下：

```ascii
 +------------------------> X
 |  +------------+ R
 |  |            |
 |  |  +------------+ G
 |  |  |            |
 |  |  |  +------------+ B
 |  |  |  |            |
 |  +--|  |  30  , 240 |
 |     |  |            |
 |     +--|  240 , 30  |
 |        |            |
 |        +------------+
 V Y
```

下面是各个常见函数的调用及返回值：

```js
let v1 = rgb.length()  # `3`
let v2 = rgb.shape()   # `[3, 2, 2]`
let v3 = rgb[1]        # `![![30, 240],![240, 30]]`
let v4 = rgb[1][2]     # `![240, 30]`
let v5 = rgb[1, 2]     # `![240, 30]`
let v6 = rgb[1, 2, 1]  # `240`
```

### 矩阵

`矩阵`（`Matrix`）是由 m 行（row）n 列（column）元素排列成的矩形阵列。矩阵是二维数组的别称，比如 `Matrix<T>` 实际上是 `Array<Array<T>>` 。

矩阵的字面量除了可以使用标准的二维数组表示方法，还能使用简化的格式：使用 `![...]` 符号包围数据，行与行之间的数据使用分号 `;` 分隔。

示例：

```js
let m1 = ![
    1,2,3;
    4,5,6;
    7,8,9]
```

它跟下面的二维数组的字面量是等效的：

```js
let m1 = ![[1,2,3],
           [4,5,6],
           [7,8,9]]
```

显然简化版的表示方法要简单一些，而且在省略变量的数据类型情况下，第一种写法返回的数据类型显示名称时显示的是 `Matrix<Int>`，而第二种写法是 `Array<Array<Int>>`（注意只是显示名称不一样，实际运算时都是使用别名的真实类型，即 `Array<Array<Int>>`）。它们构建的矩阵如下：

$$
    \begin{bmatrix}
    a_{11} & a_{12} & \cdots & a_{1n} \\
    a_{21} & a_{22} & \cdots & a_{2n} \\
    \vdots & \vdots & \ddots & \vdots \\
    a_{m1} & a_{m2} & \cdots& a_{mn} \\
    \end{bmatrix}
$$

跟访问二维数组的方法一样，也可以使用中括号访问矩阵的元素，比如第 1 行第 2 列（即 m=1, n=2）的元素，语句如下：

```js
让 c1 = m1[1][2]  # c == 2
让 c2 = m1[1, 2]   # c == 2
```

```js
let c1 = m1[1][2]  # c == 2
let c2 = m1[1, 2]   # c == 2
```

矩阵也可以通过构造函数构建。

示例：

```js
let m = new Matrix(2, 3, 0)
```

构造函数的参数分别表示行、列、初始值。

同样也可以创建随机数的矩阵：

```js
let m = Matrix::newRandom(2, 3, 0.0, 1.0)
```

XiaoXuan 为 `Matrix<Int>` 重载了矩阵的乘法运算，`矩阵 a * 矩阵 b` 的结果是：

$$
c(i,j) = \sum_{k=1}^{n}{a(i,k)b(k,j)}
$$

即线性代数的矩阵乘法（前提是矩阵 a 的行数必须等于 b 的列数）；结构相同的矩阵有加法和减法运算；标量和矩阵有乘法运算，表示逐个元素跟该标量相乘。详细见 https://en.wikipedia.org/wiki/Matrix_(mathematics)#Basic_operations

对于一维数组，有点积（用点乘 `.*` 符号表示）运算，可用于大小相同的数组，表示逐个位置对应的元素相乘，然后求和。XiaoXuan 没有提供一维数组的叉积运算。

XiaoXuan 还提供诸如 `获取列`（`getColumn`） 函数，用来获取指定的一列数据。

## 列表、数组、列表的比较

除了列表，还有其他几种序列类型的数据集合，即都实现了 `序列`（`Sequence`）特性。它们一般具有跟列表一致的访问接口，比如可以使用 `let [a, ...b] = n` 获取第一个元素和其余元素，有些序列支持添加元素操作，也就可以使用 `let n = [a,...b]` 添加元素。

<!--
所有序列都可以使用 `数据类型[]`（`DataType[]`） 这样的格式作表示其数据类型，比如：

`Int[] a = [1,2,3,4,5]`

下面将会讲述的数列、数组也能用同样的方法赋值到一个变量，比如：

`Int[] b = [1..5]`
`Int[] c = ![1,2,3]`

实际上 `数据类型[]` 就是 `序列<数据类型>`（`Sequence<DataType>`） 的别名。所以上面的代码等同于：

`Sequence<Int> b = [1..5]`


需注意的是一旦将具体的一个序列赋值给这种数据类型的变量或者参数之后，就丢失了具体类型的其他特性。`序列` 特性只有 `第一个`、`其余` 两个方法。
-->

### 使用场景

下面比较列表、列表、数集、数组这几种序列：

* 列表

  列表可作为一般用途的数据集合。一般用于需要增加、连接、删除、拆解元素等场合。不适合（在尾部）累加元素，也不适合按索引访问元素。

* 数组

  数组适合需要经常批量访问数据（即一次访问多个数据）的场合，适合按索引访问元素，适合 "一次构建、多次读取"。数组不适合需要增加、连接、删除、拆解元素等场合。

* 列表

  列表适合（在尾部）累加元素，比如构建字符串、表格等，适合 "多次写入，多次读取"。

## 序列的常用函数

上面讲述的列表、数列、数集、列表、数组都属于序列，即它们都实现了 `序列`（`Sequence`）特性，`序列` 特性包含了两个方法 `第一个`（以及 `尝试第一个`） 和 `其余`。

然而大部分派生于 `序列` 的数据类型都不仅仅具有 `序列` 特性，同时还具有其他伴随的特性，这里不一一展开，下面笼统地使用 `序列`（`Seq`）代替这类派生于 `序列` 的数据类型。

下面列出这些数据类型通常会具有的方法及其方法原型。

* 长度 length
  `整数 <- 长度 (序列<T> 目标)`
  `Int <- length (Seq<T> target)`

* 第一个 first
  `T <- 第一个 (序列<T> 目标)`
  `T <- first (Seq<T> target)`

* 尝试第一个 tryFirst
  `可选<T> <- 尝试第一个 (序列<T> 目标)`
  `Option<T> <- tryFirst (Seq<T> target)`

* 其余 rest
  `序列<T> <- 其余 (序列<T> 目标)`
  `Seq<T> <- rest (Seq<T> target)`

* 最后一个 last
  `T <- 最后一个 (序列<T> 目标)`
  `T <- last (Seq<T> target)`

* 尝试最后一个 tryLast
  `可选<T> <- 尝试最后一个 (序列<T> 目标)`
  `Option<T> <- tryLast (Seq<T> target)`

* 最后一个除外 exceptLast
  `序列<T> <- 最后一个除外 (序列<T> 目标)`
  `Seq<T> <- exceptLast (Seq<T> target)`

* 获取 get
  `T <- 获取 (整数 位置, 序列<T> 目标)`
  `T <- get (Int position, Seq<T> target)`

  语法糖：
  `目标序列[位置]`
  `target_seq[position]`

* 尝试获取 tryGet
  `可选<T> <- 尝试获取 (整数 位置, 序列<T> 目标)`
  `Option<T> <- tryGet (Int position, Seq<T> target)`

* 选取 slice
  `序列<T> <- 选取 (整数 开始位置, 整数 数量, 序列<T> 目标)`
  `Seq<T> <- slice (Int startPos, Int count, Seq<T> target)`

  语法糖：
  `目标序列[开始位置:数量]`
  `target_seq[startPos:count]`

* 开始部分 take
  `序列<T> <- 开始部分 (整数 数量, 序列<T> 目标)`
  `Seq<T> <- take (Int count, Seq<T> target)`

* 添加 add
  `序列<T> <- 添加 (T 新增项, 序列<T> 目标)`
  `Seq<T> <- add (T additional, Seq<T> target)`

  语法糖：
  `[新增项, ...目标序列]`
  `[additional, ...target_seq]`

* 追加 append
  `序列<T> <- 追加 (T 新增项, 序列<T> 目标)`
  `序列<T> <- 追加 (序列<T> 新增项, 序列<T> 目标)`

  `Seq<T> <- append (T additional, Seq<T> target)`
  `Seq<T> <- append (Seq<T> additional, Seq<T> target)`

* 删除 remove
  `序列<T> <- 删除 (整数 位置, 序列<T> 目标)`
  `序列<T> <- 删除 (整数 开始位置, 整数 数量, 序列<T> 目标)`
  `序列<T> <- 删除 (逻辑 <- (T), 序列<T> 目标)`

  `Seq<T> <- remove (Int position, Seq<T> target)`
  `Seq<T> <- remove (Int startPos, Int count, Seq<T> target)`
  `Seq<T> <- remove (Boolean <- (T), Seq<T> target)`

* 过滤 filter
  `序列<T> <- 过滤 (逻辑 <- (T), 序列<T> 目标)`
  `Seq<T> <- filter (Boolean <- (T), Seq<T> target)`

* 拆分 separate
  `(序列<T>, 序列<T>) <- 拆分 (整数 位置之前, 序列<T> 目标)`
  `(序列<T>, 序列<T>) <- 拆分 (逻辑 <- (T), 序列<T> 目标)`

  `(Seq<T>, Seq<T>) <- separate (Int posBefore, Seq<T> target)`
  `(Seq<T>, Seq<T>) <- separate (Boolean <- (T), Seq<T> target)`

* 连接 concat
  `序列<T> <- 连接 (序列<T> 新增项, 序列<T> 目标)`
  `Seq<T> <- concat (Seq<T> additional, Seq<T> target)`

  语法糖：
  `新增项 ++ 目标序列`
  `additional ++ target_seq`

* 裁剪 trim
  `序列<T> <- 裁剪 (T 项目, 序列<T> 目标)`
  `序列<T> <- 裁剪 (逻辑 <- T, 序列<T> 目标)`
  `序列<T> <- 裁剪头 (T 项目, 序列<T> 目标)`
  `序列<T> <- 裁剪头 (逻辑 <- T, 序列<T> 目标)`
  `序列<T> <- 裁剪尾 (T 项目, 序列<T> 目标)`
  `序列<T> <- 裁剪尾 (逻辑 <- T, 序列<T> 目标)`

  `Seq<T> <- trim (T item, Seq<T> target)`
  `Seq<T> <- trim (Boolean <- T, Seq<T> target)`
  `Seq<T> <- trimStart (T item, Seq<T> target)`
  `Seq<T> <- trimStart (Boolean <- T, Seq<T> target)`
  `Seq<T> <- trimEnd (T item, Seq<T> target)`
  `Seq<T> <- trimEnd (Boolean <- T, Seq<T> target)`

* 补齐
  `序列<T> <- 补齐头(T 项目, 整数 长度, 序列<T> 目标)`
  `序列<T> <- 补齐尾(T 项目, 整数 长度, 序列<T> 目标)`

  `Seq<T> <- padStart(T item, Int length, Seq<T> target)`
  `Seq<T> <- padEnd(T item, Int length, Seq<T> target)`

* 重复 replicate
  `序列<T> <- 重复 (整数 数量, 序列<T> 目标)`
  `Seq<T> <- replicate (Int count, Seq<T> target)`

* 平分 part
  `序列<序列<T>> <- 平分 (整数 数量, 序列<T> 目标)`
  `Seq<Seq<T>> <- part (Int count, Seq<T> target)`

* 分隔 split
  `序列<序列<T>> <- 分隔 (T 分隔符, 序列<T> 目标)`
  `序列<序列<T>> <- 分隔 (逻辑 <- (T), 序列<T> 目标)`

  `Seq<Seq<T>> <- split (T separater, Seq<T> target)`
  `Seq<Seq<T>> <- split (Boolean <- (T), Seq<T> target)`

* 拼接 join
  `序列<T> <- 拼接 (T 连接符, 序列<T> 目标)`
  `序列<T> <- 拼接 (序列<T> 连接符, 序列<T> 目标)`

  `Seq<T> <- join (T joint, Seq<T> target)`
  `Seq<T> <- join (Seq<T> joint, Seq<T> target)`

* 插入 insert
  `序列<T> <- insert (整数 位置之前, T 新增项, 序列<T> 目标)`
  `序列<T> <- insert (整数 位置之前, 序列<T> 新增项, 序列<T> 目标)`

  `Seq<T> <- insert (Int posBefore, T additional, Seq<T> target)`
  `Seq<T> <- insert (Int posBefore, Seq<T> additional, Seq<T> target)`

* 替换 replace
  `序列<T> <- replace (整数 开始位置, 整数 数量, T 替换项, 序列<T> 目标)`
  `序列<T> <- replace (整数 开始位置, 整数 数量, 序列<T> 替换项, 序列<T> 目标)`

  `Seq<T> <- replace (Int startPos, Int count, T, Seq<T> target)`
  `Seq<T> <- replace (Int startPos, Int count, Seq<T>, Seq<T> target)`

* 排序 sort
  `序列<T> <- sort (序列<T> 目标)`
  `Seq<T> <- sort (Seq<T> target)`

* 反转 reverse
  `序列<T> <- reverse (序列<T> 目标)`
  `Seq<T> <- reverse (Seq<T> target)`

* 查找位置 findPosition
  `可选<整数> <- 查找位置 (T 查找项, 序列<T> 目标)`
  `可选<整数> <- 查找位置 (逻辑 <- (T), 序列<T> 目标)`

  `Option<Int> <- findPosition (T searching, Seq<T> target)`
  `Option<Int> <- findPosition (Boolean <- (T), Seq<T> target)`

* 反向查找位置 reverseFindPosition
  `可选<整数> <- 反向查找位置 (T 查找项, 序列<T> 目标)`
  `可选<整数> <- 反向查找位置 (逻辑 <- (T), 序列<T> 目标)`

  `Option<Int> <- reverseFindPosition (T searching, Seq<T> target)`
  `Option<Int> <- reverseFindPosition (Boolean <- (T), Seq<T> target)`

* 查找 find
  `可选<T> <- 查找 (逻辑 <- (T), 序列<T> 目标)`
  `Option<T> <- 查找 (Boolean <- (T), Seq<T> target)`

* 存在 exist
  `逻辑 <- 存在 (T 查找项, 序列<T> 目标)`
  `逻辑 <- 存在 (逻辑 <- (T), 序列<T> 目标)`

  `Boolean <- exist (T searching, Seq<T> target)`
  `Boolean <- exist (Boolean <- (T), Seq<T> target)`

* 存在开始 existStart
  `逻辑 <- 存在开始 (T 查找项, 序列<T> 目标)`
  `逻辑 <- 存在开始 (序列<T> 查找项, 序列<T> 目标)`
  `逻辑 <- 存在开始 (逻辑 <- (T), 序列<T> 目标)`

  `Boolean <- existStart (T searching, Seq<T> target)`
  `Boolean <- existStart (Seq<T> searching, Seq<T> target)`
  `Boolean <- existStart (Boolean <- (T), Seq<T> target)`

* 存在结束 existEnd
  `逻辑 <- 存在结束 (T 查找项, 序列<T> 目标)`
  `逻辑 <- 存在结束 (序列<T> 查找项, 序列<T> 目标)`
  `逻辑 <- 存在结束 (Boolean <- (T), 序列<T> 目标)`

  `Boolean <- existEnd (T searching, Seq<T> target)`
  `Boolean <- existEnd (Seq<T> searching, Seq<T> target)`
  `Boolean <- existEnd (Boolean <- (T), Seq<T> target)`

* 全部匹配 allMatch
  `逻辑 <- 全部匹配 (Boolean <- (T), 序列<T> 目标)`
  `Boolean <- allMatch (Boolean <- (T), Seq<T> target)`

* 逐个 each
  `void <- 逐个(void <- (T), 序列<T> 目标)`
  `void <- each(void <- (T), Seq<T> target)`

* 映射 map
  `序列<E> <- 映射 (E <- (T), 序列<T> 目标)`
  `Seq<E> <- map (E <- (T), Seq<T> target)`

* 折叠 fold
  `E <- 折叠(E <- (E 累计值, T 当前值), E 初始值,  序列<T> 目标)`
  `E <- fold(E <- (E accumulator, T currentValue), E initialValue,  Seq<T> target)`

* 右折叠 foldRight
  `E <- 右折叠(E <- (E 累计值, T 当前值), E 初始值,  序列<T> 目标)`
  `E <- foldRight(E <- (E accumulator, T currentValue), E initialValue,  Seq<T> target)`

* 配对 zip
  `序列<(E, T)> <- 配对 (序列<E> 增加项, 序列<T> 目标)`

  `Seq<(E, T)> <- zip (Seq<E> additional, Seq<T> target)`

### 数字列表

对于整数、自然数、实数型列表，还有 max, min, average, sum, median 等函数。

### 字符列表

对于字符列表，有 toUpperCase, toLowerCase, trim, trimBegin, trimEnd, replaceAll 等函数。

## 表格

`表格`（`Table`）是一个由标头、行、列组成的数据。同一列的数据类型必须相同，标头就是列的名称。一行数据由各列数据在同一行的数据组成。表格在概念上跟电子表格（spreadsheet）是一样的。注意表格不是序列。

构造一个表格之前先需要定义一个结构体，一行数据就是一个结构体的实例，标头就是结构体各成员的名称。

示例，下面构建一个 `用户`（`User`） 结构体：

```js
结构体 用户
    整数 编号
    字符串 姓名
    逻辑 检查
以上
```

```js
struct User
    Int id
    String name
    Boolean checked
end
```

然后使用 `表格` 构造函数构建表格：

```js
let t1 = new Table<User>([
    User(1, "foo", true),
    User(2, "bar", false)
])
```

XiaoXuan 提供了一个字面量语法糖构建结构体，上例的表格可以使用下面的字面量来构建：

```js
let t1 = ![
    User(Int id, String name, Boolean checked);
    1, "foo", true;
    2, "bar", false
]
```

如果提供的数据是基本的数据类型，也可以省略第一行结构体当中的成员数据类型，示例：

```js
let t1 = ![
    User(id, name, checked);
    1, "foo", true;
    2, "bar", false
]
```

上例所构建的表格如下：

| id | name | checked |
|----|------|---------|
| 1  | foo  | true    |
| 2  | bar  | false   |

使用 `标头`（`header`）函数可以获取表格的结构体类型，使用 `标头标题`（`headerTitles`）可以获取由标头组成的字符串列表，比如 `["id", "name", "checked"]`。

表格也是一种序列，可以视为元素为一个结构体的列表，即上例 `Table<User>` 大致相当于列表 `List<User>`。所以同一般序列一样，使用 `获取`（`get`）函数可以获取指定行的数据，返回的是一个结构体。

示例：

```js
let i = t1.get(2)
```

则 `i` 的值是 `User(id=2, name="bar", checked=false)`。

跟元素类型为一个结构体的列表（如 `List<User>`）不同，`表格` 数据类型提供了很多跟表格处理相关的函数，比如排序、筛选等。

## 映射表

`映射表`（`Map`）是一系列 "键-值对" 数据。映射表不属于序列（即映射表没有实现 `序列` 特性），但也是常用的数据集合的一种。

映射表的字面量是：使用一对花括号包围所有数据，多个 "键-值对"（key-value pair） 之间使用逗号分隔，使用 "键名:值" 构建 "键-值对"。示例：

```js
{
    "东": 123,
    "西": 456
}
```

```js
{
    "foo": 123,
    "bar": 456
}
```

键支持大部分类型的数据，只要实现了 "可散列" 特性即可，值可以是任何类型的数据。当键为字符串类型时，键名的双引号可以省略，比如上面第一个映射表，可以简化为：

```js
{
    东: 123,
    西: 456
}
```

> 使用整数作为键有最好的性能，一般映射表的内部也是使用整数作为键。当用户使用其他数据类型作为键时，程序会调用数据的 `获取散列值`（`getHash`）函数获取对象的散列值，然后再作为内部键使用。XiaoXuan 内置了一种叫 `散列字符串`（`HashString`）的数据类型，具有 `可散列` 特性，在创造实例的时候计算散列值，适合作为映射表的键。

需注意一个映射表里的所有 "键-值对" 的数据类型必须一样，"键-值对" 实际上是一个含有两个成员的结构体，结构体定义如下：

```js
结构体 映射表元素<T,E>
    T 键
    E 值
以上
```

```js
struct MapElement<T,E>
    T key
    E value
end
```

结构体的第一个成员是 "键"，第二个成员是 "值"。上面示例的第一个映射表数据类型是 "映射表<字符串, 整数>", 第二个是 "映射表<字符串, 字符串>"。

XiaoXuan 运行环境默认使用二叉树（或者平衡树）来实现映射表。

### 访问映射表的元素

使用 `获取`（`get`）函数用于获取指定键的元素。

假设现有映射表 `a` 内容如下：

```js
让 a = {
    "东": 1,
    "西": 2,
    "南": 3,
    "北": 4
}
```

如果项获取键 "西" 的值，语句如下：

* `让 i = 获取 ("西", a)`
* `让 i = a.获取 ("西")`

* `let i = get ("西", a)`
* `let i = a.get ("西")`

如果指定的键不存在，则会抛出运行时异常。如果想试探性获取一个键值，可以使用 `尝试获取`（`tryGet`）函数，函数返回 `可选<T>`（`Option<T>`），如果存在指定键，则返回 `可选::有(值)`，否则返回 `可选::无`。

示例：

```js
let i = tryGet("西", a)
let j = tryGet("中", a)
```

变量 `i` 的值为 `可选::有(2)`，变量 `j` 的值为 `可选::无`。

#### 使用中括号获取指定键的值

可以在映射表实例后面使用一对中括号 `[...]` 简化调用 `获取` 函数。

示例：

* `让 i = a["西"]`
* `let i = a["西"]`

变量 i 的值跟使用 `获取("西", a)` 函数的返回值一样。

#### 使用模式解构获取指定键的值

示例：

```js
# 同时获取键 "东" 和 "南" 的值，并赋值给变量 i 和 j。
让 {"东": i, "南": j} = a

# 同上，然后将剩余的 "键-值对" 存入变量 k，变量 k 将是一个映射表，
# 其内容为 `{"西": 2, "北": 4}`
让 {"东": i, "南": j, ...k} = a

# 当键的数据类型是字符串时，也可以省略双引号
让 {东: i, 南: j} = a

# 如果连变量 i, j 都省略，那么将会得到跟键名一样的变量
让 {东, 南} = a
```

### 添加新的 "键-值对"

使用 `添加`（`add`）函数向映射表添加新的 "键-值对"（"key-value pair"），函数返回值是 `结果<映射表>`。如果操作成功，则返回 `好(新映射表)`（`Ok(new_map)`），如果键名已经存在，则返回 `错误()`（`Err()`）。

示例：

```js
match a.add("中", 5)
    case Ok(m): writeLineFormat("new map: {:?}", m)
    case Err(): writeLine("error")
end
```

正如上面所说，"键-值对" 实际上是一个含有两个成员的结构体，所以也可以直接添加 "键-值对" 结构体：

```js
let e = new 映射表元素("中", 5)
a.add(e)
```

### 更新已存在的键值

使用 `更新`（`update`）函数向映射表更新已存在的键值，如果操作成功，则返回 `好(新映射表)`（`Ok(new_map)`），如果指定的键不存在，则返回 `错误()`（`Err()`）。

示例：

```js
match a.update("中", 2)
    case Ok(m): ...
    case Err(): ...
end
```

### 添加或更新 "键-值对"

可以使用 `添加或更新`（`addOrUpdate`）函数添加或更新 "键-值对"，也就是说，如果指定的键不存在，则相当于 `添加` 函数，如果指定的键已存在，则相当于 `更新` 函数。函数总是返回一个新的映射表。

示例：

```js
let b = a.addOrUpdate("中", 6)
```

#### 使用三个点来添加或更新 "键-值对"

使用三个点符号 "..." 可以代替 `添加或更新` 函数，示例：

```js
let m = {"a": 123, "b": 456}
let b1 = {"c": 789, ...m}
let b2 = {"a": 555, ...m}
```

结果变量 `b1` 的值为 `{"a": 123, "b": 456, "c": 789}`，变量 `b2` 的值为 `{"a": 555, "b": 456}`

### 检查指定键是否存在

使用 `存在`（`exist`）函数可以检查是否存在指定的键，如果存在则返回 `真`（`true`），否则返回 `假`（`false`）。

示例：

```js
let m = {"a": 123, "b": 456}
let e1 = m.exist("a")
let e2 = m.exist("c")
```

结果变量 `e1` 的值为 `真`，变量 `e2` 的值为 `假`。

`存在` 函数也接受一个签名为 `Boolean <- (MapEntry<K, V>)` 或者 `Boolean <- (K, V)` 的函数，`存在` 函数会从映射表里逐个取出 "键-值 对"，然后调用参数函数，当参数函数返回值为 `真` 时，函数立即返回 `真`。

```js
let m = {"a": 123, "b": 456}
let e1 = m.exist((k, v) => k == "a")  # true
let e2 = m.exist((k, v) => v > 300)   # true
let e2 = m.exist((_, v) => v > 500)   # false
```

### 删除 "键-值对"

使用 `删除`（`remove`） 函数可以根据指定的键删除 "键-值 对"，需注意如果指定的键不存在，会引起运行时异常。

可以使用 `尝试删除`（`tryRemove`） 函数常识性地 "删除" 映射表指定的 "键-值对"，函数返回值的类型是 `结果<映射表>`，成功则返回新映射表，如果指定键不存在则返回 `错误()`。

### 删除多个 "键-值对"

使用 `删除全部`（`removeAll`） 函数可以根据条件删除一个或多个 "键-值 对"。

```js
let m = {"a": 123, "b": 456}
let e1 = m.removeAll((k, v) => v > 300)  # {"a": 123}
```

### 过滤 "键-值对"

使用 `过滤`（`filter`） 函数可以根据条件过滤掉一个或多个 "键-值 对"，只保留满足过滤条件的 "键-值 对"。

```js
let m = {"a": 123, "b": 456}
let e1 = m.filter((k, v) => v > 300)  # {"b": 456}
```

### 遍历映射表元素

使用 `转为列表`（`toList`） 函数可以获取映射表的所有项目，返回值是一个列表，列表的元素是 "键-值对"，即 `映射表元素<T,E>`。

示例：

```js
let items = a.toList()
for item in items
    writeLine (item.key, item.value)
end
```

上面示例会遍历映射表 `a` 的所有元素。

另外还有 `获取键组`（`getKeys`） 和 `获取值组`（`getValues`）函数可以获取映射表的键组和值组。

## 集

`集`（`Set`）跟列表类似，但它不允许有重复的数据。集合可以理解为只有 "键" 而没有 "值" 的映射表，实际上 `Set` 就是 `Map<T, Unit>` 数据类型的别名（`Unit` 即 `空元型`，它只有一个值 `空间型::空元`，`Unit::Empty`）。集合一般用来排除重复数据。

集合没有字面量表示方法，需要使用构造函数构建：

```js
让 s1 = 新建 集([1,2,2,3])
让 s2 = 新建 集(["abc", "xyz", "abc", "abc"])
```

```js
let s1 = new Set([1,2,2,3])
let s2 = new Set(["abc", "xyz", "abc", "abc"])
```

上例中重复的数据将会被剔除，最后 `s1` 的值为 `1, 2, 3`，`s2` 的值为 `"abc", "xyz"`。

### 转换为普通列表

通常运行环境使用二叉树（或者平衡树）实现数据表，从集合读取元素的效率很低，因此需要使用集合的 `转为列表`（`toList`） 函数即将集合转换为普通列表。
