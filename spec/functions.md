# 函数

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [函数](#函数)
  - [函数的调用](#函数的调用)
    - [语法](#语法)
      - [函数的返回值](#函数的返回值)
      - [按参数名称传参](#按参数名称传参)
      - [调用冲突](#调用冲突)
      - [调用没有参数的函数](#调用没有参数的函数)
      - [嵌套调用](#嵌套调用)
      - [参数列表换行](#参数列表换行)
      - [尾部调用优化](#尾部调用优化)
    - [实例方法和特性函数 （::考虑移动）](#实例方法和特性函数-考虑移动)
    - [函数的点号调用方式 （::考虑移动）](#函数的点号调用方式-考虑移动)
      - [一般函数（::不支持）](#一般函数不支持)
      - [连续的函数点号调用（::不支持）](#连续的函数点号调用不支持)
    - [拆封 （::考虑移动）](#拆封-考虑移动)
      - [指定拆封的后备值 <!--替换值--> （::考虑移动）](#指定拆封的后备值-替换值-考虑移动)
      - [指定拆封的替换值为表达式 （::考虑移动）](#指定拆封的替换值为表达式-考虑移动)
      - [指定拆封的替换为语句块 （::考虑移动）](#指定拆封的替换为语句块-考虑移动)
      - [指定拆封的后备匿名函数](#指定拆封的后备匿名函数)
      - [会自动退出函数的拆封 （::考虑移动）](#会自动退出函数的拆封-考虑移动)
    - [链式调用 （::考虑移动）](#链式调用-考虑移动)
    - [函数的组合](#函数的组合)
    - [使用 `调用` 函数调用函数（::不支持）](#使用-调用-函数调用函数不支持)
    - [函数的中置调用方式](#函数的中置调用方式)
    - [优先级和结合性](#优先级和结合性)
    - [内置的中置函数的优先级](#内置的中置函数的优先级)
    - [中置调用的原理](#中置调用的原理)
    - [表达式的执行顺序](#表达式的执行顺序)
  - [函数的定义](#函数的定义)
    - [语法](#语法-1)
      - [省略返回值数据类型(::考虑)](#省略返回值数据类型考虑)
      - [简写形式](#简写形式)
    - [函数别名](#函数别名)
    - [匿名函数](#匿名函数)
    - [匿名函数捕获变量值（闭包）](#匿名函数捕获变量值闭包)
    - [简化形式的匿名函数](#简化形式的匿名函数)
    - [`返回` 关键字](#返回-关键字)
      - [省略 `返回` 关键字](#省略-返回-关键字)
      - [匿名函数当中的 `返回` 关键字](#匿名函数当中的-返回-关键字)
      - [流程控制语句当中的 `返回` 关键字](#流程控制语句当中的-返回-关键字)
      - [尾部调用](#尾部调用)
    - [函数的重载](#函数的重载)
      - [跨模块重载（::不支持）](#跨模块重载不支持)
      - [参数的默认值和可选参数](#参数的默认值和可选参数)
    - [重载冲突](#重载冲突)
    - [分支函数](#分支函数)
      - [函数的分支与数学的函数定义](#函数的分支与数学的函数定义)
  - [纯函数](#纯函数)

<!-- /code_chunk_output -->

## 函数的调用

### 语法

调用函数时，写上函数的名称，然后使用一对括号把所有实参包围起来：

* `函数名称 (参数值1, 参数值2, ... , 参数值N)`
* `functionName (value1, value2, ... , valueN)`

示例：

```js
加 (1, 2)
行输出 ("你好")
```

```js
add (1, 2)
writeLine ("Hello")
```

#### 函数的返回值

可以定义一个变量接收函数的返回值：

* `让 变量名 = 函数名称 (参数值1, 参数值2, ..., 参数值N)`
* `let variableName = functionName (value1, value2, ..., valueN)`

示例：

```js
让 a = 平方根 (4)
让 b = 加 (1, 2)
```

```js
let a = sqrt (4)
let b = add (1, 2)
```

如果对函数的返回值不感兴趣，也可以直接调用函数，不一定需要定义一个变量来接收它的返回值。

#### 按参数名称传参

调用函数时，一般是把各个参数值（即实参）按顺序（或者说 "位置"）传入函数，当一个函数的参数较多，可以考虑按参数名称传入参数值，这样在阅读时会更明确各个实参的意义。

按参数名称传参的格式：

* `函数名称 (参数名称1=参数值1, 参数名称2=参数值2, ..., 参数名称N=参数值N)`
* `functionName (param1=value1, param2=value2, ..., paramN=valueN)`

也可以混合按位置和按名称两种传参方式，不过必须先写完所有按位置传参的参数值，然后才可以开始写按名称传参的 "名称-数值" 对，格式：

* `函数名称 (参数值1, ..., 参数值N, 参数名称a=参数值a, ..., 参数名称z=参数值z)`
* `functionName (value1, ..., valueN, paramA=valueA, ..., paramZ=参数值Z)`

示例：

```js
# 按名称传参
绘图.直线 (x1=0, y1=0, x2=100, y2=100, 颜色=颜色常数.红色, 线条宽度=3)

# 混合按位置和按名称传参
绘图.直线 (0, 0, 100, 100, 颜色=颜色常数.红色, 线条宽度=3)
```

```js
# passing parameters by name
draw.line (x1=0, y1=0, x2=100, y2=100, color=ColorConstant.Red, lineWidth=3)

# mixing per-position and per-name passing
draw.line (0, 0, 100, 100, color=ColorConstant.Red, lineWidth=3)
```

> 无论函数当中的参数是否为可选参数，均可按照名称方式传参。

#### 调用冲突

> XiaoXuan 的每个函数调用，在编译时就已经确定其应该调用的是哪一个函数定义，而不是在运行的过程中确定。

因为运行环境会在源码解和析验证阶段已经排除有参数位置冲突的情况（具体排除方法见下面函数定义章节），所以当按照参数位置调用函数时，总能找到正确的对应的函数。不过当按照参数名称或者按照参数位置加名称的方式调用函数时，则有可能存在冲突的可能。

示例：

```js
function Int test (Int a [, String b = "foo"]) = ...
function Int test (String b [, Int a = 99]) = ...
```

注：参数列表中的中括号是为了突出表示当中的是可选参数，实际上不存在中括号。

在源码解析验证的阶段，因为上面两个函数的位置参数的数据类型不同，因此不存在冲突。但如果按照参数名称调用，运行环境会逐个重载进行匹配。具体的步骤如下：

1. 先按照调用语句当中的位置参数筛选重载，此时无视函数定义当中参数的名称以及是否可选参数，即仅按照参数的数据类型和顺序来匹配；
2. 然后按照调用语句当中的名称参数，在上一步得出的候选重载中的剩余参数里，根据名称进行匹配，最后筛选出符合的重载。
3. 如果最后匹配的函数重载超过一个，则会引起运行时异常。

示例：

```js
let i = test(a = 55, b = "bar")
```

上面的调用语句与 `test` 函数的两个重载均可匹配，所以会引起运行时异常，这时需要更改调用语句，比如：

`let i = test(55, b = "bar")`

或者

`let j = test("bar", a = 55)`

#### 调用没有参数的函数

调用一个没有参数的函数（一般称之为过程）时，需要在函数名称后面加上一对空括号：

* `函数名称 ()`
* `functionName ()`

#### 嵌套调用

函数也可以嵌套调用，即：将一个函数的返回值作为另一个函数的参数的值。严格来说任何有返回值的表达式或者语句块，都可以作为参数值传给另一个函数。

嵌套调用的格式：

* `函数1 (参数值1, 函数2 (参数值a, 参数值z), 任意有返回值的表达式, ...)`
* `function1 (value1, function2 (valueA, valueZ), any_expression, ...)`

示例：

```js
让 弦 = 平方根 (平方 (3), 平方 (4))
让 弦 = 平方根 (3 ^ 2 + 4 ^ 2)
```

```js
let dist = sqrt (square (3), square (4))
let dist = sqrt (3 ^ 2 + 4 ^ 2)
```

* 尽量避免多层函数嵌套调用，可以先把表达式的值求出来并赋值给变量，然后再把变量作为参数值传入函数。
* 在语法上，允许省略函数名称和参数列表之间的空格，允许省略参数值之间的空格，不过为了规范起见尽量保留这些空格。

#### 参数列表换行

当参数列表过长时，可以换行书写，但参数列表的第一个括号（即开始括号）必须保留在函数名称后面，示例：

```js
01  让 标准差 =
02      平方根 (
03          加 (
04              (x1-μ)^2,
05              (x2-μ)^2
06          )
07      )
```

```js
01  let std_deviation =
02      sqrt (
03          add (
04              (x1-μ)^2,
05              (x2-μ)^2
06          )
07      )
```

注意上面示例的第 02 和 03 行的末尾的左括号 "(" 必须跟在函数名称后面。

#### 尾部调用优化

当一个函数内部有语句调用自身时，且该语句位于函数的最后一句（注意这一句必须是单纯地调用函数自身的语句，而不能是一个表达式语句），或者这句后面只有 `如果` 语句的 `以上` 语句。这时运行环境会对这语句进行尾部调用优化。

尾部调用优化即不会创建新的调用栈，而是更改函数的参数值直接再运行一次函数体的代码。

实际上语法解析器在满足尾部调用优化的情况下，会把调用函数自身的语句替换成 `回到`（`recur`）语句。

### 实例方法和特性函数 （::考虑移动）

如果某个数据类型（包括结构体和联合体）具备了某个`特性`（`Trait`，又叫做类型类、TypeClass），或者被赋予了实例方法，则可以在这个数据类型的实例上使用点号（"."）来调用特性当中的函数或者实例方法。

比如有一个 "可显示"（"Display"）特性，其中有一个 "转为字符串"（"toString"） 的函数。现有赋予该特性给结构体 "用户"，则有 3 种方式调用 "转为字符串" 函数：

```js
01  让 a = 可显示<用户>.转为字符串 (用户甲)    # 普通的函数调用方式
02  让 b = 转为字符串 (用户甲)                # 根据第一个参数自动推导对应的函数
03  让 c = 用户甲.转为字符串 ()               # 点号调用方式
```

```js
01  let a = Display<User>.toString (userA)
02  let b = toString (userA)
03  let c = userA.toString ()
```

上面代码当中：

* 01 行是标准的函数调用方式；
* 02 行是运行环境先在当前上下文是否存在 "转为字符串" 函数，如果没有则根据第一个参数查找是否存在对应的特性函数或者数据实例方法，如果存在则使用相应的函数（上例中运行环境找到了特性函数 "可显示<用户>.转为字符串"）；
* 03 行是使用了特性函数点号的调用方式。

实际上点号调用方式是一个语法糖。即，对于如下格式的函数调用：

* `特性名称.函数名 (数据实例, 参数值1, 参数值2, ... 参数值N)`
* `TraitName.functionName (dataInstance, value1, value2, ... valueN)`

可以简写如下：

* `数据实例.函数名 (参数值1, 参数值2, ... 参数值N)`
* `dataInstance.functionName (value1, value2, ... valueN)`

需注意仅当特性函数或者实例方法的第一个参数为数据实例的类型时才能使用点号调用方式，有些特性函数和实例方法的第一个参数未必恰好是当前数据实例的类型。

使用省略特性名称或者数据类型名称的调用方式（也叫做隐式方法调用）比较接近动态脚本语言的风格，但存在名称冲突的风险（编译时会显示警告信息）。

使用点号调用函数比较接近一般面向对象编程语言的对象实例的方法（method）调用风格和习惯，例如：

```java
# Java
User userA = ...;
int id = userA.id;             # 访问对象的属性
String text = userA.toString() # 访问对象的方法
```

```js
# XiaoXuan
let userA = ...
let id = userA.id  # 访问结构体的成员
let text = userA.toString() # 调用类 "Display" 的 "toString()" 方法
```

在条件允许的情况下推荐使用第 3 种调用方式。

如果要在数字（整数和浮点数）字面量后面使用点号调用函数，需要使用括号把数字包围起来，示例：

```js
让 a = (123).平方()
```

直接在数字后面写上点号和函数名称会引起运行时异常。

### 函数的点号调用方式 （::考虑移动）

#### 一般函数（::不支持）

> 已经弃用该特性，因为容易会跟特性函数调用混淆

如果一个值的数据类型跟一个函数的第一个参数的数据类型一致，也可以使用点号（"."）来调用该函数。

示例：

```js
函数 整数 平方 (整数 i) = ...
让 i = 12
让 s = i.平方()
```

```js
function Int square (Int i) = ...
let i = 12
let s = i.square()
```

跟特性函数的点号调用不同，特性函数只需导入了目标数据类型即可。而一般函数的点号调用需要将该函数导入到当前的模块当中。

#### 连续的函数点号调用（::不支持）

> 已经弃用该特性，因为容易会跟特性函数调用混淆

只要符合点号调用的要求，则可以使用 "." 符号连续调用这两个或多个函数。比如有如下 3 个函数：

```js
函数 整数 加 (整数 i, 整数 i) = ...
函数 整数 平方 (整数 i) = ...
函数 显示 (整数 i) = ...
```

```js
function Int add (Int i, Int i) = ...
function Int square (Int i) = ...
function show (Int i) = ...
```

现在想 "求 (3 + 4) 的平方，并把结果输出到标准输出"，每次单独调用一个函数的写法如下：

```js
让 i = 加 (3, 4)
让 j = 平方 (i)
显示 (j)
```

```js
let i = add (3, 4)
let j = square (i)
show (j)
```

或者写成一行：

* `显示 (平方 (加 (3, 4)))`
* `show (square (add (3, 4)))`

如果使用点号连续调用，则代码可以写成：

* `加 (3, 4) .平方 () .显示 ()`
* `add (3, 4) .square () .show ()`

使用点号连续调用比 "连续多行的单独函数调用" 或者 "嵌套调用" 更直观。

如果要换行，可以把点号 "." 另起一行，示例：

```js
让 a = 加(3,4)
    .平方()
    .显示()
```

点号连续调用的结合方向是从左到右的。

### 拆封 （::考虑移动）

如果一个值的类型为 `Result` 或者 `Option`，除了可以使用模式解构获取其有效值，还能通过拆封关键字 "||" 进行读取。

设有变量 `a` 为 `Option<Int>` 类型，如果当前值为 `Some(123)`，则语句

`let b = a || 0`

会让变量 `b` 的值为 `123`。

拆封关键字只可以作用在实现了 `封装`（`Wrapper`） 类列的数据，否则会引起运行时异常。

#### 指定拆封的后备值 <!--替换值--> （::考虑移动）

拆封关键字 "||" 的右侧用于指定拆封失败后的替换值（也可以称为默认值）。

继续上面的例子，假如这时变量 `a` 的值为 `None`，则下面的语句：

`let b = a || 456`

会让变量 `b` 的值为 `456`。

也就是说：

* 当 `a` 的值为 `Some(123)` 时，变量 `b` 的值为 `123`，
* 当 `a` 的值为 `Nothing` 时，变量 `b` 的值为 `456`。

#### 指定拆封的替换值为表达式 （::考虑移动）

拆封关键字 `||` 的右侧除了可以是基本的数值，也可以是任意返回类型相符合的表达式。

下面是使用拆封关键字串联几个函数的例子：

```js
let s = "0b1010"
let x = parseDec(s) || parseHex(s) || parseBin(s) || 0
```

上面的语句会依次尝试对字符串 `s` 解析为十进制、十六进制和二进制数，只要中途任何一个成功，都会立即返回值给变量 `x`，当全部都解析都失败时，则返回最后指定的默认值 0。

拆封默认值关键字的结合顺序是从左到右。

#### 指定拆封的替换为语句块 （::考虑移动）

拆封关键字 "||" 的右侧还可以是一个语句块，只要该语句块的返回类型相符合即可。如果该语句块由多个语句组成，需要使用一对括号把它们包围起来，

#### 指定拆封的后备匿名函数

可以使用一个匿名函数获取拆封失败的详细情况。

比如对于打开文件的函数 `open`，其返回值为 `Result<File, IO.Error>`，当文件打开成功时返回 `Ok(File)`。

当文件打开失败时返回 `Err(Error)`，我们可以通过这个 `Error` 实例进一步了解文件打开失败的原因，比如，如果是 `Error.kind() === ErrorKind.NotFound`，我们可以创建一个新文件，然后返回打开这个新文件的 `File` 数据实例。

代码如下：

```js
let file = File.open("hello.txt") || e =>
    if e.kind() == ErrorKind.NotFound then
        File.create("hello.txt") ?
    else
        return Err(e)
    end
```

如果不使用拆箱关键字，则上面的代码等同于：

```js
let file = match File.open("hello.txt")
    case Ok(file):
        file
    case Err(e):
        if e.kind() == ErrorKind.NotFound then
            match File.create("hello.txt")
                case Ok(file):
                    file
                case Err(e):
                    Err(e)
            end
        else
            Err(e)
        end
    end
```

#### 会自动退出函数的拆封 （::考虑移动）

有时候希望在拆封失败时直接让函数返回失败值，即退出函数，而不是抛出运行时异常，这样可以使用 "?" 关键字拆封。

示例：

```js
01  function Result<String, IO.Error> read(String filePath)
02      let f = openFile(filePath) ?
03      ...
04  end
```

在上面的示例中，如果 02 行拆封失败，则直接让函数返回 `Err()` 而不是抛出运行时异常。在写 I/O 密集的代码时，因为大部分 I/O 函数都是返回 `Result` 类型的数据，使用 "?" 可以避免频繁处理 I/O 异常，直接返回 `Err` 给更上一级的模块处理异常。

如果不使用拆箱关键字，则上面的代码等同于：

```js
function Result<String, IO.Error> read(String filePath)
    let f = match openFile(filePath)
        case Ok(f):
            f
        case Err(error):
            return Err(error)
    end
    ...
end
```

### 链式调用 （::考虑移动）

跟 "连续函数点号调用" 类似，关键字 ">>" 也能连续调用函数，只需第二个函数的首个参数的数据类型跟第一个函数的返回值拆封后的数据类型一致即可。可以粗略地认为 ">>" 关键字是 "??" 关键字和函数点号调用的结合体。

即链式调用会自动拆封 `Result` 和 `Option` 等实现了 `Wrap` 特性的数据，当拆封成功则把其值作为第一个参数传递给第二个函数，如果拆封失败则根据预先定义的值直接传递给下一个节点。

假设有三个函数 `fa`、`fb` 和 `fc`，其参数都有且只有一个 `Int`，返回值都是 `Option<Int>`，现假设有如下语句：

`let a = fa (100) >> fb () >> fc ()`

如果三个函数的返回值都是 `Some(Int)`，则 `a` 的值也是 `Some(Int)`，如果中间任何一个函数值返回的是 `None`，则 `a` 的值都会为 `None`。

注意链式调用当中的节点可能会转换返回类型，比如第一节点返回的是 `Result`，第二节点返回的是 `Option`，则最终返回的数据就是 `Option` 类型。

关于链式调用的详细情况请参见 [链式调用](chain.md)。

### 函数的组合

如果一个函数的返回值的数据类型符合另一个函数的第一个参数（有且只有一个参数）的数据类型，则可以使用函数组合符号（`&`）将两个或多个函数组合起来形成一个新的函数，例如：

* `让 a = 负 (平方根 (加 (2, 3)))`
* `let a = neg (sqrt (add (2, 3)))`

可以写成：

```js
让 我的组合函数 = 负 & 平方根 & 加
让 a = 我的组合函数 (2, 3)
```

```js
let myCombFunc = neg & sqrt & add
let a = myCombFunc (2, 3)
```

当然也可以把函数的组合、函数的调用一次过进行：

* `让 a = 负 & 平方根 & 加 (2, 3)`
* `let a = neg & sqrt & add (2, 3)`

函数组合的结合方向是**从右到左**的，即先从右侧的函数开始计算，然依次计算到最左侧的函数。

如果一个函数有多个参数，可以使用部分调用（假如函数支持部分调用，即有柯里化的重载，诸如 `map`、`fold`、`filter`、`sort`、`match` 等常用函数具有柯里化重载）后再组合，比如：

```js
让 加十分 = 加 (10)  # "加 (10)" 的返回值是一个部分函数： fn (b) = 10 + b
让 我的组合函数 = 平方根 & 加十分 & 平方
让 a = 我的组合函数 (60)
```

```js
let addTen = add (10)  # "add (10)" return a partial function： fn (b) = 10 + b
let myCombFunc = sqrt & addTen & square
让 a = myCombFunc (60)
```

也可以写成一行：

* `让 a = 平方根 & 加 (10) & 平方 (30)`
* `let a = sqrt & add (10) & square (30)`

根据函数结合律，多个输入输出类型相同的函数在组合时，函数顺序不重要，最终结果都相同，不过因为在执行时是从最右边的函数开始（即从右向左结合），一般来说可以把能减少数据的函数先执行，比如要实现 “取字符串第一个字母并转为大写” 的函数，先取数组第一个元素再转换为大写，比先转为大写再取第一个字母的效率要高。

函数组合也并非一定是平铺结构的，有时需要 "层次型" 结构，示例：

```js
let toParamCase = join('_') & map(Char::toLowerCase) & split(" ")
```

### 使用 `调用` 函数调用函数（::不支持）

使用 `调用` 函数调用一个函数的格式是：`调用 (函数名, 参数元组)`

示例：

```js
# 函数的一般调用方式
让 s1 = 测试 (123, "Hello")

# 使用 `调用` 语句来调用
让 args = (123, "Hello")
让 s2 = 调用 (测试, args)
```

```js
# normal call
lets1 = test (123, "Hello")

# call by 'call' statement
let args = (123, "Hello")
let s2 = call (test, args)
```

每个函数内部都有一个名为 "_参数值表_"（"_arguments_"） 的元组，其中记录者该函数被调用时所传入的所有参数值。

```js
函数 浮点数 测试 (整数 a, 整数 b)
  让 和 = 调用 (加, _参数值表_)
  让 差 = 调用 (减, _参数值表_)
  平方根 (和^2 + 差^2)
以上
```

```js
function Float test (Int a, Int b)
  let a = call (add, _arguments_)
  let b = call (sub, _arguments_)
  sqrt (a^2 + b^2)
end
```

### 函数的中置调用方式

如果一个函数只有两个参数，则在调用时可以使用中置格式，即：<!--使用反单引号（"`"）将函数名包围起来--> 在函数名前面加上冒号，然后将两个参数分别写在函数的左右两边。

比如函数：

* `让 a = 加 (11, 55)`
* `let a = add (11, 55)`

其中置调用的写法是：

```js
让 a = 11 :加 55
```

```js
let a = 11 :add 55
```

所有名称由**纯符号**构成的函数都使用中置格式调用，如函数 "+" 和 "*" （它们分别是函数 "加" 和 "乘" 的别名）等等。

示例，下面 3 句的作用完全相同：

```js
让 a = 加 (11, 55)
让 b = 11 :加 55
让 c = 11 + 55
```

```js
let a = add (11, 55)
let b = 11 :add 55
let c = 11 + 55
```

XiaoXuan 语言里没有运算符，所有运算符实际上都是函数的别名。

### 优先级和结合性

当**多个中置函数连续调用**时，不同的中置函数可以有不同的优先级别（即有不同的执行先后顺序），相同优先级别的又有 "从左到右" 和 "从右到左" 两种不同的结合方向。优先级和结合方向是由定义函数时定义的。

默认情况下，所以中置函数的优先级别一样，且都遵循 "从左到右" 的结合方向。比如：

* `让 a = 1 + 8 - 3`
* `let a = 1 + 8 - 3`

在求值时，首先会执行表达式 `1 + 8`，得出值 `9` 之后再执行表达式 `9 - 3`，最后得出结果 `6`。

有些函数有较高的优先级，比如：

* `让 b = 1 + 2 * 3`
* `let b = 1 + 2 * 3`

因为 `*` 函数定义的优先级别比 `+` 的要高，所以会先执行表达式 `2 * 3`，得出值 `6` 之后再执行表达式 `1 + 6`，最后得出结果为 `7`。

从右到左的结合方向的函数比较少，常见的有幂运算函数 `^`，比如：

* `让 c = 4 ^ 3 ^ 2`
* `let c = 4 ^ 3 ^ 2`

它会先执行表达式 `3 ^ 2`，得出值 `9` 之后再执行表达式 `4 ^ 9`。

### 内置的中置函数的优先级

部分内置的中置函数的优先级（从高到低排列）如下，如无单独指出，结合顺序默认都是从左到右：

1. 幂运算：`^`（`:幂`，`:pow`），结合顺序为从右到左；
2. 有理数分隔符：`//`；
2. 算术运算乘除余：`*`（`:乘`，`:mul`）、`/`（`:除`，`:div`）、`%`（`余`，`:rem`）、`.*`（`点乘`，`:dotMul`，即两个结构相同的数组逐个元素相乘，或者其中一个是标量）、`./`（`:点除`，`:dotDiv`）、`:余`（`:rem`）；
3. 算术运算加减：`+`（`:加`，`:add`）、`-`（`:减`，`:sub`)；
4. 位运算移位：`:左移`（`:leftShift`）、`:右移`（`:rightShift`）、`:逻辑右移`（`:logicRightShift`）；
5. 位与运算：`:位与`（`:bitAnd`）；
6. 位或运算：`:位或`（`:bitOr`）；位运算这个跟 C 语言有所不同，C 语言通常位运算的优先级在相等比较之后。因为 XiaoXuan 语言的逻辑值不能转换为数字类型，且只能进行逻辑运算，又因为大小比较和相等比较运算的结果是逻辑值，所以 "位运算与或" 放在这两种运算之后则变得无意义，所以 XiaoXuan 把它的优先级调高；
6. 大小比较运算，集合元素查找：`>`（`:大于`，`:greatThan`）、`>=`（`:大于等于`，`:greatThanEqual`）、`<`（`:小于`，`:lessThan`）、`<=`（`:小于等于`，`:lessThanEqual`）、`:存在于`（`:in`）、`:含有`（`:contains`）；
7. 相等比较运算：`==`（`:等于`，`:equal`）、`!=`（`:不等于`，`:notEqual`）；
8. 逻辑与：<!-- `&&` -->（`:并且`，`:and`）
9. 逻辑或：<!-- `||` -->（`:或`，`:or`）

参考: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

XiaoXuan 里没有："负" 运算符 `-`、位运算 "位反" 运算符 `~` 以及逻辑 "非" 运算符 `!`，只有相应的函数 `负`（`neg`），`位反`（`bitInv`）和 `非`（`not`） 函数，示例：

```java
# Java
int a = - (3 + 4);
bool b = !(true && false);
int c = ~0xff00aabb
```

```js
# XiaoXuan
let a = neg (3 + 4)
let b = not (true :and false)
let c = bitInv (0xff00aabb)
```

### 中置调用的原理

中置符号使用 `运算符` 语句定义，`运算符` 语句定义了符号所对应的函数名称、运算优先级别、结合顺序。

示例：

```js
运算符 ("+", "加", 优先级 = 99, 结合顺序值 = 结合顺序.左)
```

`运算符` 语句必须写在模块级作用范围内。

运算符定义之后，当解析器遇到存在运算符（即纯符号组成的标识符）的表达式时，则会查找运算符对照表，然后根据运算优先级和结合顺序，将表达式当中的运算符解析成第一个参数数据的方法调用。

示例：

`2 + 3`

解析器通过查表找到 `+` 符号对应的函数名为 `加`，然后将表达式解析为：

`(2).加(3)` （因为 `2` 是数字，所以被加上了一对括号）

由于 `2` 是整数，所以方法调用语句被进一步解析为数据的静态方法以及找到函数的原型：

`整数::加 (2, 3)`
`整数::加 (Int, Int)`

下面列举一个有两个 `+` 符号的表达式的解析过程：

`a + b + c`

解析过程：

1. a.加(b + c)
2. a.加(b.加(c))
3. a.加(整数::加(b, c))
4. 整数::加(a, 整数::加(b, c))

### 表达式的执行顺序

下面列出各种表达式的执行顺序（优先级从高到低排列），如无单独指出，结合顺序默认都是从左到右：

1. 分组及语句块，即一对括号或者使用 `开始...以上`（`begin...end`）包围起来的部分。分组和语句块的结合顺序是从左到右，比如连续两个括号 `(...)()` 则先对前一个求值；分组和分组嵌套时，先求内部的再求外部的值 `(j+(i+(...)))` == `... + i + j`。
2. `新建 N::T (...)`（`new N::T (...)`）新建数据实例语句，`新建 T.M.N (...)`（`new T.M.N (...)`）新建联合体成员实例语句；(::考虑取消 new 关键字，直接采用构造函数的普通函数调用即可)
3. 名称空间路径如 `std::collection::Array`，结合顺序为从左到右。
4. `instance.function_name()` 数据实例方法的点号调用，`function_name (...)` 函数的一般调用；
5. 结构体（联合体、枚举、常量）成员访问（即点号）如 `user.name`、`user.addr.city`，列表的索引访问（即中括号加数字下标）如 `books[1]`、`table[1][2]`；映射表项目的访问（即中括号加字符串）`user["name"]`、`user["name"]["first"]`；
6. 函数的组合（`&`）（因为有时需要先函数部分调用后再结合，所以函数组合运算符的优先级低于函数调用），结合顺序为从右到左；
9. 函数的中置格式调用；
10. 函数的链式调用（`>>`）;
7. 带后备的拆封表达式（`||`）
8. 带函数返回功能的拆封（`?`）；
11. 函数的管道调用（`|`）；
<!-- 13. 线程变量赋值语句(`:=`)。 -->
12. 赋值、解构语句（`=`），结合顺序为从右到左。

需要注意的是函数的一般调用方式要比函数的中置调用方式优先级要高，示例：

* `让 a = 平方根 (9) + 平方根 (16)`
* `let a = sqrt (9) + sqrt (16)`

在执行时会先计算两个 `平方根` 函数，得出值之后再计算 `+` 函数。

> 如果一个结构体的成员是函数，则需要使用把这个数据实例和成员用括号包括起来才能正确调用，比如 `(user.func).(arg1, arg2, ...)`，如果写成 `user.func(arg1, arg2)` 会被认为是调用实例方法。一般不建议将函数作为结构体的成员。

## 函数的定义

### 语法

使用 `函数`（`function`） 关键字定义一个函数，格式如下：

```js
函数 返回值的数据类型 函数名称 (参数类型1 参数名称1, ..., 参数类型N 参数名称N)
    ...
    函数主体
    ...
以上
```

```js
function DataType functionName (DataType1 param1, ..., DataTypeN paramN)
    ...
    function body
    ...
end
```

函数的主体是一个或多个语句或表达式，最后一个表达式的值将会作为函数的返回值。示例：

```js
函数 浮点数 两点距离 (整数 x1, 整数 y1, 整数 x2, 整数 y2)
    让 a = (x2 - x1) ^ 2
    让 b = (y2 - y1) ^ 2
    平方根 (a + b)
以上
```

```js
function Float distance (Float x1, Float y1, Float x2, Float y2)
    let a = (x2 - x1) ^ 2
    let b = (y2 - y1) ^ 2
    sqrt (a + b)
end
```

最后一行的 `平方根` 函数的结果将会作为函数的返回值。当然也可以加上 `return` 关键字，在函数主体最后一行的 `return` 关键字实际上在运行时会直接忽略。

#### 省略返回值数据类型(::考虑)

<!--
定义函数时，如果省略了返回值的数据类型：

* 对于普通定义的函数，会自动被认为返回值类型为 `结果<基元, 基元>`（`Result<Unit, Unit>`）（别名 `空型`，`Void`），如果 `返回`（`return`）关键字后面不加任何值，则会自动被认为是 `返回 好(空值)`（`return Ok(void)`），其中 `空值` 值等同于空元组 `()`。
* 对于匿名函数，会根据上下文环境自动推导，推导过程是先查找所处的环境所需要的数据类型，如果无从推导则由返回值来决定。
-->

考虑关键字 `无返回`（`void`）

比如

```js
函数 无返回 测试(字符串 a， 字符串 b)
  输出行(`a: {a}, b: {b}`)
以上
```

```js
function void test(String a, String b)
  writeLine(`a: {a}, b: {b}`)
end
```

如果函数不注明返回数据类型，则自动被添加 `无返回`（`void`）关键字。

无返回函数的签名是：

`void <- functionName (param1, param2, ...)`

#### 简写形式

如果函数的主体是一个表达式，则可以把函数的定义写成一行：

* `函数 返回值的数据类型 函数名称 (参数类型1 参数名称1, ..., 参数类型n 参数名称n) = 表达式`
* `function DataType functionName (DataType1 param1, ..., DataTypeN paramN) = expression`

示例：

* `函数 整数 加十分 (整数 a) = a + 10`
* `function Int addTen (Int a) = a + 10`

表达式不一定要求在一行内写完，只要是一个合法的表达式均可， 比较长的表达式也是可以换行的，示例：

```js
函数 浮点数 距离 (整数 x1, 整数 y1, 整数 x2, 整数 y2) =
    平方根 (
        (x2 - x1) ^ 2 +
        (y2 - y1) ^ 2)
```

```js
function Float distance (Int x1, Int y1, Int x2, Int y2) =
    sqrt (
        (x2 - x1) ^ 2 +
        (y2 - y1) ^ 2)
```

上例当中的 `=` 符号、`(` 符号， `+` 符号后面均表示语句尚未结束。

### 函数别名

可以为一个函数设置另一个名称，使用 `别名`（`alias`） 关键字定义函数的别名，语法如下：

* `别名 新函数名称 = 原函数名称`
* `alias newName = originalFunctionName`

示例：

* `别名 "+" = 加`
* `alias "+" = add`

如果函数名称包含有符号，需要将函数名称使用双引号包围起来。

* 别名对一个函数的所有重载均起效。即别名只跟函数的名称有关，跟函数的签名无关；
* 一般别名的定义跟原函数的定义在同一个作用域里。比如在某个模块里定义的函数，其别名也应该在这个模块里定义；在某个特性里定义的函数，其别名也应该在该特性里定义。

### 匿名函数

使用 `匿名函数`（`fn`） 关键字可以定义一个匿名函数，匿名函数没有名称，通常在一个函数内部定义及使用，或者作为参数传给另一个（高阶）函数。

定义匿名函数的语法：

```js
让 变量名称 =
    匿名函数 返回值的数据类型 (参数类型1 参数名称1, ..., 参数类型N 参数名称N)
        ...
        # 函数主体
        ...
    以上
```

```js
let variable =
    fn DataType (DataType1 param1, ..., DataTypeN paramN)
        ...
        # function body
        ...
    end
```

跟标准函数的定义一样，如果函数的主体是一个表达式，则可以把匿名函数的定义写成一行：

* `让 变量名称 = 匿名函数 返回值的数据类型 (参数类型1 参数名称1, ..., 参数类型N 参数名称N) = 表达式`
* `let variable = fn DataType (DataType1 param1, ..., DataTypeN paramN) = expression`

示例：

```js
让 乘加 = 匿名函数 整数 (整数 a, 整数 x, 整数 b) = a * x + b
让 a = 乘加 (2, 3, 4)
```

```js
let mulAdd = fn Int (Int a, Int x, Int b) = a * x + b
let a = mulAdd (2, 3, 4)
```

XiaoXuan 支持定义完立即调用，因为括号的结合顺序是从左到右，所以会先对第一对括号求值，如果返回值类型是函数，则将第二对括号的内容作为参数，调用该匿名函数。示例：

* `让 a = (匿名函数 整数 (整数 a) = a * 2) (4)`
* `let a = (fn Int (Int a) = a * 2) (4)`

如果一个匿名函数作为参数传给另一个函数，因为参数的类型包含了函数签名的信息，即类型推导能推导出匿名函数的返回值的数据类型及各个参数的数据类型，则可以省略书写返回值的数据类型以及各参数的数据类型。

示例：

```js
function pick(List<Int> items, F f) where
    F = Boolean <- (Int)
    ...
end

let numbers = [1, 2, 3, 4, 5]
let fav = pick(numbers, fn (i) = i > 3 )
```

上例中的 `fn (i) = i > 3` 匿名函数省略了返回值数据类型，也省略了参数的数据类型。

### 匿名函数捕获变量值（闭包）

如果一个匿名函数的主体引用了匿名函数之外的变量，则变量的值会被捕获，即使匿名函数离开了其被定义的作用域，该被捕获的值仍然有效。示例：

```js
函数 F 增长(整数 i) 其中
    F = 整数 <- (整数)

    返回 匿名函数 (整数 x) = i + x
以上

让 f1 = 增长 (10)  # 函数 f1 绑定了值为 10 的变量 i
让 f2 = 增长 (20)  # 函数 f2 绑定了值为 20 的变量 i

输出行 (f1 (2)) # 输出 12
输出行 (f2 (2)) # 输出 22
```

```js
function F inc(Int i) where
    F = Int <- (Int)

    return fn (x) i + x
end

let f1 = inc (10)  # `f1` binds the variable i with value 10
let f2 = inc (20)  # `f2` binds the variable i with value 10

writeLine (f1 (2)) # output 12
writeLine (f2 (2)) # output 22
```

在支持可变变量的编程语言里，f1 和 f2 里引用了一个共同的变量 i，假如变量 i 的值（或者 i 的成员的值）被 f1 改变了，则该改变也会反映到 f2 所绑定的变量 i 里，有时这种改变并不是预想的，因此引起错误。示例：

```JavaScript
function inc() {
    let fns = [];
    let step = 0;
    for(let i=0; i<10; i++) {
        step +=1;
        let fn = x => x + step;
        fns.push(fn);
    }

    # fns 里包含 10 个匿名函数，其绑定的 step 的值都是 10，
    # 而不是 1 到 10。

    for(let fn of fns) {
        console.log(fn(5)); # 都输出 15
    }

    # 下面是修正版
    let ffs = [];
    for(let i=0; i<10; i++) {
        let step = i; # 复制 i 值到变量 step
        let fn = x => x + i;
        ffs.push(fn);
    }

    for(let ff of ffs) {
        console.log(ff(5)); # 依次输出 5,6,7,8, ..., 15
    }
}
```

在 JavaScript 环境里，当匿名函数使用自身之外的变量时，变量（不是变量的值，而是变量本身，或者说标识符本身）会被该匿名函数所捕获，如果匿名函数被返回并被传递到其他地方，该捕获仍然存在，即该匿名函数能够一直访问到该变量的最新的值。

示例：

```JavaScript
function makeCounter() {
    let n = 1;
    return [
        () => n = n + 1,
        () => n = n - 1,
        () => n
    ]
}

# makeCounter 函数返回一个数组，数组有三个匿名函数，
# 一个递增，一个递减，一个返回当前值

let [inc, dec, get] = makeCounter();
inc();  # 返回 2
inc();  # 返回 3
get();  # 返回 3
dec();  # 返回 2
dec();  # 返回 1
```

在 JavaScript 环境里，每个函数被执行时都有两个指针，一个指向父词法环境（即调用者 caller 的词法环境） ，一个指向当前的词法环境（即 callee 自己的词法环境），匿名函数也不例外。当匿名函数被当作返回值跳出所在的函数时，函数尚未被执行，所以没有自己的词法环境。但因为匿名函数有对其所在的环境的引用（即存在上述的第一个指针），所以所在的函数的词法环境不会被回收，会一直被保持者，直到匿名函数被回收为止。

参考《javascript info》的 "作用域与闭包" 一章:
https://zh.javascript.info/closure#step-4-fan-hui-han-shu

XiaoXuan 的变量值是不可变的，因此在匿名函数里引用的外部变量时，仅仅引用了一份该变量的值（对于复制类型的值，则是复制），匿名函数被当作返回值跳出所在的函数之后，如果所在的函数已经执行完毕，则它的词法环境可以放心被回收，XiaoXuan 的垃圾回收效率会更高一些。

### 简化形式的匿名函数

正如前两节所说，如果一个匿名函数在一个函数签名确定的上下文环境里（比如作为一个参数传给另一个函数），那么匿名函数可以省略书写返回值数据类型以及参数的数据类型。在这种情况下，XiaoXuan 支持一种简化形式的匿名函数格式。语法是使用符号 `=>` 分隔参数和函数主体部分，如果参数的只有一个，则连参数的括号都可以省略。

简化形式的匿名函数也可以称为 "箭头函数"。

示例：

```js
# 假设函数签名为： Int <- (Int)
匿名函数 Int (Int x) = x + 10 # 标准版匿名函数
匿名函数 (x) = x + 10         # 省略数据类型的匿名函数
x => x + 10                  # 简化版匿名函数

# 假设函数签名为：Int <- (Int, Int)
匿名函数 Int (Int x, Int y) = sqrt(x^2 + y^2) # 标准版匿名函数
匿名函数 (x, y) = sqrt(x^2 + y^2)             # 省略数据类型的匿名函数
(x,y) => sqrt(x^2 + y^2)                     # 简化版匿名函数
```

```js
# function signature: Int <- (Int)
fn Int (Int x) = x + 10 # standard anonymous function
fn (x) = x + 10         # standard anonymous function without data types
x => x + 10               # simplified anonymous function

# function signature：Int <- (Int, Int)
fn Int (Int x, Int y) = sqrt(x^2 + y^2) # standard anonymous function
fn (x, y) = sqrt(x^2 + y^2)             # standard anonymous function without data types
(x, y) => x^2 + y^2                    # simplified anonymous function
```

下面是一个实际的例子：

```js
让 s = [1, 2, 3, 4, 5, 6];
让 翻倍s = s.映射(x => x * 2)
```

```js
let s = [1, 2, 3, 4, 5, 6];
let double_s = s.map(x => x * 2)
```

`映射`（`map`）的函数签名为 `List<E> map<T, E=T>(List<T>, E <- (T))`，其中第 2 个参数接受一个函数，该函数的作用是从一个数 `T` 转换成另外一个数 `E`，它是一个转换函数，`map` 函数的作用就是将一列数根据你的需要转换得另外一列数。比如你的转换函数是将传入的整数乘于 2,那么输入 `[1,2,3]` 经过 `map` 转换得出 `[2,4,6]`。

上例中，变量 s 的数据类型是 `列表<整数>`（`List<Int>`）, 由类型推导出 `map` 函数个类型参数是 `List<Int> map(List<Int>, Int <- (Int))`，其中转换函数的签名为：

* `整数 <- (整数)`
* `Int <- (Int)`

因此我们需要可以构造一个符合这个签名的匿名函数：

* `匿名函数 整数 (整数 n) = n * 2`
* `fn Int (Int n) = n * 2`

这个匿名函数的定义可以省略数据类型：

* `匿名函数 (n) = n * 2`
* `fn (n) = n * 2`

进一步简化该匿名函数：

* `x => x * 2`

跟标准的匿名函数一样，简化版匿名函数也是支持多行的，只要在冒号 `:` 后面写上表示语句块的 `开始`（`begin`），然后写多行函数体，再以 `以上`（`end`）关键字表示结束，示例：

```js
让 翻倍s = s.映射(x =>
    开始
        x * 2
    以上)
```

```js
let double_s = s.map(x =>
    begin
        x * 2
    end)
```

### `返回` 关键字

`返回`（`return`） 关键字用于立即退出当前的函数，可以带着一个返回值。

示例：

```js
函数 整数 处理(整数 a)
    ...
    如果 ... 那么 返回 123
    ...
以上
```

当程序执行到 `返回` 语句时，不管当时正在执行到函数主体的哪条语句，都会立即返回一个值给调用者，并且放弃执行 `返回` 语句之后的语句。

#### 省略 `返回` 关键字

因为函数的最后一个表达式的值会自动成为函数的返回值，所以如果 `返回` 关键子位于函数的最后一行，则可以省略这个关键字。

#### 匿名函数当中的 `返回` 关键字

如果 `返回` 关键字位于匿名函数，包括简写版匿名函数 `:`，则它仅仅退出当前的匿名函数，而不会退出外部的函数。

示例：

```js
函数 整数 处理(整数 a)
    ...
    让 整数 b = 匿名函数(整数 c)
        ...
        如果 ... 那么 返回 456
        ...
    以上
    ...
以上
```

上例当中的 `返回` 仅仅将 `456` 返回给变量 `b`，而不是返回给函数 `处理` 的调用者。

#### 流程控制语句当中的 `返回` 关键字

在诸如 `如果`，`分支`，`选择`，`条件`， `遍历` 等等语句里，`返回`（`退出`）关键字都是直接退出语句所在的函数。

#### 尾部调用

如果一个函数主体的最后一行是调用函数自己，则称之为 "尾部调用"。XiaoXuan 运行环境会对尾部调用进行优化，不创建调用栈，防止堆栈溢出。

示例：

```js
01  函数 整数 累加(整数 i)
02      让 内循环 = 匿名函数(整数 current, 整数 total)
03          如果 current == 0 那么 返回 total
04          让 s = total + current
05          内循环 (current - 1, s)
06      以上
07
08      返回 内循环(i ,0)
09  以上
10
11  让 c = 累加(100)
```

上例中第 05 行调用了其所在的函数 "内循环"，且是最后一句，所以是尾部调用。

注意尾部调用必须是**单纯的**调用函数自身（返回值可以是任意符合参数要求的值），且必须位于函数主体的**最后一句**。

示例：

```js
01  函数 整数 累加(整数 i)
02      让 内循环 = 匿名函数(整数 current, 整数 total)
03          如果 current == 0 那么
04              返回 total
05          否则
06              让 s = total + current
07              内循环 (current - 1, s)
08          以上
09      以上
```

上面的代码跟上一个示例的语义是完全一样的，但 XiaoXuan 仅简单地依据是否最后一句来判断是否尾部调用，因为 07 行之后还有 `以上` 一句，所以被运行时认为不是尾部调用。

### 函数的重载

可以定义两个或以上名称相同、返回值的数据类型相同，但参数列表不同的函数，这种情况称为函数的重载。函数重载一般是为了让调用者可以有选择地灵活调用函数。

示例：

```js
01  函数 说 (字符串 name) = 输出行 (name)
02  函数 说 (字符串 name, 字符串 sentence) = 输出格式行 ("{} 你好, {}", name, sentence)
03
04  说 ("张三", "吃饭了吗") # 调用 02 函数
05  说 ("张三") # 调用 01 函数
```

```js
01  function say (String name) = writeLine (name)
02  function say (String name, String sentence) = formatWriteLine ("Hi {}, {}", name, sentence)
03
04  say ("Foo", "What's up") # call 02
05  say ("Foo") # call 01
```

* 函数重载要求参数列表必须**不相同**，可以是参数数量不相同，可以是参数的类型不相同，<!-- 可以是参数的模式不相同，--> 或者两者皆不相同。
* 函数重载要求返回值数据类型必须**相同**，实际上，在同一个模块里不允许同名但不同返回值类型的函数。


#### 跨模块重载（::不支持）

函数重载也可以重载其他模块的函数，假设模块 "a" 有函数 "Int calc(Int i)"，则在模块 "b" 也能重载该函数，方法是先把模块 "a" 的目标函数导入到模块 "b"，然后在 "b" 的模块范围内定义一个参数不同的同名函数即可。

示例：

```js
module b

# import a function from another module
import a.calc

# overload the function
function Int calc(Float i)
    # ...
end
```

#### 参数的默认值和可选参数

函数的参数支持指定默认值，带有默认值的参数在调用时可以省略，所以这种参数也叫做 "可选参数"。相对地，位置参数也可以叫做 "必选参数"。

一个函数的可选参数可以有零个或多个，但只能在排在必选参数之后，也就是可选参数必须排在参数列表的末尾。

示例：

```js
function draw(Point p, Int width = 1, Color color = ColorConst::Black)
```

上面的后两个参数 `width` 和 `color` 即为可选参数。

跟常量的定义一样，默认值只能是基本的数据或者是结构体、联合体的默认构造函数所产生的值。

对于带有可选参数的函数，其签名的参数列表是所有参数。即无论是必选参数还是可选参数，都属于函数签名，且无视参数名和默认值。比如上例的函数其签名为：

```js
void <- (Point, Int, Color)
```

> 可选参数只是函数调用的语法糖，当一个函数调用省略了某些参数的值时，运行时会从函数的定义里获取默认值，然后补齐缺少的参数值，再调用目标函数。

### 重载冲突

函数重载要求参数的类型或者个数不同，这条规则同样适用于带有可选参数的函数。即在判断一个重载是否有冲突时，**无视参数名称**，仅依据参数的数据类型和顺序来判断。

假设有如下两个函数重载：

```js
function test(Int a, String b, Int c = 88) = ...
function test(Int a, String x = "foo", Int y = 99) = ...
```

如果仅看必选参数部分，其函数签名似乎不存在冲突，如下：

```js
void <- (Int a, String b)
void <- (Int a)
```

然而 XiaoXuan 的判断规则是无视是否可选参数、也无视参数名，所以它们的真正函数签名是存在冲突的，如下：

```js
void <- (Int, String, Int)
void <- (Int, String, Int)
```

之所以如此判断，是因为 XiaoXuan 优先支持按位置传参，当一个函数调用仅使用位置传参时，显然它仅看参数的数据类型和顺序。

具体的判断重载是否有冲突的步骤如下：

1. 将所有重载的可选参数去除；
2. 按照必选参数的数量从少到多排序；
3. 然后挑选必选参数最少的那个重载，扫描一遍是否存在签名一样（仅看参数的数据类型和顺序）的重载，存在则说明存在冲突，判断结束；
4. 逐个可选参数添加，每添加一个，都扫描一次是否存在签名一样的重载，存在则说明存在冲突，判断结束；
5. 当所有可选参数都添加并且确定无冲突时，排除此重载，即将此重载从判断列表中移除。然后重复第 3 到第 5 步。
6. 当所有的重载都不存在冲突时，则说明此函数的定义是语法正确的。

<!--
如果一个函数存在重载，且重载当中存在可选参数，则必须保证各个重载不存在歧义的参数列表，否则会引起运行时异常。

示例：

```js
function drawA(Point p)
  ...
end

function drawA(Point p, Int width = 1)
  # Invalid
end

function drawB(Point p, Color c)
  ...
end

function drawB(Point p, Int width = 1, Color c = ColorConst::Black)
  # Invalid
end

function drawC(Point p, Color c)
  ...
end

function drawC(Point p, Int width = 1)
  # OK
end

function drawD(Point p, Color c = ColorConst::Black)
  ...
end

function drawC(Point p, Int width = 1)
  # OK
end
```

上面的 `drawA` 和 `drawB` 的第 2 个函数定义都会引起运行时异常，因为它的必选参数部分跟另外两个函数的数据类型相同，且可选参数会跟其他重载存在歧义。

具体过程是，在语法解析之后，运行环境会把存在可选参数的函数当中的可选部分当作不存在，然后拿必选参数部分跟其他重载比较：

1. 如果参数类型不一样，则认为是合法的重载，没进一步比较的必要；
2. 如果参数类型一样，则拿取正在比较的两个函数的剩余部分参数（不分必选还是可选），只有有一个参数集合是空的，或者两个集合存在交集，都认为是非法重载。

有这样的限制，主要是为了消除歧义，在调用之前调用者就已经（通过静态分析）可以确认它真正调用的是哪个重载。
-->

需注意的：

* 即使函数重载的定义不存在冲突，在调用时，如果调用语句使用了按参数名称传参，则仍然存在冲突的可能，详细见函数调用冲突章节；
* XiaoXuan 语句的函数调用优先匹配参数的数据类型和顺序，此时将无视参数的名称，这部分匹配完毕之后，再根据调用语句当中的名称参数跟函数定义当中剩余的参数进行名称匹配。
* 为了方便静态分析和编译，同时也是为了降低语言实现的难度，XiaoXuan 语言**不支持变长参数**。

<!--
### 函数的模式匹配（::不支持）

函数的参数不仅仅用于引用或记录传入的参数值（类似赋值语句），同时还能作为模式匹配，即只有实参跟参数要求的模式相匹配时，该参数才会获取相应的值。示例：

```js
01  函数 显示余数 (Int a, Int 0) = 输出行 ("除数不能为零")
02  函数 显示余数 (Int a, Int b) = 输出格式行 ("余数为 {}", a `余` b)
03
04  显示余数 (5, 2) # 02 行函数被调用
05  显示余数 (5, 0) # 01 行函数被调用
```

```js
01  function showRemain (Int a, Int 0) = writeLine ("The divisor cannot be zero")
02  function showRemain (Int a, Int b) = writeLine ("The remainder is {}", a `rem` b)
03
04  showRemain (5, 2) # 02 function is invoked
05  showRemain (5, 0) # 01 function is invoked
```

运行环境会根据函数的定义顺序，对每个函数的参数列表进行匹配，只有匹配中的那个函数定义才会被执行。

函数重载其实也是函数模式匹配的一种，对一个函数的匹配顺序是：

1. 检查参数的个数；
2. 检查每个参数的数据类型；
3. 检查每个参数是否模式匹配。

详细的模式匹配见 [08 模式](pattern-and-matching.md)
-->

### 分支函数

可以在函数定义后面使用关键字 `分支`（`branch`）让函数根据不同的条件执行不同的主体，这种函数称为 "分支函数"。

分支函数的关键字是 `分支`（`branch`），写在函数的参数列表，或者 `其中`（`where`）列表之后，也可以单独一行写。然后是一个或多个使用 `情况`（`case`） 关键字的条件分支。

改写上一个示例如下：

```js
01  函数 显示余数 (Int a, Int b) 分支
02      情况 b == 0: 输出行 ("除数不能为零")
03      情况 b > a: 输出行 ("除数比被除数还大")
04      情况 b == a: 输出行 ("没有余数")
05      默认: 输出行 ("余数为 {}", a `余` b)
06  以上
07
08  显示余数 (5, 0) # 执行 02 行
09  显示余数 (5, 6) # 执行 03 行
10  显示余数 (5, 5) # 执行 04 行
11  显示余数 (5, 2) # 执行 05 行
```

```js
01  function showRemain (Int a, Int b) branch
02      case b == 0: writeLine ("The divisor cannot be zero")
03      case b > a: writeLine ("divisor is larger than dividend")
04      case b == a: writeLine ("no remainder")
05      default: writeLine ("The remainder is {}", a `rem` b)
06  end
07
11  showRemain (5, 0) # execute line 02
10  showRemain (5, 6) # execute line 03
08  showRemain (5, 5) # execute line 04
09  showRemain (5, 2) # execute line 05
```

每一个分支情况后面都接着一个能返回逻辑值的表达式，当表达式返回 `真` 时，该分支会被执行。`分支` 语句的语法跟 `条件` 语句一样（`分支` 语句是 `条件` 语句的语法糖，如果 `分支` 里缺少 `默认` 分支，则运行时会自动添加一个抛出运行时异常的默认分支）。条件语句的详细用法请参见 [流程控制](control-flow.md)。

每一个分支都是独立的一个函数主体。如果函数主体是多行语句，则需要在语句 `情况`（`case`）关键字后面换行写。

最后一个分支通常是不限任何条件的默认分支，如果没有默认分支，当所有的条件都不满足时，运行环境会抛出一个运行时错误。

#### 函数的分支与数学的函数定义

带分支语句的函数与数学的函数定义非常接近，考虑如下一个函数：

```js
function int check (Int x) branch
    case x >= 90: 1
    case x >= 80: 2
    case x >= 70: 3
    case x >= 60: 4
    default: 5
end
```

对应的数学函数：

\[
check(x)=
    \begin{cases}
        1,  & \text{if } x \geq 90\\
        2,  & \text{if } x \geq 80\\
        3,  & \text{if } x \geq 70\\
        4,  & \text{if } x \geq 60\\
        5,  & \text{otherwise}
    \end{cases}
\]

## 纯函数

纯函数是指函数的返回值只跟输入的参数值有关，跟所在的上下文环境无关，而且只要输入参数值一样，总能得出一样的结果值。

典型的纯函数如 `加`，`减` 等算术函数，运行环境提供了一系列纯函数，这些函数被标上 `@pure` 标注。

需要注意纯函数必须有具有意义的输入参数和返回值，当用户定义的函数只调用纯函数时，它自身也会自动成为纯函数。

XiaoXuan 运行环境能够对纯函数作优化处理，比如延迟执行、缓存结果、并行执行等。
