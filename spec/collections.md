# 集合

## 列表

列表（List）是一系列数据类型相同的数据。

列表字面量的格式是：使用一对中括号包围所有数据，数据之间使用逗号分隔。

示例：

* `让 a = [1, 2, 3]`
* `让 b = [3.14, 2.718, 0.618]`
* `让 c = ["天地玄黄", "宇宙洪荒", "日月盈昃", "辰宿列张"]`
* `让 d = [真, 假, 假, 真]`

* `let a = [1, 2, 3]`
* `let b = [3.14, 2.718, 0.618]`
* `let c = ["twinkle", "twinkle", "little", "star"]`
* `let d = [true, false, false, true]`

上面的语句分别构建了 `列表<整数>`（`List<Int>`），`列表<浮点数>`（`List<Float>`），`列表<字符串>`（`List<String>`），`列表<逻辑>`（`List<Boolean>`）四个列表。

一个列表里不能同时存在不同类型的数据，比如下列的语句是错误的。

* `让 a = [100, 200, 2.9979e8, 6.67e-11]` // 前两个元素是整数型，后两个是浮点型。
* `让 b = ["寒来暑往", 真, "秋收冬藏"]` // 前后两个是字符串型，中间是逻辑型。

* `let a = [100, 200, 2.9979e8, 6.67e-11]` // there are both Int and Float
* `let b = ["hickory", true, "dickory"]` // there are both String and Boolean

### 构建数列列表

在中括号内使用**范围**关键字 `..` （即两个点号，虽然都是符号，但它不是运算符）可以构建一个数列，比如：

`[1..10]`

将会生成一个含有从 "开始值" 整数 1 到 "结束值" 整数 10 的列表，即 `[1,2,3,4,5,6,7,8,9,10]`。

开始值和结束值和符号 `..` 之间的空格有无均可。

默认的步进值是整数 `1`,如果想设置其他步进值，则除了需要提供 "开始值" 和 "结束值"，还需要额外提供第 2 个元素，步进值就是 (第 2 个元素 - 开始值)。比如：

`[1, 3..10]`
`[10,20..50]`

分别生成列表 `[1,3,5,7,9]` 和 `[10,20,30,40,50]`，步进值分别是 `3-1=2` 和 `20-10=10`。

#### 动态指定开始值、结束值和步进值

开始值、结束值和步进值除了接受字面值，也可以是变量，比如

```
let start = 10
let end = 15
let a = [start..end]
```

将会生成 `[10,11,12,13,14,15]`。

#### 浮点数数列

如果想生成浮点数数列，则必须提供第 2 个元素以确定步进值，比如：

`[0.1, 0.2 .. 0.5]`

将会生成 `[0.1, 0.2, 0.3, 0.4, 0.5]`

#### 字符列表

字符数据类型存储的是 Unicode 字符，在运行时实际上是 `UInt32`，所以开始值、结束值、步进值也可以是字符。

示例：

`['a' .. 'f']`

将会生成字符列表 `['a','b','c','d','e']`。需要注意的是 Unicode 的码点（code point）并不是连续的，所以在生成字符列表时会自动跳过那些无效的 Unicode 字符。

#### 延迟执行（未定::）

当 XiaoXuan 运行环境执行诸如 `[1 .. 10^19]` 语句时，不用担心机器的内存会被消耗光，因为当一个数列列表的元素比较多时，运行环境并不会立即产生这个数列，而是在真正需要时才产生并返回相应的数据。技术地说，这个数列跟普通数列有一样的访问接口，但实际上在内存里它只是一个函数。

#### 省略开始值或结束值（未定::）

当省略结束值时，数列的结束值会被设定为起始值数据类型的最大值，比如对于默认的 `整数` 类型，其默认值为 2^63-1。对于 `字符` 类型，最大值则是 Unicode 的最后一个码点（code point）。示例：

`让 a = [1, 3 ..]`
`let a = [1, 3 ..]`

会产生数列 `[1, 3, 5, 7 ...` 一直到 `Int64` 最后一个数字。

当省略 "开始值" 时，则表示从整数 0 或者浮点数 0.0 或者字符 '\1' 开始，到 "结束值" 为止，示例：

`让 a = [.. 7]`
`让 b = [.. 5, 7]`

`let a = [.. 7]`
`let b = [.. 5, 7]`

上面两行分别产生 `[1, 2, 3, 4, 5, 6, 7]` 和 `[1, 3, 5, 7]` 两个数列。

需要注意的是不能同时省略开始值和结束值。

### 无穷列表（未定::）

并不是所有列表都是由真实的一列数据组成的，比如上面提到的数列列表，有些列表实际上是一些延迟执行的函数，因此也存在一些有无穷个元素的列表，后面的 "I/O" 章节会讲到。

### 增加列表的元素

XiaoXuan 的所有类型的数据都不支持更改，所以无法直接对一个列表自身增加、修改或者删除元素，所有对列表更改的操作都会产生一个新的列表。为了提高效率和节约资源，XiaoXuan 运行环境内部对于一般的列表采用单向链表来实现（需注意，不同的情况下具体的列表实现方式会各不相同，并不是总是单向链表），在单向链表的头部（最新元素的那端）添加元素能在常数时间内完成，所以如果要增加列表元素，一般都是往链表的头部添加。

XiaoXuan 使用一对中括号和**展开**关键字 "..."（即三个点号，虽然都是符号，但它不是运算符）的格式实现往列表头部添加一个元素。示例：

现有列表 `a`：

`让 a = [1, 2, 3]`
`let a = [1, 2, 3]`

添加整数 `88` 到列表头部，则语句如下：

`让 b = [88, ...a]`
`let b = [88, ...a]`

将会得到一个新的列表 `b`，其值为 `[88, 1, 2, 3]`。

也可以一次添加多个元素，比如：

`让 c = [77, 88, 99, ...a]`
`let c = [77, 88, 99, ...a]`

将会得到一个新的列表 `b`，其值为 `[77, 88, 99, 1, 2, 3]`。

需注意:

* 新添加的元素总是出现在列表的头部，而不是一般语言常见的添加到列表的尾部。
* 关键字 `...` 只能出现在中括号的末尾，语句 `[...a, 4, 5]` 会引起运行时错误（语法错误）。

XiaoXuan 提供 `添加`（`add`）函数用于实现以上的操作，示例：

`添加 (a, 8)`
`添加 (a, [77,88,99])`

`add (a, 8)`
`add (a, [77,88,99])`

### 拼接列表

使用 `拼接`（`concat`）函数（符号为 `++`）可以将两个列表拼接起来，并返回一个拼接后的新列表。

假设有两个列表 `[1,2,3]` 和 `[7,8,9]`，则：

`让 a = [1,2,3] ++ [7,8,9]`
`let a = [1,2,3] ++ [7,8,9]`

将会得到一个新的列表 `[1,2,3,7,8,9]`。

需注意：

* 待拼接的列表的数据类型必须相同；
* 拼接操作是从右到左结合，如 `[1,2] ++ [5,6] ++ [8,9]` 先拼接后两个列表得 `[5,6,8,9]` 然后再拼接第一个列表；
* 因为字符串实际上是 `列表<字符>`（`List<Char>`），所以字符串的拼接也是使用 `++` 函数，比如： `"hello" ++ " " ++ "world"` 得到 `"hello world"`。

### 获取列表的大小

使用 `长度`（`length`）函数可以获取列表的大小，示例：

`让 i = 长度 (a)`
`让 i = a.长度()`

`let i = length (a)`
`let i = a.length()`

注意（未定::）：对于无穷列表，这个函数会引起运行时错误。

### 访问列表的元素

下面通过例子说明如何读取列表的元素。

现假设有列表 `a` 其内容为 `[1, 2, 3, 4, 5]`：

* `第一个`（`head`）函数获取第一个元素

  `第一个 (a)`
  `head (a)`

  将返回 `1`。

* `尾部`（`tail`）函数获取除第一个元素之外，由剩余元素组成的一个新列表。

  `尾部 (a)`
  `tail (a)`

  将返回 `[2, 3, 4, 5]`。

* `最后一个`（`last`）函数获取列表的最后一个元素。

  `最后一个 (a)`
  `last (a)`

  将返回 `5`

* `头部`（`init`）函数获取除了最后一个元素之外，由其他元素组成的一个新列表。

  `头部 (a)`
  `init (a)`

  将返回 `[1, 2, 3, 4]`。

* `获取`（`get`）函数用于获取指定位置的元素。

  `获取 (a, 2)`
  `get (a, 2)`

  将返回 `2`。函数的第二个参数表示需要获取的元素的位置，需注意：

  * 位置从数字 1 开始，而不是从 0 开始。很多语言的列表索引值（下标）是从 0 开始的，但 XiaoXuan 的是从 1 开始；
  * 位置值的最大值为列表的长度；
  * 位置值不能超出列表的范围，即小于 1 或者大于列表长度，否则都会引起运行时错误。

* 使用中括号获取元素。示例：

  `让 i = a[2]`
  `let i = a[2]`

  中括号里面写上需要获取的元素的位置，其作用与 `获取项目 (a, 2)` 一样。

  需注意的是，如果列表的具体实现是一个单向链表，则按位置来访问元素的效率比较低，它需要逐个元素遍历直到你直到的位置为止，虽然有些列表的实现可能会针对按位置访问做了一些优化，但习惯上我们应该尽量避免高频次使用位置值来访问列表。

* `选取 (开始位置, 此前位置)`（`slice (startPos, beforePos)`）函数选取指定范围的元素，并返回一个新列表。

  `选取 (a, 2, 4)`
  `a.选取 (2, 4)`

  `slice (a, 2, 4)`
  `a.slice (2, 4)`

  将返回 `[2, 3]`。

  需注意列表位置从数字 1 开始，而不是从 0 开始。而很多语言的列表或者数组的索引值（下标）是从 0 开始的。

  `选取` 函数的参数：

  * 第 1 个参数为源列表。
  * 第 2 个参数表示选取范围的开始位置，取值范围从 1 到列表的长度；
  * 第 3 个参数表示选取范围和结束位置，但选取的结果不包括这个结束位置，可以将第三个参数想象为 "选取到该位置之前" 的元素。取值范围从 1 到"列表长度 + 1"。

  需注意：

  * 如果 "开始位置 == 此前位置"，则会返回一个空列表 `[]`。
  * "此前位置" 必须大于等于 "开始位置"，"开始位置" 和 "此前位置" 不能超出列表的范围，否则都会引起运行时错误。

  第三个参数也可以省略，表示选取从 "开始位置" 到列表的最后一个元素，示例：

  `选取 (a, 3)`
  `slice (a, 3)`

  将返回 `[3, 4, 5]`。

* 使用范围符号选取元素。

  `让 i = a[2:3]`
  `let i = a[2:3]`

  中括号里面写上需要获取的范围的 "开始位置" 和 "此前位置"，中间用 ":" （冒号）隔开，其作用与 `slice (a, 2, 3)` 一样。

  "开始位置" 或者 "此前位置" 可能省略其中的一个，当省略 "开始位置" 时，表示从位置 1 开始。当省略 "此前位置" 时，表示选取到最后一个元素。示例：

  `让 i = a[3:]`
  `让 j = a[:3]`

  `let i = a[3:]`
  `let j = a[:3]`

  上面变量 i 的值为 `[3, 4, 5]`，表示获取从第 3 个元素开始的新列表；j 的值为 `[1, 2, 3]`，表示获取前 3 个元素的新列表。

* 赋值语句的模式匹配（解构）

  使用赋值语句的模式匹配（解构）来获取列表的元素比使用函数的更加简单直观，示例：

  ```
  // 获取第 1 个元素并赋值给变量 i，此时 i == 1
  让 [i] = a

  // 获取第 1 和第 2 个元素分别赋值给变量 i 和变量 j，此时 i == 1, j == 2
  让 [i, j] = a

  // 获取第 1 和第 2 个元素，第 1 个元素的值丢弃，第 2 个元素的值赋值给 i，此时 i = 2
  让 [_, i] = a

  // 获取第 1 个以及剩余的元素，第 1 个元素赋值给变量 i，
  // 剩余的元素（是一个列表）赋值给变量 j，此时变量 j == [2, 3, 4, 5]。
  让 [i, ...j] = a

  // 获取第 1 和第 2 个以及剩余的元素，前两个元素分别赋值给变量 i 和 j，
  // 剩余的元素（是一个列表）赋值给变量 k，此时变量 k == [3, 4, 5]
  让 [i, j, ...k] = a
  ```

  需注意的是**剩余**关键字 `...` （即三个点，同 "展开" 关键字）只能出现在中括号的末尾，诸如 `let [i, ...j, k]` 的语句会引起运行时错误（语法错误）。

访问列表元素一般使用 `头`, `尾`, `let b = [1, ...a]`，`let [i, ...j] = b` 等几个操作方法，这些方法都能够在常数时间内完成，效率比其他方法高。

### 删除元素

实际上不存在删除元素操作，如果要完成 "删除" 元素之目的，需要转换成 "获取" 所需的元素操作。

示例：

```
// 目的：删除列表的第 1 个元素
// 方法：获取除了第 1 个元素之外的剩余元素
让 b = 尾部 (a)
让 [_, ...b] = a

// 目的：删除列表的前两个元素
// 方法：调用两次 `尾部` 函数，或者使用模式匹配解构丢弃前两个元素
让 c = a -> 尾部 -> 尾部
让 [_, _, ...c] = a

// 目的：删除列表的前 N 个元素（0 <= N < 列表长度）
// 方法：获取从位置 N+1 开始往后的所有元素
让 d = a[N+1..]

// 目的：删除列表的后 N 个元素（0 <= N < 列表长度）
// 方法：获取从位置 1 开始，到 "总个数 - N" 位置为止这个范围内的元素
让 e = a[1 .. a.长度() - N]
让 e = a[.. a.长度() - N]
```

```
// expected: delete the first element of the list
// solution: get the remaining elements except for the 1st element
let b = tail (a)
let [_, ...b] = a

// expected: delete the first two elements of the list
// solution: call the `tail` function twice, or use pattern matching
// deconstruction to discard the first two elements
let c = a -> tail -> tail
let [_, _, ...c] = a

// expected: delete the first N elements of the list (0 <= N < list length)
// solution: get all elements from position N+1
let d = a[N+1..]

// expected: delete the last N elements of the list (0 <= N < list length)
// solution: get the elements in the range
// from position 1 to the "Total - N" position
let e = a[1 .. a.length() - N]
let e = a[.. a.length() - N]
```

XiaoXuan 提供了 `删除(开始位置, 此前位置)`（`remove (startPos, beforePos)`） 函数简化上述的操作，用于实现 "删除" 指定范围的元素之目的，示例：

`让 e = a.删除(2, 4)`
`let e = a.remove(2, 4)`

变量 e 的值为 `[1, 4, 5]`。

### 切分列表

使用 `切分`（`split`）函数可以在指定位置将一个列表切分为两个列表，示例：

`让 (x, y) = a.切分(3)`
`let (x, y) = a.split(3)`

`切分` 函数返回一个元组，元组有两个成员，分别是切分而得的前后两个列表。其中参数表示切分的 "此前位置"（假设为 N），从位置 1 到从位置 N-1 的元素形成第一个列表。从位置 N 到到最后一个元素形成第二个列表。所以上面的示例将会得到 `[1, 2]` 和 `[3, 4, 5]` 两个列表。

"此前位置" 允许的范围值从 1 开始到 "列表长度 + 1"，如果：

* "此前位置" 值为 1，则返回一个空列表和一个跟源列表一样的列表，即 `[]` 和 `[1,2,3,4,5]`；
* "此前位置" 值为 "列表长度 + 1"，则返回一个跟源列表一样的列表和一个空列表，即 `[1,2,3,4,5]` 和 `[]`。

如果 "此前位置" 值超出允许范围，则会引出运行时异常。

### 插入元素或列表

插入元素由 "切分列表" 和 "拼接列表" 两个操作完成，XiaoXuan 提供了 `插入`（`insert`） 函数完成上述操作。

示例，分别有新元素 `99` 和新列表 `[77,88,99]` 准备插入到位置 N（即把新内容放到位置 N 之前，即插队），假设 N = 3，代码如下：

```
让 N = 3

让 (x, y) = a.切分(N)
让 aa = x ++ [99, ...y]
让 ab = x ++ [77,88,99] ++ y

让 aa = 插入(a, N, 99)
让 ab = 插入(a, N, [77,88,99])
```

```
let N = 3
let (x, y) = a.split(N)
let aa = x ++ [99, ...y]
let ab = x ++ [77,88,99] ++ y

let aa = insert(a, N, 99)
let ab = insert(a, N, [77,88,99])
```

最后变量 aa 的值为 `[1,2,99,3,4,5]`，ab 的值为 `[1,2,77,88,99,3,4,5]`。

`插入`（`insert`）函数的参数是 "此前位置"。

### 追加元素或列表

当传入 "列表长度 + 1" 给函数 `插入` 时，实际的效果是追加元素或列表。使用 `追加`（`append`） 函数可以使目的更明确。不过需要注意的是，追加元素或列表的效率比在列表头添加元素的要低很多，一般不建议使用追加操作。

### 替换元素或列表

替换元素由两次 "切分列表" 和两次 "拼接列表" 共 4 个操作完成，XiaoXuan 提供了 `替换`（`replace`） 函数完成上述操作。

示例，分别有新元素 `99` 和新列表 `[77,88,99]` 准备替换从位置 M 开始到位置 N 之前的元素，假设 M = 2，N = 4，代码如下：

```
让 M = 2
让 N = 4

让 (x, y) = a.切分(M)
让 (p, q) = y.切分(N-M+1)
让 aa = x ++ [99, ...q]
让 ab = x ++ [77,88,99] ++ q

让 aa = 替换(a, M, N, 99)
让 ab = 替换(a, M, N, [77,88,99])
```

```
let M = 2
let N = 4

let (x, y) = a.split(M)
let (p, q) = y.split(N-M+1)
let aa = x ++ [99, ...q]
let ab = x ++ [77,88,99] ++ q

let aa = replace(a, M, N, 99)
let ab = replace(a, M, N, [77,88,99])
```

最后变量 aa 的值为 `[1,99,4,5]`，ab 的值为 `[1,77,88,99,4,5]`。

### 查找元素或列表

`查找`（`find`）函数可以在指定的列表中查找指定的元素或者列表，并返回找到的位置。如果没发现目标，则返回 0。

示例：

```
让 i = a.查找(4)        // 得 4
让 j = a.查找([3,4])    // 得 3
让 m = a.查找(99)       // 得 0
让 n = a.查找([77,88])  // 得 0
```

```
let i = a.find(4)        // get 4
let j = a.find([3,4])    // get 3
let m = a.find(99)       // get 0
let n = a.find([77,88])  // get 0
```

## 映射表

映射表（Map）是一系列 "键-值对" 数据。

映射表的字面量是：使用一对花括号包围所有数据，多个 "键-值对" 之间使用逗号分隔，使用 "键名:值" 构建 "键-值对"。示例：

```
{
    "东": 123,
    "西": 456
}
```

```
{
    "甲": "子",
    "乙": "丑",
    "丙": "寅",
    "丁": "卯"
}
```

```
{
    "foo": 123,
    "bar": 456
}
```

键支持大部分类型的数据，只要实现了 "可比较" 特性即可，值可以是任何类型的数据。当键为字符串类型时，键名的双引号可以省略，比如上面第一个映射表，可以简化为：

```
{
    东: 123,
    西: 456
}
```

需注意一个映射表里的所有 "键-值对" 的数据类型必须一样，上面示例的第一个映射表数据类型是 "映射表<字符串, 整数>", 第二个是 "映射表<字符串, 字符串>"。

XiaoXuan 运行环境默认使用二叉树来实现映射表。

### 访问映射表的元素

使用 `获取`（`get`）函数用于获取指定键的元素。

假设现有映射表 `a` 内容如下：

```
让 a = {
    "东": 1,
    "西": 2,
    "南": 3,
    "北": 4
}
```

如果项获取键 "西" 的值，语句如下：

`让 i = 获取 (a, "西")`
`让 i = a.获取 ("西")`

`let i = get (a, "西")`
`let i = a.get ("西")`

函数返回 `可选<字符串>`（`Option<String>`） 数值，如果存在指定键对应的值，则数值为 `有(值)`，否则数值为 `无`。这个例子里，变量 i 的值为 `有(2)`。

除了使用 `获取` 函数，还可以使用一对中括号来获取指定键的值。示例：

`让 i = a["西"]`
`let i = a["西"]`

变量 i 的值跟使用 `获取` 函数的返回值一样。

当然也可以使用模式匹配，示例：

```
// 同时获取键 "东" 和 "南" 的值，并赋值给变量 i 和 j。
让 {"东": i, "南": j} = a

// 同上，然后将剩余的 "键-值对" 存入变量 k，变量 k 将是一个映射表，
// 其内容为 `{"西": 2, "北": 4}`
让 {"东": i, "南": j, ...k} = a

// 当键的数据类型是字符串时，也可以省略双引号
让 {东: i, 南: j} = a

// 如果连变量 i, j 都省略，那么将会得到跟键名一样的变量
让 {东, 南} = a
```

### 添加 "键-值对"

使用 `添加`（`add`）函数向映射表添加新的 "键-值对"，函数返回值是 `结果<映射表>`。如果操作成功，则返回 "完成(新映射表)"，如果键名已经存在，则返回 "错误()"。

示例：

```
match a.add("中", 5)
    case Ok(m): writeLine("new map: {}", m)
    case Err(e): writeLine("error: {}), e)
end
```

也可以使用 `设置`（`set`）函数，当原映射表不存在准备新添加的键名时，作用跟 `添加` 函数一样，当原映射表已存在相同的键名时，则键值将会被新的键值所替代。

### 删除 "键-值对"

使用 `删除`（`remove`） 函数可以 "删除" 映射表指定的 "键-值对"，返回值是 `结果<映射表>`。

## 元组

元组（tuple）通常用于函数的返回值，当函数需要返回的数值不止一个时，可以使用元组。元组跟匿名成员结构体非常相似，即具有固定的、已知数量、已知顺序、已知数据类型的一个或多个成员的组合。

元组的字面量的格式是：使用一对括号包围所有数据，数据之间使用逗号分隔。

示例：

```
(1, 2, 3)
(1, "hello", true, 3.14)
```

元组的数据类型即元组各个成员的数据类型的组合，比如上面两个元组的数据类型分别是：`(整数, 整数, 整数)` 和 `(整数, 字符串, 逻辑, 浮点数)`。需注意，元组每个成员的数据类型都可以不同。

为了一致性，也存在单独一个成员的元组，其字面量是在第一个数值后面加上一个逗号，示例：

`(456, )`
`("foo", )`

上面两个元组的数据类型分别是 `(整数)` 和 `(字符串)`。

### 元组的访问

元组跟列表和映射表不同，它的成员既没有位置值，也没有名称，一般只能使用模式匹配解构来访问其中的成员。

假设现有元组 `a`，其值为：

`(123, "hello", true)`

可以使用如下语句获取它的三个成员的值：

`让 (a,b,c) = a`

这样一来，三个变量 `a`, `b`, `c` 的值分别为 123, "hello" 和 true。

除了解构，还有可以通过运行环境自动为元组生成的成员名称来访问，成员名称的格式是 "_1"，"_2", ... 即一个下划线加上成员的次序。示例：

```
a._1 == 123
a._2 == "hello"
a._3 == true
```

### 添加元组元素

添加新成员到一个元组的头部，可以使用一对圆括号和**展开**关键字 "..." 的格式实现。

示例：

```
让 b1 = (99, ...a)
让 b2 = (77, 88, 99, ...a)
```

元组的操作方法较少，当要表示一列数据（且数据类型相同时）应使用列表，元组一般也仅用于函数的返回值，该返回值的各个元素的类型不相同，且该返回值不是很通用，还不需要单独创建一个结构体专门给它的这种情况。
