# 集合

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [集合](#集合)
  - [列表](#列表)
    - [增加列表的元素](#增加列表的元素)
    - [拼接列表](#拼接列表)
    - [获取列表的大小](#获取列表的大小)
    - [访问列表的元素](#访问列表的元素)
      - [`头`（`first`）函数](#头first函数)
      - [`其余`（`rest`）函数](#其余rest函数)
      - [`主体`（`initial`）函数（::不支持）](#主体initial函数不支持)
      - [`尾`（`last`）函数](#尾last函数)
      - [`获取`（`get`）函数](#获取get函数)
      - [使用中括号获取指定位置的元素](#使用中括号获取指定位置的元素)
      - [`选取`（`slice`） 函数](#选取slice-函数)
      - [使用中括号选取指定范围的元素](#使用中括号选取指定范围的元素)
        - [省略 "元素个数"](#省略-元素个数)
        - [省略 "开始位置"](#省略-开始位置)
      - [其他访问函数](#其他访问函数)
    - [使用模式解构访问列表的元素](#使用模式解构访问列表的元素)
    - [删除元素](#删除元素)
      - [`删除`（`remove`）函数](#删除remove函数)
    - [切分列表](#切分列表)
    - [分隔列表](#分隔列表)
    - [插入元素或列表](#插入元素或列表)
    - [追加元素或列表（::不支持）](#追加元素或列表不支持)
    - [替换元素或列表](#替换元素或列表)
    - [查找元素或（子）列表的出现位置](#查找元素或子列表的出现位置)
    - [查找元素](#查找元素)
  - [映射表](#映射表)
    - [访问映射表的元素](#访问映射表的元素)
      - [使用中括号获取指定键的值](#使用中括号获取指定键的值)
      - [使用模式解构获取指定键的值](#使用模式解构获取指定键的值)
    - [添加新的 "键-值对"](#添加新的-键-值对)
    - [更新已存在的键值](#更新已存在的键值)
    - [添加或更新 "键-值对"](#添加或更新-键-值对)
    - [检查指定键是否存在](#检查指定键是否存在)
    - [删除 "键-值对"](#删除-键-值对)
    - [遍历映射表元素](#遍历映射表元素)
  - [其他序列](#其他序列)
    - [数列](#数列)
      - [等差数列](#等差数列)
      - [动态指定开始值、结束值和步进值](#动态指定开始值-结束值和步进值)
      - [浮点数数列](#浮点数数列)
      - [字符列表（::不支持）](#字符列表不支持)
      - [延迟执行](#延迟执行)
      - [省略结束值](#省略结束值)
      - [省略开始值（::不支持）](#省略开始值不支持)
    - [数列集](#数列集)
    - [随机数列](#随机数列)
    - [队列](#队列)
      - [实例化队列](#实例化队列)
      - [追加元素或列表](#追加元素或列表)
      - [删除元素](#删除元素-1)
      - [转换为普通列表](#转换为普通列表)
    - [集合](#集合-1)
    - [数组](#数组)
      - [字符数组](#字符数组)
      - [多维数组](#多维数组)
    - [矩阵](#矩阵)
    - [重复序列](#重复序列)
      - [重复多元素的序列](#重复多元素的序列)
      - [重复字符串](#重复字符串)
      - [延迟执行](#延迟执行-1)
    - [表格](#表格)
  - [几种序列的使用场景](#几种序列的使用场景)

<!-- /code_chunk_output -->

## 列表

序列是一系列数据类型相同的数据，其中最常用的序列是 `列表`（`List`）。

列表字面量的格式是：使用一对中括号包围所有数据，数据（称为 "元素"）之间使用逗号分隔。

示例：

```js
让 a = [1, 2, 3]
让 b = [3.14, 2.718, 0.618]
让 c = ["天地玄黄", "宇宙洪荒", "日月盈昃", "辰宿列张"]
让 d = [真, 假, 假, 真]
```

```js
let a = [1, 2, 3]
let b = [3.14, 2.718, 0.618]
let c = ["twinkle", "twinkle", "little", "star"]
let d = [true, false, false, true]
```

上面的语句分别构建了四个列表：

* `列表<整数>`（`List<Int>`）
* `列表<浮点数>`（`List<Float>`）
* `列表<字符串>`（`List<String>`）
* `列表<逻辑>`（`List<Boolean>`）

一个列表里不能同时存在不同类型的元素，比如下列的语句是错误的：

```js
让 a = [100, 200, 2.9979e8, 6.67e-11]  # 前两个元素是整数型，后两个是浮点型。
让 b = ["寒来暑往", 真, "秋收冬藏"]     # 前后两个是字符串型，中间是逻辑型。
```

```js
let a = [100, 200, 2.9979e8, 6.67e-11] # there are both Int and Float
let b = ["hickory", true, "dickory"]  # there are both String and Boolean
```

### 增加列表的元素

XiaoXuan 的所有类型的数据都不支持更改，自然无法对一个列表增加、修改或者删除元素。所有对列表更改的操作的方法（函数）都会产生一个新的列表。

XiaoXuan 运行环境内部默认采用单向链表来实现列表，在单向链表的头部（最新元素的那端）添加元素能在常数时间内完成，所以如果要增加列表元素，一般都是往列表的头部添加。相反，往列表末尾添加元素的效率则非常低（因为要重新构建一次列表）。

在实际应用过程中，对列表的操作应该采用与数据结构中的 "栈（Stack）" 比较相似的方式，元素的操作遵循 "先进后出（FILO）" 原则。

XiaoXuan 使用一对中括号和**展开**关键字 "..."（即三个点号，虽然都是符号，但它不是运算符）的格式实现往列表头部添加一个元素。示例：

假设有列表 `a`：

* `让 a = [1, 2, 3]`
* `let a = [1, 2, 3]`

现在需要添加整数 `88` 到列表头部，则语句如下：

* `让 b = [88, ...a]`
* `let b = [88, ...a]`

将会得到一个新的列表 `b`，其值为 `[88, 1, 2, 3]`。

也可以一次添加多个元素，比如：

* `让 c = [77, 88, 99, ...a]`
* `let c = [77, 88, 99, ...a]`

将会得到一个新的列表 `b`，其值为 `[77, 88, 99, 1, 2, 3]`。

需注意:

* 新添加的元素总是出现在列表的头部，而不像一般语言常见的数组或集合那样————添加到列表的尾部。
* 关键字 `...` 只能出现在中括号的末尾，语句 `[...a, 4, 5]` 会引起运行时错误（语法错误）。

`[x, ...a]` 表达式实际上是调用 `添加`（`add`） 函数的语法糖，示例：

```js
让 b = 添加 (a, 8)
让 b = a.添加(8)
让 c = 添加 (a, [77,88,99])
让 c = a.添加([77,88,99])
```

```js
let b = add (a, 8)
let b = a.add(8)
let c = add (a, [77,88,99])
let c = a.add([77,88,99])
```

而类似 `[x, y, z, ...a]` 这样的表达式，实际上是多次调用 `添加` 函数的语法糖。

### 拼接列表

使用 `拼接`（`concat`）函数（符号为 `++`）可以将两个列表拼接起来，并返回一个拼接后的新列表。

假设有两个列表 `[1,2,3]` 和 `[7,8,9]`，则：

* `让 a = [1,2,3] ++ [7,8,9]`
* `let a = [1,2,3] ++ [7,8,9]`

将会得到一个新的列表 `[1,2,3,7,8,9]`。

需注意：

* 待拼接的列表的数据类型必须相同；
* 拼接操作是从右到左结合，如 `[1,2] ++ [5,6] ++ [8,9]` 先拼接后两个列表得 `[5,6,8,9]` 然后再拼接第一个列表；
* 因为字符串实际上是 `列表<字符>`（`List<Char>`） 数据类型，所以字符串的拼接也是使用 `++` 函数，比如： `"hello" ++ "🈳" ++ "world"` 得到 `"hello🈳world"`。

### 获取列表的大小

使用 `长度`（`length`）函数可以获取列表的大小，示例：

```js
让 i = 长度 (a)
让 i = a.长度()
```

```js
let i = length (a)
let i = a.length()
```

### 访问列表的元素

下面通过例子说明如何读取列表的元素。注意跟经典的函数式编程语言对列表操作的函数名称不同，比如经典的 "head/tail/init/last" 分别表示取 "第一个、除第一个、除最后一个、最后一个"，在 XiaoXuan 里这些访问方法不仅仅用于访问列表，同时还用于序列（即列表的超集），所以函数名称需要作适当的调整。

现假设有列表 `a` 其内容为 `[1, 2, 3, 4, 5]`：

#### `第一个`（`first`）函数

使用 `第一个` 函数可获取第一个元素

```js
让 i = 第一个 (a)
让 i = a.第一个()
```

```js
let i = first (a)
let i = a.first()
```

变量 `i` 的值将会是 `1`。

#### `其余`（`rest`）函数

使用 `其余` 函数可获取除第一个元素之外，由剩余元素组成的一个新列表。

```js
让 i = 其余 (a)
让 i = a.其余()
```

```js
let i = rest (a)
let i = a.rest()
```

变量 `i` 的值将会是 `[2, 3, 4, 5]`。

#### `主体`（`initial`）函数（::不支持）

使用 `主体` 函数获取除了最后一个元素之外，由其他元素组成的一个新列表。

```js
让 i = 主体 (a)
让 i = a.主体()
```

```js
let i = initial (a)
let i = a.initial()
```

变量 `i` 的值将会是 `[1, 2, 3, 4]`。

#### `最后一个`（`last`）函数

使用 `最后一个` 函数获取列表的最后一个元素。

```js
让 i = 最后一个 (a)
让 i = a.最后一个()
```

```js
let i = last (a)
let i = a.last()
```

变量 `i` 的值将会是 `5`。

#### `获取`（`get`）函数

使用 `获取` 函数可获取指定位置的元素。`获取` 函数的签名是：

* `获取 (列表实例, position)`
* `get (listInstance, position)`

```js
让 i = 获取 (a, 2)
让 i = a.获取(2)
```

```js
let i = get (a, 2)
let i = a.get(2)
```

变量 `i` 的值将会是 `2`。上例当中函数参数 `2` 表示待获取的元素的位置，需注意：

* XiaoXuan 的列表位置值从数字 1 开始，而不是从 0 开始（很多语言的数组/列表索引值/下标是从 0 开始的）；
* 位置值允许的最大值为列表的长度，也就是说，位置值的有效范围是从 "0" 到 "列表的长度"；
* 位置值不能超出列表的范围，即小于 1 或者大于列表长度，否则都会引起运行时错误。
* 如果列表的具体实现是一个单向链表，则按位置来访问元素的效率比较低，它需要逐个元素遍历直到指定的位置为止，虽然有些列表的实现可能会针对按位置访问做了一些优化，但习惯上我们应该尽量避免高频次使用位置值来访问列表。

#### 使用中括号获取指定位置的元素

使用中括号可以实现 `获取` 函数一样的功能。

示例：

* `让 i = a[2]`
* `let i = a[2]`

中括号里面写上需要获取的元素的位置，其作用与调用函数 `获取 (a, 2)` 一样。

#### `选取`（`slice`） 函数

使用 `选取` 函数可以选取指定范围的元素，并返回一个新列表。函数的签名是：

* `选取 (列表实例, 开始位置, 元素个数)`
* `slice (listInstance, startPosition, count)`

`选取` 函数各参数的含义：

* 第 1 个参数为源列表。
* 第 2 个参数表示选取范围的开始位置，取值范围从 1 到 "列表的长度 + 1"，选取的结果包括开始位置的元素；
* 第 3 个参数表示选取元素的个数，取值范围从 0 到 "列表长度 - 开始位置 + 1"。比如假设一个列表有 10 个元素，开始位置值为 `2`，则有效的选取元素个数为 `0` 到 `9`。

需注意：

* 如果 "元素个数" 参数传入 `0`，则会返回一个空列表 `[]`；
* 如果 "开始位置" 参数传入 "列表的长度 + 1"，表示从列表最后一个元素的后面开始选取，显然此时能选取的元素个数只能为 "0"，所以函数的返回值会是一个空列表 `[]`；
* "开始位置" 以及 "元素个数" 都不能超出列表的范围，否则都会引起运行时异常。

示例：

```js
让 b1 = 选取 (a, 2, 3)
让 b2 = a.选取 (2, 3)
```

```js
let b1 = slice (a, 2, 3)
let b2 = a.slice (2, 3)
```

上面示例表示从列表 `a` 的第 2 个元素开始（包括第 2 个元素），选取 3 个元素，因此变量 `b` 的值将会是 `[2, 3, 4]`。

第三个参数也可以省略，表示选取从 "开始位置" 到列表的最后一个元素，示例：

* `让 c = 选取 (a, 4)`
* `let c = slice (a, 4)`

变量 `c` 的值将会是 `[4, 5]`。

#### 使用中括号选取指定范围的元素

使用中括号还能实现跟 `选取` 函数一样的功能，语法是：

* `列表实例[开始位置:元素个数]`
* `listInstance[startPosition:count]`

示例：

* `让 b = a[2:3]`
* `let b = a[2:3]`

上面示例表示从列表 `a` 的第 2 个元素开始（包括第 2 个元素），选取 3 个元素，因此变量 `b` 的值将会是 `[2, 3, 4]`。

##### 省略 "元素个数"

如果省略 "元素个数"，表示选取从 "开始位置" 到列表的最后一个元素，示例：

* `让 c = a[4:]`
* `let c = a[4:]`

变量 `c` 的值将会是 `[4, 5]`。

##### 省略 "开始位置"

如果省略 "开始位置"，则表示选取列表最后指定个数的元素。

示例：

* `让 b = a[:3]`
* `let b = a[:3]`

上面示例表示选取列表 `a` 的最后 3 个元素，所以变量 `b` 的值将会是 `[3, 4, 5]`。

#### 其他访问函数

大部分访问函数都提供一个带有 "尝试" 开头的函数，比如 `第一个`（`first`） 函数对应着 `尝试第一个`（`tryFirst`）函数，其返回值是 `结果<T, Error>`（`Result<T, Error>`），用于从那些读取可能会出现错误的列表，比如流（Stream）。

另外，还有一个 （`第一个和其余`）`firstAndRemain` 函数，用于一次读取第一个元素，及其余的元素。

### 使用模式解构访问列表的元素

使用模式解构来获取列表的元素比使用函数的更加简单直观，示例：

```js
让 a = [1,2,3,4,5]

# 获取第 1 个元素并赋值给变量 i，此时 i == 1
让 [i] = a

# 获取第 1 和第 2 个元素分别赋值给变量 i 和变量 j，此时 i == 1, j == 2
让 [i, j] = a

# 获取第 1 和第 2 个元素，第 1 个元素的值丢弃，第 2 个元素的值赋值给 i，此时 i = 2
让 [_, i] = a

# 获取第 1 个以及剩余的元素，第 1 个元素赋值给变量 i，
# 剩余的元素（是一个列表）赋值给变量 j，此时变量 j == [2, 3, 4, 5]。
让 [i, ...j] = a

# 获取第 1 和第 2 个以及剩余的元素，前两个元素分别赋值给变量 i 和 j，
# 剩余的元素（是一个列表）赋值给变量 k，此时变量 k == [3, 4, 5]
让 [i, j, ...k] = a
```

需注意的是**剩余**关键字 `...` （即三个点，同 "展开" 关键字）只能出现在中括号的末尾，诸如 `let [i, ...j, k]` 的语句会引起运行时异常（语法错误）。

### 删除元素

因为值不可变性，实际上不存在删除元素的方法。如果确实要完成 "删除" 元素之目的，只需转换成 "获取" 部分元素的操作即可。

示例：

```js
# 目的：删除列表的第 1 个元素
# 方法：获取除了第 1 个元素之外的剩余元素
让 b = a.尾部()
让 [_, ...b] = a

# 目的：删除列表的前 2 个元素
# 方法：调用 `选取` 函数
让 c = a.选取 (2+1)
让 c = a[2+1:]

# 目的：删除列表的前 N 个元素（0 <= N <= 列表长度）
# 方法：获取从位置 N+1 开始往后的所有元素
让 d = a.选取 (N+1)
让 d = a[N+1:]

# 目的：删除列表的后 N 个元素（0 <= N <= 列表长度）
# 方法：获取从位置 1 开始，获取 "总个数 - N" 个元素
让 e = a.选取[1 : a.长度() - N]
让 e = a[1 : a.长度() - N]
```

```js
# expected: delete the first element of the list
# solution: get the remaining elements except for the 1st element
let b = a.tail()
let [_, ...b] = a

# expected: delete the first two elements of the list
# solution: call the `slice` function
let c = a.slice(2+1)
let c = a[2+1]

# expected: delete the first N elements of the list (0 <= N <= list length)
# solution: get all elements from position N+1
let d = a.slice(N+1)
let d = a[N+1:]

# expected: delete the last N elements of the list (0 <= N <= list length)
# solution: get the elements start from position 1, count "Total - N".
let e = a.slice(1, a.length() - N)
let e = a[1 : a.length() - N]
```

#### `删除`（`remove`）函数

使用 `删除` 函数可以简化 "删除" 中间某个范围元素的操作，需注意的时，`删除` 函数并不会真的删除源列表，而是返回一个删除了指定范围元素的新列表。

`删除` 函数的签名是：

* `删除 (列表实例, 开始位置, 元素个数)`
* `remove (listInstance, startPosition, count)`

函数的参数含义跟 `选取` 函数的一样。

示例：

```js
让 a = [1,2,3,4,5]
让 e = a.删除(2, 3)
```

```js
let a = [1,2,3,4,5]
let e = a.remove(2, 3)
```

上面示例表示从列表 `a` 的第 2 个元素开始，共删除 3 个元素，变量 `e` 的值将会是 `[1, 5]`。

### 切分列表

使用 `切分`（`part`）函数可以在指定位置将一个列表切分为两个列表。

`切分` 函数的签名是：

* `切分 (列表实例, 开始位置)`
* `part (listInstance, startPosition)`

示例：

* `让 (x, y) = a.切分(3)`
* `let (x, y) = a.part(3)`

`切分` 函数返回一个元组，元组有两个成员，分别是切分而得的前后两个列表。其中参数表示切分的开始位置（假设为 N），从位置 1 到从位置 N-1 的元素形成第一个列表。从位置 N （包括 N 元素）到最后一个元素形成第二个列表。所以上面的示例将会得到：

```js
(
    [1, 2],
    [3, 4, 5]
)
```

跟 `选取` 函数类似，"开始位置" 的取值范围从 1 开始到 "列表长度 + 1"。

* 如果 "开始位置" 值为 1，则返回一个空列表和一个跟源列表一样的列表，即 `[]` 和 `[1,2,3,4,5]`；
* 如果 "开始位置" 值为 "列表长度 + 1"，则返回一个跟源列表一样的列表和一个空列表，即 `[1,2,3,4,5]` 和 `[]`。

如果 "开始位置" 值超出允许范围，则会引出运行时异常。

### 分隔列表

使用 `分隔`（`split`）函数可以将一个列表根据指定的值分隔为若干份，示例：

* `让 s = [1,2,0,3,0,4,5,6].分隔(0)`
* `let s = [1,2,0,3,0,4,5,6].split(0)`

则 `s` 的值为：

```js
[
    [1, 2],
    [3],
    [4, 5, 6]
]
```

* 如果找不到指定的值，则返回仅有一个元素的列表，该元素的值跟原列表一样；
* 如果指定的值出现在第一个元素，则返回的列表的第一个元素是空列表；
* 如果指定的值出现在最后一个元素，则返回的列表的最后一个元素是空列表。

考虑如下的一种情况：

```js
让 a = [0, 0]
让 s = a.分隔(0)
```

此时变量 `s` 的值将会是一个 3 个空列表的列表 `[[],[],[]]`。

`分隔` 函数也支持传入一个列表，表示根据这个子列表的值分隔源列表，示例：

```js
让 a = "123abc456abc789"
让 s = a.分隔("abc")
```

因为字符串实质是字符列表，所以上面的语句是可运行的，其表示按照子字符串 "abc" 对源字符串进行分隔，变量 `s` 的值将会是：

```js
["123", "456", "789"]
```

### 插入元素或列表

插入元素可以由 "切分列表" 和 "拼接列表" 两个操作完成，为了简化操作，XiaoXuan 提供了 `插入`（`insert`） 函数。

`插入` 函数的签名是：

* `插入 (列表实例, 开始位置, 新元素)`
* `insert (listInstance, startPosition, newElement)`

参数 "开始位置" 的有效取值范围是从 "1" 到 "列表的长度 + 1"，表示插入的位置（即把新元素放到该位置之前，即插队）。

示例，假设有列表 `[1,2,3,4,5]`，现分别有新元素 `99` 和新列表 `[77,88,99]` 准备插入到位置 N，假设 N = 3，代码如下：

```js
让 N = 3

让 (x, y) = a.切分(N)
让 aa = x ++ [99, ...y]
让 ab = x ++ [77,88,99] ++ y

# 使用 `插入` 函数
让 aa = a.插入(N, 99)
让 ab = a.插入(N, [77,88,99])
```

```js
let N = 3
let (x, y) = a.part(N)
let aa = x ++ [99, ...y]
let ab = x ++ [77,88,99] ++ y

# by using `insert` function
let aa = a.insert(N, 99)
let ab = a.insert(N, [77,88,99])
```

最后变量 aa 的值为 `[1,2,99,3,4,5]`，ab 的值为 `[1,2,77,88,99,3,4,5]`。

### 追加元素或列表（::不支持）

当传入 "列表长度 + 1" 给函数 `插入` 时，实际的效果是追加元素或列表。使用 `追加`（`append`） 函数可以使目的更明确。不过需要注意的是，追加操作的效率比在列表头添加元素的要低很多，一般不建议使用追加操作。

### 替换元素或列表

替换元素可以由两次 "切分列表" 和两次 "拼接列表" 共 4 个操作完成，为了简化操作，XiaoXuan 提供了 `替换`（`replace`） 函数。

`替换` 函数的签名是：

* `替换 (列表实例, 开始位置, 元素个数, 新元素)`
* `replace (listInstance, startPosition, count, newElement)`

示例，假设有列表 `[1,2,3,4,5]`，现分别有新元素 `99` 和新列表 `[77,88,99]` 准备替换从位置 M 开始的 N 个元素，假设 M = 2，N = 3，代码如下：

```js
让 M = 2
让 N = 3

让 (x, y) = a.切分(M)
让 (_, z) = y.切分(M+N)
让 b1 = x ++ [99, ...z]
让 b2 = x ++ [77,88,99] ++ z

# 使用 `替换` 函数
让 b1 = a.替换(M, N, 99)
让 b2 = a.替换(M, N, [77,88,99])
```

```js
let M = 2
let N = 3

let (x, y) = a.part(M)
let (_, z) = y.part(M+N)
let b1 = x ++ [99, ...z]
let b2 = x ++ [77,88,99] ++ z

# by using `replace` function
let b1 = a.replace(M, N, 99)
let b2 = a.replace(M, N, [77,88,99])
```

结果变量 `b1` 的值为 `[1,99,5]`，`b2` 的值为 `[1,77,88,99,5]`。

### 查找元素或（子）列表的出现位置

`查找位置`（`findPosition`）函数可以在指定的列表中查找指定的元素或者子列表，并返回找到的位置（位置值将会被 `可选` 类型的 `有` 封装）。如果没发现目标，则返回 `无`（`None`）。

示例：

```js
让 i = a.查找位置(4)        # 得 `有(4)`
让 j = a.查找位置(99)       # 得 `无`
让 m = a.查找位置([3,4])    # 得 `有(3)`
让 n = a.查找位置([77,88])  # 得 `无`
```

```js
let i = a.findPosition(4)        # get `Some(4)`
let j = a.findPosition(99)       # get `None`
let m = a.findPosition([3,4])    # get `Some(3)`
let n = a.findPosition([77,88])  # get `None`
```

查找位置也支持传入一个签名为 `Boolean <- (T item)` 的函数，查找过程会从列表逐个元素取出然后传递给这个函数，当函数返回 `真`（`true`）时，查找过程中断，并且返回当时的位置。如果查到最后一个元素这个函数仍未返回 `真`，则查找过程返回 `无`（`None`）。

假设现有一个结构体 `用户`（`User`）及几个实例如下：

```js
struct User
    String name
    String email
end

let u1 = User("foo", "foo@domain.local")
let u2 = User("bar", "bar@domain.local")

let uu = [u1, u2]
```

下面的代码用于查找用户名为 "bar" 的元素的位置值：

```js
let i = uu.findPosition(do %.name === "bar")  # get `Some(2)`
let j = uu.findPosition(do %.name === "John") # get `None`
```

### 查找元素

`查找`（`find`）函数可以根据传入的 `Boolean <- (T item)` 查找符合的元素，找到后返回被 `可选` 类型的 `有` 封装的元素，如果没发现目标，则返回 `无`（`None`）。

示例，继续上例当中的列表 `uu`，下面的代码用于查找用户名为 "bar" 的元素：

```js
let m = uu.find(do %.name === "bar")    # get `Some(User("foo", ...))`
let n = uu.find(do %.name === "John")   # get `None`
```

## 映射表

映射表（Map）是一系列 "键-值对" 数据。

映射表的字面量是：使用一对花括号包围所有数据，多个 "键-值对"（key-value pair） 之间使用逗号分隔，使用 "键名:值" 构建 "键-值对"。示例：

```js
{
    "东": 123,
    "西": 456
}
```

```js
{
    "foo": 123,
    "bar": 456
}
```

键支持大部分类型的数据，只要实现了 "可比较" 特性即可，值可以是任何类型的数据。当键为字符串类型时，键名的双引号可以省略，比如上面第一个映射表，可以简化为：

```js
{
    东: 123,
    西: 456
}
```

需注意一个映射表里的所有 "键-值对" 的数据类型必须一样，"键-值对" 实际上是一个含有两个成员的结构体，结构体定义如下：

```js
结构体 映射表元素<T,E>
    T 键
    E 值
以上
```

```js
struct MapElement<T,E>
    T key
    E value
end
```

结构体的第一个成员是 "键"，第二个成员是 "值"。上面示例的第一个映射表数据类型是 "映射表<字符串, 整数>", 第二个是 "映射表<字符串, 字符串>"。

XiaoXuan 运行环境默认使用二叉树（或者平衡树）来实现映射表。

### 访问映射表的元素

使用 `获取`（`get`）函数用于获取指定键的元素。

假设现有映射表 `a` 内容如下：

```js
让 a = {
    "东": 1,
    "西": 2,
    "南": 3,
    "北": 4
}
```

如果项获取键 "西" 的值，语句如下：

* `让 i = 获取 (a, "西")`
* `让 i = a.获取 ("西")`

* `let i = get (a, "西")`
* `let i = a.get ("西")`

函数返回 `可选<字符串>`（`Option<String>`） 数值，如果存在指定键对应的值，则数值为 `有(值)`，否则数值为 `无`。这个例子里，变量 i 的值为 `有(2)`。

#### 使用中括号获取指定键的值

除了使用 `获取` 函数，还可以使用一对中括号来获取指定键的值。示例：

* `让 i = a["西"]`
* `let i = a["西"]`

变量 i 的值跟使用 `获取` 函数的返回值一样。

#### 使用模式解构获取指定键的值

示例：

```js
# 同时获取键 "东" 和 "南" 的值，并赋值给变量 i 和 j。
让 {"东": i, "南": j} = a

# 同上，然后将剩余的 "键-值对" 存入变量 k，变量 k 将是一个映射表，
# 其内容为 `{"西": 2, "北": 4}`
让 {"东": i, "南": j, ...k} = a

# 当键的数据类型是字符串时，也可以省略双引号
让 {东: i, 南: j} = a

# 如果连变量 i, j 都省略，那么将会得到跟键名一样的变量
让 {东, 南} = a
```

### 添加新的 "键-值对"

使用 `添加`（`add`）函数向映射表添加新的 "键-值对"（"key-value pair"），函数返回值是 `结果<映射表>`。如果操作成功，则返回 `好(新映射表)`（`Ok(new_map)`），如果键名已经存在，则返回 `错误()`（`Err()`）。

示例：

```js
match a.add("中", 5)
    case Ok(m): writeLineFormat("new map: {:?}", m)
    case Err(): writeLine("error")
end
```

正如上面所说，"键-值对" 实际上是一个含有两个成员的结构体，所以也可以直接添加 "键-值对" 结构体：

```js
let e = new 映射表元素("中", 5)
a.add(e)
```

### 更新已存在的键值

使用 `更新`（`update`）函数向映射表更新已存在的键值，如果操作成功，则返回 `好(新映射表)`（`Ok(new_map)`），如果指定的键不存在，则返回 `错误()`（`Err()`）。

示例：

```js
match a.update("中", 2)
    case Ok(m): ...
    case Err(): ...
end
```

### 添加或更新 "键-值对"

可以使用 `设置`（`set`）函数添加或更新 "键-值对"，函数总是返回一个新的映射表。

示例：

```js
let b = a.set("中", 6)
```

也可以使用 "..." （三个点）代替 `设置` 函数，示例：

```js
let b = {"中": 6, ...a}
```

### 检查指定键是否存在

使用 `存在`（`exist`）函数可以检查是否存在指定的键，如果存在则返回 `真`（`true`），否则返回 `假`（`false`）。

### 删除 "键-值对"

使用 `删除`（`remove`） 或者 `尝试删除`（`tryRemove`） 函数可以 "删除" 映射表指定的 "键-值对"，返回值的类型是 `结果<映射表>`，成功则返回新映射表，如果指定键不存在则返回 `错误()`。

### 遍历映射表元素

使用 `项目组`（`items`） 函数可以获取映射表的所有项目，返回值是一个列表，列表的元素是 "键-值对"，即 `映射表元素<T,E>`。

示例：

```js
let items = a.items()
for item in items
    writeLine (item.key, item.value)
end
```

上面示例会遍历映射表 `a` 的所有元素。

除了 `项目组` 方法，还有 `键组`（`keys`） 和 `值组`（`values`）函数可以获取映射表的内容。

## 其他序列

除了 "单向链表" 的列表，还有其他类型的序列，它们一般具有跟列表的一致接口和访问，即都实现了 `序列`（`Sequence`）特性。比如可以使用 `let [a, ...b] = n` 获取第一个元素和其余元素，有些序列支持添加/累加元素操作，即也可以使用 `let n = [a,...b]` 添加元素。

所有序列都可以使用 `数据类型[]`（`DataType[]`） 这样的格式作表示其数据类型，比如：

`Int[] a = new List<Int>()`

包括下面会讲述的数列、数组，比如：

`Int[] b = [1..5]`
`Int[] c = ![1,2,3]`

实际上 `数据类型[]` 就是 `序列<数据类型>`（`Sequence<DataType>`） 的别名，不过一旦将具体的一个序列赋值给这种数据类型的变量或者参数之后，就丢失了具体类型的其他特性。`序列` 特性只有 `第一个`、`其余` 两个方法。

### 数列

`数列`（`NumberSequence`）指包含一系列等差的数字的列表。在中括号内使用**表示范围**的关键字 `..` （即两个点号，虽然都是符号，但它不是运算符）可以构建一个等差数列列表，比如：

`[1..10]`

将会生成一个含有从 "开始值" 整数 1 到 "结束值" 整数 10 的列表，即 `[1,2,3,4,5,6,7,8,9,10]`。

开始值和结束值和符号 `..` 之间的空格有无均可。

如果开始值和结束值一样，则会构建一个只有一个元素的数列。比如 `[10..10]` 实际上就是 `[10]`。

#### 等差数列

* `让 n = 新建 数列(1,10)`
* `let n = new NumberSequence(1,10)`

相邻元素间的差值（即步进值）默认是整数 `1`,如果想设置其他步进值，则除了 "开始值" 和 "结束值"，还需要额外提供第 2 个元素，则步进值将会是 "第 2 个元素 - 第 1 个元素（即开始值）"。

比如：

* `[1, 3, ..9]`
* `[10, 20, ..50]`

* `让 n = 新建 数列(1, 3, 9)`
* `let n = new NumberSequence(1,3, 9)`

分别生成列表 `[1,3,5,7,9]` 和 `[10,20,30,40,50]`，步进值分别是 `3-1=2` 和 `20-10=10`。

注意

* 第 2 个元素与第 1 个元素不能相同，否则会抛出运行时异常；
* 当存在第 2 个元素时，第 1 个和 第 2 个元素后面需要加上逗号；
* 当存在第 2 个元素时，结束值必须符合步进的结果，否则会抛出运行时异常，比如 `[1,3,..10]` 的结束值 `10` 不符合步进结果。

#### 动态指定开始值、结束值和步进值

开始值、结束值和步进值除了接受字面值，也可以是变量，比如

```js
let start = 10
let end = 14
let step = 2
let a = [start .. end]
let b = [start, step, .. end]
```

则 `a` 的结果是 `[10,11,12,13,14]`，`b` 的结果是 `[10,12,14]`。

#### 浮点数数列

如果想生成浮点数数列，则必须提供第 2 个元素以确定步进值，比如：

`[0.1, 0.2 .. 0.5]`

将会生成 `[0.1, 0.2, 0.3, 0.4, 0.5]`

#### 字符列表（::不支持）

字符数据类型存储的是 Unicode 字符，在运行时实际上是 `UInt32`，所以开始值、结束值、步进值也可以是字符。

示例：

`['a' .. 'f']`

将会生成字符列表 `['a','b','c','d','e']`。需要注意的是 Unicode 的码点（code point）并不是连续的，所以在生成字符列表时会自动跳过那些无效的 Unicode 字符。

#### 延迟执行

当 XiaoXuan 运行环境执行诸如 `[1 .. 2^63-1]` 语句时，不用担心机器的内存会被消耗光，因为当一个数列列表的元素比较多时，运行环境并不会立即产生这个数列，而是在真正需要时才产生并返回相应的数据。技术地说，这个数列跟普通数列有一样的访问接口，但实际上它只是一个函数。

#### 省略结束值

当省略结束值时，数列的结束值会被设定为起始值数据类型的最接近最大值的最后一个合法数字。不同类型数据的最大值是不相同的，比如对于默认的 `整数` 类型，其默认值为 2^63-1。

示例：

```js
让 a = [1, ..]
让 b = [1, 3, ..]
```

```js
let a = [1, ..]
let b = [1, 3, ..]
```

分别产生数列 `1, 2, 3, ...` 和 `1, 3, 5, 7, ...` 一直到 `Int64` 最后一个符合等差值的数字。

注意：

* 对于 `浮点数` 和 `字符` 类型，不允许省略结束值。
* 省略结束值并不是构建了一个无限数列，虽然数列的元素数量很大，不过仍然是有限的。

#### 省略开始值（::不支持）

当省略 "开始值" 时，则表示从整数 1 开始，示例：

```js
让 a = [.. 7]
让 b = [.. 5, 7]
```

```js
let a = [.. 7]
let b = [.. 5, 7]
```

上面两行分别产生 `[1, 2, 3, 4, 5, 6, 7]` 和 `[1, 3, 5, 7]` 两个数列。

需要注意：

* 不能同时省略开始值和结束值。
* 对于 `浮点数` 和 `字符` 类型，不允许省略开始值。

<!--
#### 无限数列

如果省略结束值，且步进值为 0，即第 1 和第 2 个元素的值相同，则会构建出一个无限数列。
-->

### 数列集

`数列集`（`NumberSet`）即包含一个或多个 `数列` 的集合。

示例：

```js
let n = [1..10, 50, 90..100]
```

显然往 `数列` 添加或追加元素，或者两个 `数列` 拼接（`++`）的结果就是一个 `数列集`；往 `数列集` 添加或追加元素，或者两个 `数列集` 拼接，结果仍然是一个 `数列集`。

上例的等同代码如下：

```js
let n = [1..10].append(50) ++  [90..100]
```

### 随机数列

`随机数列`（`RandomNumberList`）用于产生一系列随机数字。

示例：

```js
let r = new RandomNumberList<Int>(1, 100, 25)
```

上例将会产生一个含有 25 个随机整数的数列，其中随机数属于 1 到 100 闭区间。

下例演示计算 25 个随机数的标准差，已知标准差的公式是：

$$
\text{variance} = \frac{\sum_{i=1}^n(x_i - x_{avg})^2}{n}
$$

$$
\text{standard deviation} = \sqrt{\text{variance}}
$$

对应的代码是：

```js
let r = new RandomNumberList<Int>(25, 1, 100)
let sd = sqrt(sum((r - average(r)) ^ 2))
```

### 队列

`队列`（`Queue`）是一种 "先进先出（FIFO）" 的列表，如果程序需要不断累加数据到列表的末尾，则应考虑使用队列（因为在 "单向链表" 列表末尾添加元素的效率非常低）。

队列一般用于构建一些需要经常追加数据的场合，一旦追加完毕，再把它转换成普通列表。

#### 实例化队列

队列没有字面量，只能通过 `队列`（`Queue`） 函数实例化。

```js
让 q = 新建 队列<整数>()
让 q1 = 新建 队列<整数>(11)
让 q2 = 新建 队列<整数>([77,88,99])
```

#### 追加元素或列表

```js
让 q1 = q.追加 (11)
# q1 == 11

让 q2 = q1.追加 ([77,88,99])
# q2 == 11, 77, 88, 99
```

当然也能添加另一个队列：

```js
让 p = 队列<整数>()
让 p1 = p.追加 (11)
# p1 == 11

让 p2 = p1.追加 (q2)
# p2 == 11, 77, 88, 99
```

#### 删除元素

跟列表的情况类似，队列也是没有删除操作，或者说，获取部分元素就是相当于删除。但队列访问元素的方法很少，只支持 `第一个` 和 `其余` 两个函数。

#### 转换为普通列表

使用队列的 `转为列表`（`toList`） 函数即可将队列转成列表。

### 集合

`集合`（`Set`）跟列表类似，但它不允许有重复的数据。集合可以理解为只有 "键" 而没有 "值" 的映射表。

集合没有字面量表示方法，可以使用构造函数构建：

```js
让 s1 = 新建 集合([1,2,2,3])
让 s2 = 新建 集合(["abc", "xyz", "abc", "abc"])
```

```js
let s1 = new Set([1,2,2,3])
let s2 = new Set(["abc", "xyz", "abc", "abc"])
```

上例中重复的数据将会被剔除，最后 `s1` 的值为 `!{1,2,3}`，`s2` 的值为 `!{"abc", "xyz"}`。

从集合读取元素的效率很低，通常运行环境使用二叉树（或者平衡树）实现数据表，在读取或者遍历集合的时候，会被先转换成普通列表然后再返回调用者，所以一般使用集合是需要排除重复数据的 "多次写入，一次读取" 的场合。

### 数组

类型名称是 `数组`（`Array`）。数组的字面量跟列表类似，不过需要在第一个中括号之前添加一个感叹号，也就是 `![...]`。

示例：

```js
let a1 = ![1,2,3,4,5]
```

跟 "单向链表" 的列表不同：

* 数组使用连续的内存储存数据，所以如果需要批量处理数据，使用数组的运行效率要高一些（数据缓存命中率也较高）；
* 通过索引（下标）访问数组元素能在常数时间内完成，效率很高；
* 对数组的任何 "更改" 操作都是整体数据复制的，效率很低。所以数组不适合增删改的场合，也就是说，数组只适合构建一次，然后只读的场合。

使用构造函数也能构建数组，示例：

* 让 a1 = 新建 数组([1,2,3,4,5])
* let a1 = new Array([1,2,3,4,5])

#### 字符数组

`字符串`（`String`）实际上是字符数组，即 `数组<字符>`（`Array<Char>`）的别称，所以字符串的拼接效率很低，如果需要多次拼接/累加字符串，最好使用列表或者队列实现中间的过程，全部完成后再转换为字符串。

因为字符串是字符数组，所以对字符串的索引访问能在常数时间内完成。

XiaoXuan 为字符串添加了一些额外的函数，比如转换大小写等。

#### 多维数组

数组里面可以存放任何类型的数据，自然也能再放入一组数组。当一个数组里直接包含一层或多层数组时，则称为`多维数组`（`NDArray`，Multi-Dimensional Array，N-Dimensional Array）。

示例，下面使用字面量构建二维数组：

```js
let nd1 = ![
    ![1,2,3],
    ![4,5,6]
]
```

注意多维数组字面量里面的子数组也需要使用 `![...]` 符号包围，而不能使用 `[...]` 符号，因为这个符号表示列表而不是数组。当 XiaoXiao 运行时遇到这种结构的字面量时，会自动生成 `多维数组` 实例，而不是嵌套的数组。

跟列表一样，可以使用 `[n]` 符号访问第 N 个元素的值。示例：

```js
let n1 = nd1[1]
```

将会返回 `![1,2,3]`，如果想访问子数组的元素，可以累加中括号，比如：

`let m = [n][m]`

不过也可以简写为：

`let m = [n, m]`

使用构造函数构建：

```js
let nd = new NDArray<Int>(2, [2,3])
let nd1 = nd.build(![
    ![1,2,3],
    ![4,5,6]
])
```

构造函数第一个参数表示维度，第二个参数表示各个维度的大小。

构造函数还可以接受第三个参数，表示多维数组元素的初始值，比如：

```js
let nd2 = new NDArray<Float>(2, [10,10], 0.1)
```

将会构建一个由 "0.1" 组成的 10x10 二维数组。如果省略第三个参数，则初始值为该数组数据类型的默认值（比如整数的默认值为 0）。

XiaoXuan 还提供创建随机数多维数组的静态方法 `random`，详细见语言文档。

使用 `头`（`first`）函数将会获取多维数组最外一维的第一个元素，示例：

```js
let n1 = first(nd1) # n1 == ![1,2,3]
```

下例是一个 3 维数组：

设有一张 RGB 图片，像素是 2 x 2 pixel，像素的顺序是从左到右，从上往下，4 个点的颜色分别是 "橙-青-紫-绿"。

<svg width="40px" height="40px">
  <rect x="0" y="0" width="10" height="10" fill="rgb(240,160,30)" />
  <rect x="10" y="0" width="10" height="10" fill="rgb(30,240,240)" />
  <rect x="0" y="10" width="10" height="10" fill="rgb(240,30,240)" />
  <rect x="10" y="10" width="10" height="10" fill="rgb(160,240,30)" />
</svg>

将每一种颜色分量作为第 1 维，将 x, y 坐标（即行，列坐标）作为第 2 维和第 3 维，点上的颜色分量值（0～255）作为数组元素的值，则该图片的数据大致如下：

```js
let rgb = ![
    ![              # 红色（R）分量
        ![240, 30], # 第一行的两个像素点的红色（R）分量
        ![240, 160] # 第二行的两个像素点的红色（R）分量
    ],
    ![              # 绿色（G）分量
        ![160, 240],
        ![30, 240]
    ],
    ![              # 蓝色（B）分量
        ![30, 240],
        ![240, 30]
    ]
]
```

其 3 维图示大致如下：

```ascii
 +------------------------> X
 |  +------------+ R
 |  |            |
 |  |  +------------+ G
 |  |  |            |
 |  |  |  +------------+ B
 |  |  |  |            |
 |  +--|  |  30  , 240 |
 |     |  |            |
 |     +--|  240 , 30  |
 |        |            |
 |        +------------+
 V Y
```

XiaoXuan 为多维数组提供了一些函数，比如使用 `维度切片`（`dim_slice`） 函数可以获取指定维度的数据，比如：

`let r = dim_slice(rgb, 2, 2)`

表示获取第 1 维值为 2 的切片，结果返回蓝色分量的切片，返回的是一个二维数组：

```js
# 蓝色（B）分量
![
    ![30, 240],
    ![240, 30]
]
```

又比如：

`let rgbOnX = rgb.dim_slice(2, 1)`

表示获取第 2 维值为 1 的切片，结果返回的是第 1 行所有列的 rgb 分量。

还可以使用 `形状`（`shape`）获取多维数组的大小，比如：

`let s = rgb.shape()`

返回 `(3, [3,2,2])` 表示这是一个 3 维数组，各个维度的大小是 "3,2,2"。

### 矩阵

`矩阵`（`Matrix`）是由 m 行（row）n列（column）元素排列成的矩形阵列。矩阵是二维数组的别称，比如 `Matrix<Int>` 实际上是 `Array<Array<Int>>` 。

矩阵的字面量除了可以使用标准的二维数组表示方法，还能使用简化的格式：使用 `![...]` 符号包围数据，行与行之间的数据使用分号 `;` 分隔。

示例：

```js
let m1 = ![
    1,2,3;
    4,5,6;
    7,8,9]
```

它跟下面的二维数组的字面量是等效的：

```js
let m1 = ![
    ![1,2,3],
    ![4,5,6],
    ![7,8,9]
]
```

显然简化版的表示方法要简单一些。它们构建的矩阵如下：

$$
    \begin{bmatrix}
    a_{11} & a_{12} & \cdots & a_{1n} \\
    a_{21} & a_{22} & \cdots & a_{2n} \\
    \vdots & \vdots & \ddots & \vdots \\
    a_{m1} & a_{m2} & \cdots& a_{mn} \\
    \end{bmatrix}
$$

跟访问二维数组的方法一样，也可以使用中括号访问矩阵的元素，比如第 1 行第 2 列（即 m=1, n=2）的元素，语句如下：

```js
让 c1 = m1[1][2]  # c == 2
让 c2 = m1[1,2]   # c == 2
```

```js
let c1 = m1[1][2]  # c == 2
let c2 = m1[1,2]   # c == 2
```

矩阵也可以通过构造函数构建。

示例：

```js
let m = new Matrix([
    ![1,2,3],
    ![4,5,6],
    ![7,8,9],
])
```

XiaoXuan 为 `Matrix<Int>` 重载了矩阵的乘法运算，`矩阵 a * 矩阵 b` 的结果是：

$$
c(i,j) = \sum_{k=1}^{n}{a(i,k)b(k,j)}
$$

即线性代数的矩阵乘法（矩阵 a 的行数必须等于 b 的列数）。而一维数组乘（即点乘 `.*`）仍然是逐个元素相乘（两个矩阵的结构必须相同，或者其中一个是标量实现的广播乘法）。

XiaoXuan 还提供诸如 `获取列`（`getColumn`） 函数，用来获取指定的一列数据；提供创建随机数矩阵的静态方法 `random`，详细见语言文档。

矩阵的构造函数也可以生成一个所有元素的值都一样的指定大小的矩阵，示例：

```js
let m = new Matrix(2,3,0.1)
```

上面语句将产生一个 2 行 3 列，所有元素的值均为 0.1 的矩阵。

### 重复序列

重复序列是指将一个序列复制多遍，然后形成值重复的序列。在被复制的序列使用**表示复制**的关键字 `**` 可以复制一个列表。

示例：

```js
let a = [1] ** 4
let b = [0.0] ** 4
let c = ['a'] ** 3
let d = [true] ** 3
let e = ["foo"] ** 3
```

结果生成如下等效数列：

* `[1, 1, 1, 1]`
* `[0.0, 0.0, 0.0, 0.0]`
* `['a', 'a', 'a']`
* `[true, true, true]`
* `["foo", "foo", "foo"]`

符号 `**` 后面的数字表示复制的次数，为了跟乘法一致，规定复制 1 次表示得出原先的列表。

符号 `**` 对应的函数是 `重复`（`duplicate`）函数：

* `让 a = 重复<Int>(1, 4)`
* `let a = duplicate<Int>(1, 4)`

#### 重复多元素的序列

被重复的序列可以有多个元素。

示例：

```js
let a = [0, 1] ** 2
let b = [false, true] ** 2
let c = ['a','b','c'] ** 2
```

结果生成如下等效数列：

* `[0, 1, 0, 1]`
* `[false, true, false, true]`
* `['a', 'b', 'c', 'a', 'b', 'c']`

或者通过 `repeat_list` 函数构建：

`let a = repeat_list<Int>([0, 1], 2)`

#### 重复字符串

字符串类型 `String` 实际上是 `Array<Char>`，所以字符串也是可以重复的。

示例：

"abc" 的实际值是 `!['a', 'b', 'c']`，当使用 `**` 复制这个数组时，比如复制 2 次，结果值为 `!['a', 'b', 'c', 'a', 'b', 'c']`，恰好就是 "abcabc"。所以 `**` 运算符号同样可以直接用于重复字符串。

示例：

`let s = "abc" ** 2`

变量 `s` 的值为 "abcabcabc"。

#### 延迟执行

跟等差数列一样，重复列表也是延迟执行的。

### 表格

`表格`（`Table`）是一个由标头、行、列组成的数据。同一列的数据类型必须相同，标头就是列的名称。一行数据由各列数据在同一行的数据组成。表格在概念上跟电子表格（spreadsheet）是一样的。

构造一个表格之前先需要定义一个结构体，一行数据就是一个结构体的实例，标头就是结构体各成员的名称。

示例，下面构建一个 `用户`（`User`） 结构体：

```js
结构体 用户
    整数 编号
    字符串 姓名
    逻辑 检查
以上
```

```js
struct User
    Int id
    String name
    Boolean checked
end
```

然后使用 `表格` 构造函数构建表格：

```js
let t1 = new Table<User>([
    User(1, "foo", true),
    User(2, "bar", false)
])
```

XiaoXuan 提供了一个字面量语法糖构建结构体，上例的表格可以使用下面的字面量来构建：

```js
let t1 = ![
    User(Int id, String name, Boolean checked);
    1, "foo", true;
    2, "bar", false
]
```

如果提供的数据是基本的数据类型，也可以省略第一行结构体当中的成员数据类型，示例：

```js
let t1 = ![
    User(id, name, checked);
    1, "foo", true;
    2, "bar", false
]
```

上例所构建的表格如下：

| id | name | checked |
|----|------|---------|
| 1  | foo  | true    |
| 2  | bar  | false   |

使用 `标头`（`header`）函数可以获取表格的结构体类型，使用 `标头标题`（`headerTitles`）可以获取由标头组成的字符串列表，比如 `["id", "name", "checked"]`。

表格也是一种序列，可以视为元素为一个结构体的队列，即上例 `Table<User>` 大致相当于队列 `Queue<User>`。所以同一般序列一样，使用 `获取`（`get`）函数可以获取指定行的数据，返回的是一个结构体。

示例：

```js
let i = t1.get(2)
```

则 `i` 的值是 `User(id=2, name="bar", checked=false)`。

跟元素类型为一个结构体的队列（如 `Queue<User>`）不同，`表格` 数据类型提供了很多跟表格处理相关的函数，比如排序、筛选等。

## 几种序列的使用场景

下面比较列表、队列、数集、数组这几种序列：

* 列表

  列表可作为一般用途的数据集合。一般用于需要增加、拼接、删除、拆解元素等场合。不适合（在尾部）累加元素，也不适合按索引访问元素。

* 数组

  数组适合需要经常批量访问数据（即一次访问多个数据）的场合，适合按索引访问元素，适合 "一次构建、多次读取"。数组不适合需要增加、拼接、删除、拆解元素等场合。

* 队列

  队列适合（在尾部）累加元素，比如构建字符串、表格等，适合 "多次写入，多次读取"。

* 数集

  数集适合用于排除重复数据，适合 "多次写入，一次读取"，适合一边写入一边排序。不适合频繁读取数据。
