# 集合

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [集合](#集合)
  - [列表](#列表)
    - [构建数列列表](#构建数列列表)
      - [动态指定开始值、结束值和步进值](#动态指定开始值-结束值和步进值)
      - [浮点数数列](#浮点数数列)
      - [字符列表](#字符列表)
      - [延迟执行（::不支持）](#延迟执行不支持)
      - [省略开始值或结束值（::不支持）](#省略开始值或结束值不支持)
    - [无穷列表（::不支持）](#无穷列表不支持)
    - [增加列表的元素](#增加列表的元素)
    - [拼接列表](#拼接列表)
    - [获取列表的大小](#获取列表的大小)
    - [访问列表的元素](#访问列表的元素)
      - [`第一个`（`head`）函数](#第一个head函数)
      - [`尾部`（`tail`）函数](#尾部tail函数)
      - [`头部`（`init`）函数](#头部init函数)
      - [`最后一个`（`last`）函数](#最后一个last函数)
      - [`获取`（`get`）函数](#获取get函数)
      - [使用中括号获取指定位置的元素](#使用中括号获取指定位置的元素)
      - [`选取`（`slice`） 函数](#选取slice-函数)
      - [使用中括号选取指定范围的元素](#使用中括号选取指定范围的元素)
        - [省略 "元素个数"](#省略-元素个数)
        - [省略 "开始位置"](#省略-开始位置)
    - [使用模式解构访问列表的元素](#使用模式解构访问列表的元素)
    - [删除元素](#删除元素)
      - [`删除`（`remove`）函数](#删除remove函数)
    - [切分列表](#切分列表)
    - [分隔列表](#分隔列表)
    - [插入元素或列表](#插入元素或列表)
    - [追加元素或列表（::不支持）](#追加元素或列表不支持)
    - [替换元素或列表](#替换元素或列表)
    - [查找元素或（子）列表的出现位置](#查找元素或子列表的出现位置)
    - [查找元素](#查找元素)
  - [队列](#队列)
    - [实例化队列](#实例化队列)
    - [追加元素或列表](#追加元素或列表)
    - [删除元素](#删除元素-1)
    - [转换为普通列表](#转换为普通列表)
  - [映射表](#映射表)
    - [访问映射表的元素](#访问映射表的元素)
      - [使用中括号获取指定键的值](#使用中括号获取指定键的值)
      - [使用模式解构获取指定键的值](#使用模式解构获取指定键的值)
    - [添加新的 "键-值对"](#添加新的-键-值对)
    - [更新已存在的键值](#更新已存在的键值)
    - [添加或更新 "键-值对"](#添加或更新-键-值对)
    - [检查指定键是否存在](#检查指定键是否存在)
    - [删除 "键-值对"](#删除-键-值对)

<!-- /code_chunk_output -->

## 列表

列表（List）是一系列数据类型相同的数据。

列表字面量的格式是：使用一对中括号包围所有数据，数据（称为 "元素"）之间使用逗号分隔。

示例：

```js
让 a = [1, 2, 3]
让 b = [3.14, 2.718, 0.618]
让 c = ["天地玄黄", "宇宙洪荒", "日月盈昃", "辰宿列张"]
让 d = [真, 假, 假, 真]
```

```js
let a = [1, 2, 3]
let b = [3.14, 2.718, 0.618]
let c = ["twinkle", "twinkle", "little", "star"]
let d = [true, false, false, true]
```

上面的语句分别构建了四个列表：

* `列表<整数>`（`List<Int>`）
* `列表<浮点数>`（`List<Float>`）
* `列表<字符串>`（`List<String>`）
* `列表<逻辑>`（`List<Boolean>`）

一个列表里不能同时存在不同类型的元素，比如下列的语句是错误的：

```js
让 a = [100, 200, 2.9979e8, 6.67e-11] // 前两个元素是整数型，后两个是浮点型。
让 b = ["寒来暑往", 真, "秋收冬藏"] // 前后两个是字符串型，中间是逻辑型。
```

```js
let a = [100, 200, 2.9979e8, 6.67e-11] // there are both Int and Float
let b = ["hickory", true, "dickory"] // there are both String and Boolean
```

### 构建数列列表

在中括号内使用**范围**关键字 `..` （即两个点号，虽然都是符号，但它不是运算符）可以构建一个数列，比如：

`[1..10]`

将会生成一个含有从 "开始值" 整数 1 到 "结束值" 整数 10 的列表，即 `[1,2,3,4,5,6,7,8,9,10]`。

开始值和结束值和符号 `..` 之间的空格有无均可。

默认的步进值是整数 `1`,如果想设置其他步进值，则除了 "开始值" 和 "结束值"，还需要额外提供第 2 个元素，步进值将会是 (第 2 个元素 - 开始值)。比如：

* `[1, 3..10]`
* `[10,20..50]`

分别生成列表 `[1,3,5,7,9]` 和 `[10,20,30,40,50]`，步进值分别是 `3-1=2` 和 `20-10=10`。

#### 动态指定开始值、结束值和步进值

开始值、结束值和步进值除了接受字面值，也可以是变量，比如

```js
let start = 10
let end = 15
let a = [start..end]
```

将会生成 `[10,11,12,13,14,15]`。

#### 浮点数数列

如果想生成浮点数数列，则必须提供第 2 个元素以确定步进值，比如：

`[0.1, 0.2 .. 0.5]`

将会生成 `[0.1, 0.2, 0.3, 0.4, 0.5]`

#### 字符列表

字符数据类型存储的是 Unicode 字符，在运行时实际上是 `UInt32`，所以开始值、结束值、步进值也可以是字符。

示例：

`['a' .. 'f']`

将会生成字符列表 `['a','b','c','d','e']`。需要注意的是 Unicode 的码点（code point）并不是连续的，所以在生成字符列表时会自动跳过那些无效的 Unicode 字符。

#### 延迟执行（::不支持）

当 XiaoXuan 运行环境执行诸如 `[1 .. 10^19]` 语句时，不用担心机器的内存会被消耗光，因为当一个数列列表的元素比较多时，运行环境并不会立即产生这个数列，而是在真正需要时才产生并返回相应的数据。技术地说，这个数列跟普通数列有一样的访问接口，但实际上它只是一个函数。

#### 省略开始值或结束值（::不支持）

当省略结束值时，数列的结束值会被设定为起始值数据类型的最大值，比如对于默认的 `整数` 类型，其默认值为 2^63-1。对于 `字符` 类型，最大值则是 Unicode 的最后一个码点（code point）。示例：

* `让 a = [1, 3 ..]`
* `let a = [1, 3 ..]`

会产生数列 `1, 3, 5, 7 ...` 一直到 `Int64` 最后一个数字。

当省略 "开始值" 时，则表示从整数 1 或者浮点数 1.0 或者字符 '\1' 开始，到 "结束值" 为止，示例：

```js
让 a = [.. 7]
让 b = [.. 5, 7]
```

```js
let a = [.. 7]
let b = [.. 5, 7]
```

上面两行分别产生 `[1, 2, 3, 4, 5, 6, 7]` 和 `[1, 3, 5, 7]` 两个数列。

需要注意的是不能同时省略开始值和结束值。

### 无穷列表（::不支持）

并不是所有列表都是由真实的一列数据组成的，比如上面提到的数列列表，有些列表实际上是一些延迟执行的函数，因此也存在一些有无穷个元素的列表，后面的 "I/O" 章节会讲到。

### 增加列表的元素

XiaoXuan 的所有类型的数据都不支持更改，自然无法对一个列表增加、修改或者删除元素。所有对列表更改的操作的方法（函数）都会产生一个新的列表。

为了提高效率，对于一般的列表，XiaoXuan 运行环境内部默认采用单向链表来实现（需注意在不同的情况下具体的列表实现方式也会有所相同，并非总是使用单向链表），在单向链表的头部（最新元素的那端）添加元素能在常数时间内完成，所以如果要增加列表元素，一般都是往列表的头部添加。相反，往列表末尾添加元素的效率则非常低（因为要重新构建一次列表）。

在实际应用中，XiaoXuan 的列表与数据结构中的 "栈（Stack）" 比较相似，元素的操作遵循 "先进后出（FILO）" 原则。

XiaoXuan 使用一对中括号和**展开**关键字 "..."（即三个点号，虽然都是符号，但它不是运算符）的格式实现往列表头部添加一个元素。示例：

假设有列表 `a`：

* `让 a = [1, 2, 3]`
* `let a = [1, 2, 3]`

现在需要添加整数 `88` 到列表头部，则语句如下：

* `让 b = [88, ...a]`
* `let b = [88, ...a]`

将会得到一个新的列表 `b`，其值为 `[88, 1, 2, 3]`。

也可以一次添加多个元素，比如：

* `让 c = [77, 88, 99, ...a]`
* `let c = [77, 88, 99, ...a]`

将会得到一个新的列表 `b`，其值为 `[77, 88, 99, 1, 2, 3]`。

需注意:

* 新添加的元素总是出现在列表的头部，而不像一般语言常见的数组或集合那样————添加到列表的尾部。
* 关键字 `...` 只能出现在中括号的末尾，语句 `[...a, 4, 5]` 会引起运行时错误（语法错误）。

XiaoXuan 提供 `添加`（`add`）函数用于实现以上的操作，示例：

```js
让 b = 添加 (a, 8)
让 b = a.添加(8)
让 c = 添加 (a, [77,88,99])
让 c = a.添加([77,88,99])
```

```js
let b = add (a, 8)
let b = a.add(8)
let c = add (a, [77,88,99])
let c = a.add([77,88,99])
```

### 拼接列表

使用 `拼接`（`concat`）函数（符号为 `++`）可以将两个列表拼接起来，并返回一个拼接后的新列表。

假设有两个列表 `[1,2,3]` 和 `[7,8,9]`，则：

* `让 a = [1,2,3] ++ [7,8,9]`
* `let a = [1,2,3] ++ [7,8,9]`

将会得到一个新的列表 `[1,2,3,7,8,9]`。

需注意：

* 待拼接的列表的数据类型必须相同；
* 拼接操作是从右到左结合，如 `[1,2] ++ [5,6] ++ [8,9]` 先拼接后两个列表得 `[5,6,8,9]` 然后再拼接第一个列表；
* 因为字符串实际上是 `列表<字符>`（`List<Char>`） 数据类型，所以字符串的拼接也是使用 `++` 函数，比如： `"hello" ++ " " ++ "world"` 得到 `"hello world"`。

### 获取列表的大小

使用 `长度`（`length`）函数可以获取列表的大小，示例：

```js
让 i = 长度 (a)
让 i = a.长度()
```

```js
let i = length (a)
let i = a.length()
```

### 访问列表的元素

下面通过例子说明如何读取列表的元素。

现假设有列表 `a` 其内容为 `[1, 2, 3, 4, 5]`：

#### `第一个`（`head`）函数

使用 `第一个` 函数可获取第一个元素

```js
让 i = 第一个 (a)
让 i = a.第一个()
```

```js
let i = head (a)
let i = a.head()
```

变量 `i` 的值将会是 `1`。

#### `尾部`（`tail`）函数

使用 `尾部` 函数可获取除第一个元素之外，由剩余元素组成的一个新列表。

```js
让 i = 尾部 (a)
让 i = a.尾部()
```

```js
let i = tail (a)
let i = a.tail()
```

变量 `i` 的值将会是 `[2, 3, 4, 5]`。

#### `头部`（`init`）函数

使用 `头部` 函数获取除了最后一个元素之外，由其他元素组成的一个新列表。

```js
让 i = 头部 (a)
让 i = a.头部()
```

```js
let i = init (a)
let i = a.init()
```

变量 `i` 的值将会是 `[1, 2, 3, 4]`。

#### `最后一个`（`last`）函数

使用 `最后一个` 函数获取列表的最后一个元素。

```js
让 i = 最后一个 (a)
让 i = a.最后一个()
```

```js
let i = last (a)
let i = a.last()
```

变量 `i` 的值将会是 `5`。

#### `获取`（`get`）函数

使用 `获取` 函数可获取指定位置的元素。`获取` 函数的签名是：

* `获取 (列表实例, position)`
* `get (listInstance, position)`

```js
让 i = 获取 (a, 2)
让 i = a.获取(2)
```

```js
let i = get (a, 2)
let i = a.get(2)
```

变量 `i` 的值将会是 `2`。上例当中函数参数 `2` 表示待获取的元素的位置，需注意：

* XiaoXuan 的列表位置值从数字 1 开始，而不是从 0 开始（很多语言的数组/列表索引值/下标是从 0 开始的）；
* 位置值允许的最大值为列表的长度，也就是说，位置值的有效范围是从 "0" 到 "列表的长度"；
* 位置值不能超出列表的范围，即小于 1 或者大于列表长度，否则都会引起运行时错误。
* 如果列表的具体实现是一个单向链表，则按位置来访问元素的效率比较低，它需要逐个元素遍历直到指定的位置为止，虽然有些列表的实现可能会针对按位置访问做了一些优化，但习惯上我们应该尽量避免高频次使用位置值来访问列表。

#### 使用中括号获取指定位置的元素

使用中括号可以实现 `获取` 函数一样的功能。

示例：

* `让 i = a[2]`
* `let i = a[2]`

中括号里面写上需要获取的元素的位置，其作用与调用函数 `获取 (a, 2)` 一样。

#### `选取`（`slice`） 函数

使用 `选取` 函数可以选取指定范围的元素，并返回一个新列表。函数的签名是：

* `选取 (列表实例, 开始位置, 元素个数)`
* `slice (listInstance, startPosition, count)`

`选取` 函数各参数的含义：

* 第 1 个参数为源列表。
* 第 2 个参数表示选取范围的开始位置，取值范围从 1 到 "列表的长度 + 1"，选取的结果包括开始位置的元素；
* 第 3 个参数表示选取元素的个数，取值范围从 0 到 "列表长度 - 开始位置 + 1"。比如假设一个列表有 10 个元素，开始位置值为 `2`，则有效的选取元素个数为 `0` 到 `9`。

需注意：

* 如果 "元素个数" 参数传入 `0`，则会返回一个空列表 `[]`；
* 如果 "开始位置" 参数传入 "列表的长度 + 1"，表示从列表最后一个元素的后面开始选取，显然此时能选取的元素个数只能为 "0"，所以函数的返回值会是一个空列表 `[]`；
* "开始位置" 以及 "元素个数" 都不能超出列表的范围，否则都会引起运行时异常。

示例：

```js
让 b1 = 选取 (a, 2, 3)
让 b2 = a.选取 (2, 3)
```

```js
let b1 = slice (a, 2, 3)
let b2 = a.slice (2, 3)
```

上面示例表示从列表 `a` 的第 2 个元素开始（包括第 2 个元素），选取 3 个元素，因此变量 `b` 的值将会是 `[2, 3, 4]`。

第三个参数也可以省略，表示选取从 "开始位置" 到列表的最后一个元素，示例：

* `让 c = 选取 (a, 4)`
* `let c = slice (a, 4)`

变量 `c` 的值将会是 `[4, 5]`。

#### 使用中括号选取指定范围的元素

使用中括号还能实现跟 `选取` 函数一样的功能，语法是：

* `列表实例[开始位置:元素个数]`
* `listInstance[startPosition:count]`

示例：

* `让 b = a[2:3]`
* `let b = a[2:3]`

上面示例表示从列表 `a` 的第 2 个元素开始（包括第 2 个元素），选取 3 个元素，因此变量 `b` 的值将会是 `[2, 3, 4]`。

##### 省略 "元素个数"

如果省略 "元素个数"，表示选取从 "开始位置" 到列表的最后一个元素，示例：

* `让 c = a[4:]`
* `let c = a[4:]`

变量 `c` 的值将会是 `[4, 5]`。

##### 省略 "开始位置"

如果省略 "开始位置"，则表示选取列表最后指定个数的元素。

示例：

* `让 b = a[:3]`
* `let b = a[:3]`

上面示例表示选取列表 `a` 的最后 3 个元素，所以变量 `b` 的值将会是 `[3, 4, 5]`。

### 使用模式解构访问列表的元素

使用模式解构来获取列表的元素比使用函数的更加简单直观，示例：

```js
让 a = [1,2,3,4,5]

// 获取第 1 个元素并赋值给变量 i，此时 i == 1
让 [i] = a

// 获取第 1 和第 2 个元素分别赋值给变量 i 和变量 j，此时 i == 1, j == 2
让 [i, j] = a

// 获取第 1 和第 2 个元素，第 1 个元素的值丢弃，第 2 个元素的值赋值给 i，此时 i = 2
让 [_, i] = a

// 获取第 1 个以及剩余的元素，第 1 个元素赋值给变量 i，
// 剩余的元素（是一个列表）赋值给变量 j，此时变量 j == [2, 3, 4, 5]。
让 [i, ...j] = a

// 获取第 1 和第 2 个以及剩余的元素，前两个元素分别赋值给变量 i 和 j，
// 剩余的元素（是一个列表）赋值给变量 k，此时变量 k == [3, 4, 5]
让 [i, j, ...k] = a
```

需注意的是**剩余**关键字 `...` （即三个点，同 "展开" 关键字）只能出现在中括号的末尾，诸如 `let [i, ...j, k]` 的语句会引起运行时异常（语法错误）。

### 删除元素

因为值不可变性，实际上不存在删除元素的方法。如果确实要完成 "删除" 元素之目的，只需转换成 "获取" 部分元素的操作即可。

示例：

```js
// 目的：删除列表的第 1 个元素
// 方法：获取除了第 1 个元素之外的剩余元素
让 b = a.尾部()
让 [_, ...b] = a

// 目的：删除列表的前 2 个元素
// 方法：调用 `选取` 函数
让 c = a.选取 (2+1)
让 c = a[2+1:]

// 目的：删除列表的前 N 个元素（0 <= N <= 列表长度）
// 方法：获取从位置 N+1 开始往后的所有元素
让 d = a.选取 (N+1)
让 d = a[N+1:]

// 目的：删除列表的后 N 个元素（0 <= N <= 列表长度）
// 方法：获取从位置 1 开始，获取 "总个数 - N" 个元素
让 e = a.选取[1 : a.长度() - N]
让 e = a[1 : a.长度() - N]
```

```js
// expected: delete the first element of the list
// solution: get the remaining elements except for the 1st element
let b = a.tail()
let [_, ...b] = a

// expected: delete the first two elements of the list
// solution: call the `slice` function
let c = a.slice(2+1)
let c = a[2+1]

// expected: delete the first N elements of the list (0 <= N <= list length)
// solution: get all elements from position N+1
let d = a.slice(N+1)
let d = a[N+1:]

// expected: delete the last N elements of the list (0 <= N <= list length)
// solution: get the elements start from position 1, count "Total - N".
let e = a.slice(1, a.length() - N)
let e = a[1 : a.length() - N]
```

#### `删除`（`remove`）函数

使用 `删除` 函数可以简化 "删除" 中间某个范围元素的操作，需注意的时，`删除` 函数并不会真的删除源列表，而是返回一个删除了指定范围元素的新列表。

`删除` 函数的签名是：

* `删除 (列表实例, 开始位置, 元素个数)`
* `remove (listInstance, startPosition, count)`

函数的参数含义跟 `选取` 函数的一样。

示例：

```js
让 a = [1,2,3,4,5]
让 e = a.删除(2, 3)
```

```js
let a = [1,2,3,4,5]
let e = a.remove(2, 3)
```

上面示例表示从列表 `a` 的第 2 个元素开始，共删除 3 个元素，变量 `e` 的值将会是 `[1, 5]`。

### 切分列表

使用 `切分`（`part`）函数可以在指定位置将一个列表切分为两个列表。

`切分` 函数的签名是：

* `切分 (列表实例, 开始位置)`
* `part (listInstance, startPosition)`

示例：

* `让 (x, y) = a.切分(3)`
* `let (x, y) = a.part(3)`

`切分` 函数返回一个元组，元组有两个成员，分别是切分而得的前后两个列表。其中参数表示切分的开始位置（假设为 N），从位置 1 到从位置 N-1 的元素形成第一个列表。从位置 N （包括 N 元素）到最后一个元素形成第二个列表。所以上面的示例将会得到：

```js
(
    [1, 2],
    [3, 4, 5]
)
```

跟 `选取` 函数类似，"开始位置" 的取值范围从 1 开始到 "列表长度 + 1"。

* 如果 "开始位置" 值为 1，则返回一个空列表和一个跟源列表一样的列表，即 `[]` 和 `[1,2,3,4,5]`；
* 如果 "开始位置" 值为 "列表长度 + 1"，则返回一个跟源列表一样的列表和一个空列表，即 `[1,2,3,4,5]` 和 `[]`。

如果 "开始位置" 值超出允许范围，则会引出运行时异常。

### 分隔列表

使用 `分隔`（`split`）函数可以将一个列表根据指定的值分隔为若干份，示例：

* `让 s = [1,2,0,3,0,4,5,6].分隔(0)`
* `let s = [1,2,0,3,0,4,5,6].split(0)`

则 `s` 的值为：

```js
[
    [1, 2],
    [3],
    [4, 5, 6]
]
```

* 如果找不到指定的值，则返回仅有一个元素的列表，该元素的值跟原列表一样；
* 如果指定的值出现在第一个元素，则返回的列表的第一个元素是空列表；
* 如果指定的值出现在最后一个元素，则返回的列表的最后一个元素是空列表。

考虑如下的一种情况：

```js
让 a = [0, 0]
让 s = a.分隔(0)
```

此时变量 `s` 的值将会是一个 3 个空列表的列表 `[[],[],[]]`。

`分隔` 函数也支持传入一个列表，表示根据这个子列表的值分隔源列表，示例：

```js
让 a = "123abc456abc789"
让 s = a.分隔("abc")
```

因为字符串实质是字符列表，所以上面的语句是可运行的，其表示按照子字符串 "abc" 对源字符串进行分隔，变量 `s` 的值将会是：

```js
["123", "456", "789"]
```

### 插入元素或列表

插入元素可以由 "切分列表" 和 "拼接列表" 两个操作完成，为了简化操作，XiaoXuan 提供了 `插入`（`insert`） 函数。

`插入` 函数的签名是：

* `插入 (列表实例, 开始位置, 新元素)`
* `insert (listInstance, startPosition, newElement)`

参数 "开始位置" 的有效取值范围是从 "1" 到 "列表的长度 + 1"，表示插入的位置（即把新元素放到该位置之前，即插队）。

示例，假设有列表 `[1,2,3,4,5]`，现分别有新元素 `99` 和新列表 `[77,88,99]` 准备插入到位置 N，假设 N = 3，代码如下：

```js
让 N = 3

让 (x, y) = a.切分(N)
让 aa = x ++ [99, ...y]
让 ab = x ++ [77,88,99] ++ y

// 使用 `插入` 函数
让 aa = a.插入(N, 99)
让 ab = a.插入(N, [77,88,99])
```

```js
let N = 3
let (x, y) = a.part(N)
let aa = x ++ [99, ...y]
let ab = x ++ [77,88,99] ++ y

// by using `insert` function
let aa = a.insert(N, 99)
let ab = a.insert(N, [77,88,99])
```

最后变量 aa 的值为 `[1,2,99,3,4,5]`，ab 的值为 `[1,2,77,88,99,3,4,5]`。

### 追加元素或列表（::不支持）

当传入 "列表长度 + 1" 给函数 `插入` 时，实际的效果是追加元素或列表。使用 `追加`（`append`） 函数可以使目的更明确。不过需要注意的是，追加操作的效率比在列表头添加元素的要低很多，一般不建议使用追加操作。

### 替换元素或列表

替换元素可以由两次 "切分列表" 和两次 "拼接列表" 共 4 个操作完成，为了简化操作，XiaoXuan 提供了 `替换`（`replace`） 函数。

`替换` 函数的签名是：

* `替换 (列表实例, 开始位置, 元素个数, 新元素)`
* `replace (listInstance, startPosition, count, newElement)`

示例，假设有列表 `[1,2,3,4,5]`，现分别有新元素 `99` 和新列表 `[77,88,99]` 准备替换从位置 M 开始的 N 个元素，假设 M = 2，N = 3，代码如下：

```js
让 M = 2
让 N = 3

让 (x, y) = a.切分(M)
让 (_, z) = y.切分(M+N)
让 b1 = x ++ [99, ...z]
让 b2 = x ++ [77,88,99] ++ z

// 使用 `替换` 函数
让 b1 = a.替换(M, N, 99)
让 b2 = a.替换(M, N, [77,88,99])
```

```js
let M = 2
let N = 3

let (x, y) = a.part(M)
let (_, z) = y.part(M+N)
let b1 = x ++ [99, ...z]
let b2 = x ++ [77,88,99] ++ z

// by using `replace` function
let b1 = a.replace(M, N, 99)
let b2 = a.replace(M, N, [77,88,99])
```

结果变量 `b1` 的值为 `[1,99,5]`，`b2` 的值为 `[1,77,88,99,5]`。

### 查找元素或（子）列表的出现位置

`查找位置`（`findPosition`）函数可以在指定的列表中查找指定的元素或者子列表，并返回找到的位置（位置值将会被 `可选` 类型的 `有` 封装）。如果没发现目标，则返回 `无`（`None`）。

示例：

```js
让 i = a.查找位置(4)        // 得 `有(4)`
让 j = a.查找位置(99)       // 得 `无`
让 m = a.查找位置([3,4])    // 得 `有(3)`
让 n = a.查找位置([77,88])  // 得 `无`
```

```js
let i = a.findPosition(4)        // get `Some(4)`
let j = a.findPosition(99)       // get `None`
let m = a.findPosition([3,4])    // get `Some(3)`
let n = a.findPosition([77,88])  // get `None`
```

查找位置也支持传入一个签名为 `Boolean <= (T item)` 的函数，查找过程会从列表逐个元素取出然后传递给这个函数，当函数返回 `真`（`true`）时，查找过程中断，并且返回当时的位置。如果查到最后一个元素这个函数仍未返回 `真`，则查找过程返回 `无`（`None`）。

假设现有一个结构体 `用户`（`User`）及几个实例如下：

```js
struct User
    String name
    String email
end

let u1 = User("foo", "foo@domain.local")
let u2 = User("bar", "bar@domain.local")

let uu = [u1, u2]
```

下面的代码用于查找用户名为 "bar" 的元素的位置值：

```js
let i = uu.findPosition(do %.name === "bar")  // get `Some(2)`
let j = uu.findPosition(do %.name === "John") // get `None`
```

### 查找元素

`查找`（`find`）函数可以根据传入的 `Boolean <= (T item)` 查找符合的元素，找到后返回被 `可选` 类型的 `有` 封装的元素，如果没发现目标，则返回 `无`（`None`）。

示例，继续上例当中的列表 `uu`，下面的代码用于查找用户名为 "bar" 的元素：

```js
let m = uu.find(do %.name === "bar")    // get `Some(User("foo", ...))`
let n = uu.find(do %.name === "John")   // get `None`
```

## 队列

队列（Queue）是一种 "先进先出（FIFO）" 的列表，如果程序需要不断累加数据到列表的末尾，则应考虑使用队列（因为在列表末尾添加元素的效率非常低）。

队列的操作方法很少，一般用于构建一些需要不断追加数据的场合，一旦追加完毕，再把它转换成普通列表。

### 实例化队列

队列没有字面量，只能通过 `队列`（`Queue`） 函数实例化。

```js
让 q = 队列<整数>()
```

### 追加元素或列表

```js
让 q1 = q.追加 (11)
// q1 == 11

让 q2 = q1.追加 ([77,88,99])
// q2 == 11, 77, 88, 99
```

当然也能添加另一个队列：

```js
让 p = 队列<整数>()
让 p1 = p.追加 (11)
// p1 == 11

让 p2 = p1.追加 (q2)
// p2 == 11, 77, 88, 99
```

### 删除元素

跟列表的情况类似，队列也是没有删除操作，或者说，获取部分元素就是相当于删除。但队列访问元素的方法很少，只支持 `第一个` 和 `尾部` 两个函数，以及使用 `遍历` 语句。

### 转换为普通列表

使用队列的 `转为列表`（`toList`） 函数即可将队列转成列表。

## 映射表

映射表（Map）是一系列 "键-值对" 数据。

映射表的字面量是：使用一对花括号包围所有数据，多个 "键-值对" 之间使用逗号分隔，使用 "键名:值" 构建 "键-值对"。示例：

```js
{
    "东": 123,
    "西": 456
}
```

```js
{
    "foo": 123,
    "bar": 456
}
```

键支持大部分类型的数据，只要实现了 "可比较" 特性即可，值可以是任何类型的数据。当键为字符串类型时，键名的双引号可以省略，比如上面第一个映射表，可以简化为：

```js
{
    东: 123,
    西: 456
}
```

需注意一个映射表里的所有 "键-值对" 的数据类型必须一样，上面示例的第一个映射表数据类型是 "映射表<字符串, 整数>", 第二个是 "映射表<字符串, 字符串>"。

XiaoXuan 运行环境默认使用二叉树来实现映射表。

### 访问映射表的元素

使用 `获取`（`get`）函数用于获取指定键的元素。

假设现有映射表 `a` 内容如下：

```js
让 a = {
    "东": 1,
    "西": 2,
    "南": 3,
    "北": 4
}
```

如果项获取键 "西" 的值，语句如下：

* `让 i = 获取 (a, "西")`
* `让 i = a.获取 ("西")`

* `let i = get (a, "西")`
* `let i = a.get ("西")`

函数返回 `可选<字符串>`（`Option<String>`） 数值，如果存在指定键对应的值，则数值为 `有(值)`，否则数值为 `无`。这个例子里，变量 i 的值为 `有(2)`。

#### 使用中括号获取指定键的值

除了使用 `获取` 函数，还可以使用一对中括号来获取指定键的值。示例：

* `让 i = a["西"]`
* `let i = a["西"]`

变量 i 的值跟使用 `获取` 函数的返回值一样。

#### 使用模式解构获取指定键的值

示例：

```js
// 同时获取键 "东" 和 "南" 的值，并赋值给变量 i 和 j。
让 {"东": i, "南": j} = a

// 同上，然后将剩余的 "键-值对" 存入变量 k，变量 k 将是一个映射表，
// 其内容为 `{"西": 2, "北": 4}`
让 {"东": i, "南": j, ...k} = a

// 当键的数据类型是字符串时，也可以省略双引号
让 {东: i, 南: j} = a

// 如果连变量 i, j 都省略，那么将会得到跟键名一样的变量
让 {东, 南} = a
```

### 添加新的 "键-值对"

使用 `添加`（`add`）函数向映射表添加新的 "键-值对"，函数返回值是 `结果<映射表>`。如果操作成功，则返回 `好(新映射表)`（`Ok(new_map)`），如果键名已经存在，则返回 `错误()`（`Err()`）。

示例：

```js
match a.add("中", 5)
    case Ok(m): writeLineFormat("new map: {:?}", m)
    case Err(): writeLine("error")
end
```

### 更新已存在的键值

使用 `更新`（`update`）函数向映射表更新已存在的键值，如果操作成功，则返回 `好(新映射表)`（`Ok(new_map)`），如果指定的键不存在，则返回 `错误()`（`Err()`）。

示例：

```js
match a.update("中", 2)
    case Ok(m): ...
    case Err(): ...
end
```

### 添加或更新 "键-值对"

可以使用 `设置`（`set`）函数添加或更新 "键-值对"，函数总是返回一个新的映射表。

示例：

```js
let b = a.set("中", 6)
```

也可以使用 "..." （三个点）代替 `设置` 函数，示例：

```js
let b = {"中": 6, ...a}
```

### 检查指定键是否存在

使用 `存在`（`exist`）函数可以检查是否存在指定的键，如果存在则返回 `真`（`true`），否则返回 `假`（`false`）。

### 删除 "键-值对"

使用 `删除`（`remove`） 函数可以 "删除" 映射表指定的 "键-值对"，返回值的类型是 `结果<映射表>`，成功则返回新映射表，如果指定键不存在则返回 `错误()`。
