# 结构体和联合体

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [结构体和联合体](#结构体和联合体)
  - [结构体](#结构体)
    - [实例化结构体](#实例化结构体)
    - [访问结构体成员的值](#访问结构体成员的值)
    - [更新成员的值](#更新成员的值)
    - [数据验证约束](#数据验证约束)
    - [自定义构造函数](#自定义构造函数)
    - [匿名成员结构体](#匿名成员结构体)
    - [无成员结构体](#无成员结构体)
  - [联合体](#联合体)
    - [实例化联合体](#实例化联合体)
    - [访问联合体成员的值](#访问联合体成员的值)
  - [元组](#元组)
    - [元组的访问](#元组的访问)
    - [添加元组元素](#添加元组元素)

<!-- /code_chunk_output -->

结构体和联合体是用户自定义数据类型。

XiaoXuan 各种数据类型之间没有继承关系。

## 结构体

结构体的作用是将一堆相关的数据打包成为一个整体。结构体由基本数据类型，比如整数、字符串、逻辑等组成，当然结构体也能嵌套其他结构体和联合体。结构体的定义语法如下：

```js
结构体 名称
    数据类型1 成员名称1
    数据类型2 成员名称2
    ...
以上
```

```js
struct Name
    DataType1 memberName1
    DataType2 memberName2
    ...
end
```

结构体的定义也可以写成一行的形式，只需把所有成员（member）用括号包围起来，然后使用逗号分隔各个成员即可，语法如下。

```js
结构体 名称(数据类型1 成员名称1, 数据类型2 成员名称2, ...)
```

```js
struct Name(DataType1 memberName1, DataType2 memberName2, ...)
```

示例：

```js
结构体 用户
    整数 id
    字符串 name
    逻辑 checked
以上

结构体 登录(用户 user, 时间 time)
```

```js
struct User
    Int id
    String name
    Boolean checked
end

struct Login(User user, Time time)
```

### 实例化结构体

运行环境会自动为每一个结构体创建一个默认构造函数，函数的参数为全部成员。使用 `新建`（`new`） 关键字可以调用此构造函数以创建结构体的实例。

示例：

```js
让 u1 = 新建 用户 (100, "张三", true)
让 u2 = 新建 用户 (101, "李四", false)
```

```js
let u1 = new User (100, "foo", true)
let u2 = new User (101, "bar", false)
```

跟普通函数一样，构造函数也可以按参数名称调用。

示例：

```js
让 u1 = new 用户 (id=100, name="张三", checked=true)
```

需注意的是，混合按参数顺序和按参数名称调用时，必须先写完所有按顺序传参的值，才可以开始写按名称传参的值。

### 访问结构体成员的值

使用 "实例名称 + . + 成员名称" 的格式可以访问结构体各个成员的值。

示例：

```js
让 编号 = u1.id
让 姓名 = u1.name
```

```js
let id = u1.id
let name = u1.name
```

### 更新成员的值

因为 XiaoXuan 的值不可变性，所以没法直接为结构体的成员赋予新值，比如 `u1.name = "John"` 这语句是语法错误的，如果需要更新成员的值，只能新建一个结构体实例，然后把原结构体实例需要保留的值一一复制过来，示例：

```js
让 u3 = 用户(u1.id, "王五", u1.checked)
```

```js
let u3 = User(u1.id, "John", u1.checked)
```

上面的代码的作用相当于将 `u1` 的 `name` 成员的值更新，然后将新实例存储到变量 `u3`。

XiaoXuan 支持一种简化的更新结构体成员（即复制其他实例成员的值）的语法，调用构造函数时，使用按参数名称方式传入成员的新值，并使用 "..." 符号（即三个点）复制原实例成员的值。

示例：

```js
让 u3 = 用户(name="王五", ...u1)
让 u4 = 用户(name="赵六", checked=false, ...u1)
```

```js
let u3 = User(name="John", ...u1)
let u4 = User(name="Smith", checked=false, ...u1)
```

### 数据验证约束

有时一个结构体的成员的值有一定的使用限制，比如表示有理数的结构体的分母不能为 0 等。可以在定义结构体时添加 `@验证`（`@validate`）标注用于约束成员的值。示例：

```js
@验证(id > 0 :并且 name != "")
结构体 用户
    整数 id
    字符串 name
    逻辑 checked
以上
```

```js
@validate(id > 0 :and name != "")
struct User
    Int id
    String name
    Boolean checked
end
```

标注 `@验证` 的内容是一个能返回逻辑值的表达式，该表达式会被运行环境自动置入默认构造函数当中，在构造结构体实例时，如果该表达式返回 `假`，则会引起运行时异常，即实例构造失败。

一个结构体可以有多个 `@验证` 标注，只要任何一个验证表达式返回 `假`，都会导致实例构造失败。

标注 `@验证` 也可以标在结构体的成员之上，示例：

```js
结构体 用户
    @验证(id > 0)
    整数 id

    @验证(name != "")
    字符串 name

    逻辑 checked
以上
```

当标注 `@验证` 标在成员之上时，只能单独验证该成员的值。

### 自定义构造函数

运行环境会自动为结构体创建一个默认构造函数，函数的参数为全部成员。可以为结构体添加一个或多个 `新建`（`new`）方法，只要这些方法的参数列表跟默认构造函数不同，且返回值为该结构体，则它们都会自动称为构造函数。当程序使用 `新建`（`new`）关键字实例化结构体时，会根据参数情况自动选择适当的构造函数。

示例：

```js
实现 用户
    函数 新建 (整数 id, 字符串 name) = 新建 用户(id, name, true)
    函数 新建 (整数 id) = 用户(id, "张三")
以上
```

```js
implement User
    function new (Int id, String name) = new User (id, name, true)
    function new (Int id) = User(id, "张三")
end
```

上面定义了两个自定义构造函数。其中第一个允许用户省略 `checked` 参数，函数的主体为调用默认的构造函数。第二个构造函数则允许用户省略 `name` 和 `checked` 参数。

通过自定义构造函数，我们可以简化某些复杂的结构体的实例化过程。

需要注意的是，默认构造函数是无法覆盖的，即我们无法添加一个签名跟默认构造函数一样的函数。即运行环境会自动为每个结构体生成类似下面的函数：

```js
实现 用户
    函数 新建 (整数 id, 字符串 name, 逻辑 checked)
        ...
    以上
以上
```

该函数会调用运行环境提供的内置方法以创建结构体实例。从中也可以看出，创建实例除了使用 `创建`（`new`） 关键字，其实也可以直接调用结构体的 `创建`（`new`）函数。示例：

* 让 u1 = 用户.创建 (123, "foo", true)
* let u1 = User.new (123, "foo", true)

### 匿名成员结构体
### 无成员结构体

## 联合体

联合体由一个或多个成员组成，每一个成员可以是一个结构体、一个元组、一个常量。

虽然联合体可以有多个成员，但一个联合体实例的值只能是其中一个成员的值。

需注意的是，联合体成员的定义必须在现场定义，而不能使用外部已定义的（比如不能使用外部定义的结构体）。联合体的定义语法是：

```js
01  联合体 名称
02      成员名称1 (数据类型1 成员名称1, 数据类型2 成员名称2, ...)
03      成员名称2 (数据类型1, 数据类型2, ...)
04      成员名称3
05      ...
06  以上
```

```js
01  Union Name
02      MemberName1 (DataType1 memberName1, DataType2 memberName2, ...)
03      MemberName2 (DataType1, DataType2, ...)
04      MemberName3
05      ...
06  end
```

上面语句的 02 行定义了一个结构体类型的成员，03 行定义了一个元组类型的成员，04 行定义了一个常量，需注意的是这个常量并不需要指定其数值，这点跟其他面向对象语言当中的 "枚举" 类型有些类似。

示例：

```js
联合体 作品
    书籍(字符串 title, 字符串 isbn)
    专辑(字符串 title, 字符串 artist)
以上
```

```js
union Work
    Book(String title, String isbn)
    Album(String title, String artist)
end
```

### 实例化联合体

联合体的结构体类型和元组类型的成员的实例化跟正常的结构体和元组的实例化方法一样，至于常量，则不需实例化，直接当成常量使用即可。

示例：

```js
让 作品1 = 作品::书籍("从地球到月球", "123456")
让 作品2 = 作品::专辑("Fly Me to the Moon", "foobar")
```

```js
let work1 = Work::Book("从地球到月球", "123456")
let work2 = Work::Album("Fly Me to the Moon", "foobar")
```

### 访问联合体成员的值

因为联合体实例只能存储其中一个成员的值，所以首先需要确定它的值是哪个成员，然后再读取其成员的值。XiaoXuan 只支持通过模式匹配来完成这个任务。示例：

```js
匹配 作品1
    情况 书籍(title, isbn):
        ...
    情况 专辑(title, artist):
        ...
以上
```

```js
match work1
    case Book(title, isbn):
        ...
    case Album(title, artist):
        ...
end
```

如果有时只对其中一个成员的值感兴趣，也可以使用简化版的 `匹配` 语句 ———— `如果 让` 语句来完成，示例：

```js
如果 让 书籍(title, isbn) 匹配 作品1 那么
    ...
以上
```

```js
if let Book(title, isbn) match work1 then
    ...
end
```

## 元组

`元组`（`Tuple`）通常用于函数的返回值，当函数需要返回的数值不止一个时可以使用元组。

一个元组可以视为一个 **匿名成员的结构体**，即它由固定数量、顺序、数据类型的一个或多个成员组成。注意跟其他语言的元组不同，XiaoXuan 的元组并不是一种集合。

元组的字面量的格式是：使用一对括号包围所有数据，数据之间使用逗号分隔。

示例：

```js
(1, 2, 3)
(1, "hello", true, 3.14)
```

元组的数据类型为元组各个成员的数据类型的组合，比如上面两个元组的数据类型分别是：

* `(整数, 整数, 整数)`
* `(整数, 字符串, 逻辑, 浮点数)`

需注意，列表要求所有元素的数据类型必须相同，而元组的每个成员的数据类型都可以不同。

为了一致性，也存在单独一个成员的元组，其字面量是在第一个数值后面加上一个逗号。

示例：

* `(456, )`
* `("foo", )`

上面两个元组的数据类型分别是 `(整数)` 和 `(字符串)`。

元组无法使用函数构建。

### 元组的访问

元组跟列表和映射表不同，它的成员既不能通过位置/索引来访问，也没法通过成员名称来访问，一般使用模式匹配或者模式解构来访问。

示例，假设现有元组 `a`，其值为：

`让 a = (123, "hello", true)`

可以使用如下语句获取它的三个成员的值：

`让 (a,b,c) = a`

三个变量 `a`, `b`, `c` 的值分别为 123, "hello" 和 true。

除了模式匹配和模式解构，还可以通过 <!-- 运行环境自动为元组生成的成员名称来访问，成员名称的分别为 "_1"，"_2" 如此类推，即一个下划线加上成员的次序，-->
`获取成员`（`getMember`）函数获取成员的值，向函数传入成员的次序即可读取相应的成员值，次序从数字 1 开始（而不是从 0 开始）。

示例：

```js
让 a = (123, "hello", true)

让 m1 = a.获取成员(1) # 123
让 m2 = a.获取成员(2) # "hello"
让 m3 = a.获取成员(3) # true
```

使用 `成员个数`（`memberCount`） 函数可以获取成员的个数。

示例：

```js
让 c = a.成员个数() # 3
```

需注意的是，在构造元组实例时，运行环境支持为成员值附带上名称。比如在调用函数时，可以按参数位置传参，也可以按参数名称传参，或者混合两种传参方式。但成员的名称仅仅用于构造元组实例，只是成员的一个附加的数据，XiaoXuan 没提供获取成员名称的方法，也没提供按元组成员名称访问成员的方法。

示例：

```js
让 a = (1, 2, 3, 名称 = "hello", 形状 = "circle")

让 m4 = a.获取成员(4) # "hello"
让 m5 = a.获取成员(5) # "circle"
```

元组成员大致相当于如下的联合体：

```js
union TupleMember<T>
    Value(Int index, T v)
    ValueWithName(Int index, String name, T v)
end
```

### 添加元组元素

元组常用的只有构造和读取两种操作，一般很少需要修改元组的数据，不过<!-- XiaoXuan 还是提供了添加新成员到一个元组的头部的方法，用于构造一个新元组。--> 可以通过是使用一对圆括号和 "..." 符号（三个点号）的方法向元组头部添加成员。

示例：

```js
让 a = (1, 2, 3)
让 b1 = (99, ...a)
让 b2 = (77, "foo", true, ...a)

# b1 == (99, 1, 2, 3)
# b2 == (77, "foo", true, 1, 2, 3)
```

这种语法对应的函数是 `元组::添加`（`Tuple::add`），它是一个系统函数，有且只有一个参数，可以接受任意类型的值，另外还有 `元组::追加`（`Tuple::append`） 系统函数用于向元组末尾添加成员。
