# 方法、范型和特性

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [方法、范型和特性](#方法-范型和特性)
  - [数据类型的方法](#数据类型的方法)
    - [添加数据类型的方法](#添加数据类型的方法)
      - [`本型` 数据类型](#本型-数据类型)
      - [方法的柯里化](#方法的柯里化)
      - [构造函数](#构造函数)
    - [实例方法](#实例方法)
      - [使用点号调用实例方法](#使用点号调用实例方法)
      - [引用实例方法](#引用实例方法)
      - [方法名称前置调用实例方法](#方法名称前置调用实例方法)
      - [方法名称前置调用的意义](#方法名称前置调用的意义)
    - [方法的组织](#方法的组织)
  - [范型](#范型)
    - [类型具体化](#类型具体化)
    - [范型函数](#范型函数)
    - [范型的类型自动推导](#范型的类型自动推导)
    - [`空元组` 数据类型](#空元组-数据类型)
    - [为范型的数据赋予方法](#为范型的数据赋予方法)
    - [范型数据方法当中包含其他范型](#范型数据方法当中包含其他范型)
  - [特性](#特性)
    - [定义特性](#定义特性)
    - [赋予数据类型以特性](#赋予数据类型以特性)
    - [赋予泛型数据类型以特性](#赋予泛型数据类型以特性)
    - [`派生` 标注](#派生-标注)
    - [方法的覆盖（override）](#方法的覆盖override)
    - [特性中的空方法](#特性中的空方法)
    - [关联类型](#关联类型)
    - [泛型特性](#泛型特性)
      - [赋予泛型特性到泛型数据类型](#赋予泛型特性到泛型数据类型)
    - [内置特性](#内置特性)
  - [特性约束](#特性约束)
    - [为范型函数添加特性约束](#为范型函数添加特性约束)
    - [为范型数据类型添加特性约束](#为范型数据类型添加特性约束)
    - [为特性添加特性约束](#为特性添加特性约束)
  - [特性作为数据类型使用](#特性作为数据类型使用)

<!-- /code_chunk_output -->

## 数据类型的方法

除了一般用途的函数（即在模块范围内定义的函数），还有一些函数是专门为某些数据类型所使用的。即某个函数跟某个数据类型紧密相关，而跟其他数据类型则关系不大。XiaoXuan 称这种函数为 "数据类型的关联方法"（"data type association method"），或者简称 `方法`（`method`）。相应地，其他非数据类型关联方法，即一般函数，可以称为 "自由函数"。

> XiaoXuan 标准库里的大部分函数都是以 "数据类型的方法" 的形式存在，而自由函数很少。

> XiaoXuan 的数据类型的方法跟面向对象的方法不太一样，数据类型的方法仅仅是一种被自动分配到跟数据类型名称相同的名称空间中的普通函数，在技术上它跟数据类型之间没有关联。

### 添加数据类型的方法

使用 `赋予`（`assign`）(::TODO 考虑使用 `实现` `impl` 关键字)语句可以为指定的数据类型添加方法。<!--方法又可以分为 "静态方法" 和 "实例方法" 两种。--> 可以多次使用 `赋予` 语句为同一个数据类型添加方法。

需注意只能给当前模块的数据类型赋予方法，无法为非当前模块的数据类型赋予方法。比如标准库里有 `Int32` 类型，除了标准库模块自己，其他模块都无法为它 `赋予` 更多的方法（但可以添加特性方法，下面章节会讲述）。

示例：

```js
赋予 类型名称
    函数 返回值数据类型 函数名称 (数据类型1 参数1, 数据类型2 参数2, ...)
        ...
    以上
以上
```

```js
assign DataTypeName
    function ReturnDataType functionName (DataType1 param1, DataType2 parsm2)
        ...
    end
end
```

调用数据类型的方法跟调用一般函数（自由函数）没什么区别，只是在调用数据类型方法时，需要在方法名称前面添加其所属的数据类型的名称。（当然如果使用 `使用` 关键字把相关方法导入到当前名称空间，则可以免去这个前缀）

语法：

* `数据类型名称::方法名称 (参数值1, 参数值2, ...)`
* `DataTypeName::functionName (value1, value2, ...)`

即先写出数据类型的名称，然后加两个冒号 `::`，再写方法的名称。

注意 XiaoXuan 使用的名称空间分隔符是双冒号 `::`，而不是类似 Java 语言的点号 `.`。

示例：

现有结构体 `学生`（`Student`），要添加一个方法 `转换自`(`convertFrom`)，以实现从 `用户`（`User`） 类型数据转换到 `学生` 类型。代码如下：

```js
结构体 学生
    整数 编号
    字符串 姓名
以上

赋予 学生
    函数 学生 转换自 (用户 u)
        新建 学生 (u.编号, u.姓名)
    以上
以上
```

```js
struct Student
    Int id
    String name
end

assign Student
    function Student convertFrom (User u)
        new Student (u.id, u.name)
    end
end
```

调用该方法的代码如下：

* `让 s1 = 学生::转换自(u1)`
* `let s1 = Student::convertFrom(u1)`

#### `本型` 数据类型

在为数据类型添加方法时，经常会在参数里出现该数据的自己数据类型，为了简便起见，XiaoXuan 提供一个叫做 `本型`（`Self`） 的特殊数据类型，代表着数据自己数据类型。

注意，`本型` 只是一个代号，并非是一个真正的数据类型，它只能用在数据类型的方法定义上。

示例：

```js
赋予 学生
    函数 学生 转换自 (本型 u)
        ...
    以上
以上
```

```js
assign Student
    function Student convertFrom (Self u)
        ...
    end
end
```

上例中的 `本型`（`Self`）代表着 `Student` 这个数据类型，语法解析器会自动把 `本型` 替换成实际类型，为了统一起见，XiaoXuan 推荐使用 `本型` 代替所有在数据类型方法中出现的自身数据类型，而不建议直接写具体的数据类型。

#### 方法的柯里化

当方法有多个参数时，一般习惯上把 `本型` 参数放在参数列表的最后一个，这样的目的是为了让方法可以实现柯里化，即为方法提供部分调用的能力。也就是说，方法的最后一个参数一般代表着 "数据"，而前面的参数一般代表着 "选项"。

示例：

```js
赋予 字符串
    # 数据类型方法
    函数 字符串 替换(正则 r, 字符串 s, 本型 self)
        ...
    以上

    # 柯里化的第 1 个方法重载
    函数 字符串 替换(正则 r, 字符串 s)
        匿名函数 (本型 self) = 替换(r, s, self)
    以上

    # 柯里化的第 2 个方法重载
    函数 字符串 替换(正则 r)
        匿名函数 (String s) = 替换(r, s)
    以上
以上
```

```js
assign String
    # data type method
    function String replace(Regex r, String s, Self self)
        ...
    end

    # curry method overload 1
    function String replace(Regex r, String s)
        fn (Self self) = replace(r, s, self)
    end

    # curry method overload 1
    function String replace(Regex r)
        fn (String s) = replace(r, s)
    end
end
```

函数柯里化之后，有时能简化调用的代码。

示例：

```js
让 姓名 = "foo bar"
让 地址 = "abc def ghi"

让 替换空格 = 字符串::替换(/\s+/, "_")
让 n = 替换空格(姓名)
让 a = 替换空格(地址)
```

```js
let name = "foo bar"
let addr = "abc def ghi"

let replace_space = String::replace(/\s+/, "_")
let n = replace_space(name)
let a = replace_space(addr)
```

为了节省手动添加柯里化的方法重载，可以使用 `@柯里化`（`@curry`） 标注，把它标注在一个完整参数的函数上，运行环境会自动帮我们生成它的所有柯里化的方法重载。

比如上例当中的 3 个函数定义语句，实际上只需书写第 1 个。

示例：

```js
赋予 字符串
    @柯里化
    函数 字符串 替换(正则 r, 字符串 s, 本型 self)
        ...
    以上
```

```js
assign String
    @curry
    function String replace(Regex r, String s, Self self)
        ...
    end
end
```

#### 构造函数

在结构体一章提到，其实构造函数就是数据类型的方法，其名称为 `新建`（`new`），运行环境会为每一个构造体自动生成一个默认的构造函数。比如上例的 `学生` 结构体，其自动生成的构造函数如下：

```js
赋予 学生
    # 运行环境内部自动生成的代码
    本型 新建 (整数 编号, 字符串 姓名)
        ...
    以上
以上
```

```js
assign Student
    # automatically generated code by the runtime
    Self new (Int id, String name)
        ...
    end
end
```

使用方法实例化一个结构体的代码如下：

* `让 s = 学生::新建 (123, "foo")`
* `let s = Student::new (123, "foo")`

XiaoXuan 提供了一个语法糖，可以 <!-- 使用 `新建`（`new`）关键字来调用数据关联的 `新建` 方法：

* `让 s = new 学生 (123, "foo")`
* `let s = new Student (123, "foo")`
-->

直接将数据类型作为方法名称以调用构造函数，比如：

* `让 s = 学生 (123, "foo")`
* `let s = Student (123, "foo")`

### 实例方法

实例方法就是一个数据类型方法当中的**第一个参数**的数据类型为 `本型` 的函数。相应地，非实例方法我们可以称之为 "一般方法"。

比如要在上例的 `学生` 结构体里添加一个 `显示姓名`（`showName`）的实例方法，用于显示学生的姓名，则代码如下：

```js
赋予 学生
    函数 显示姓名 (本型 s)
        书写行 (!"我的名字是 {s.name}")
    以上
以上
```

```js
assign Student
    function showName(Self s)
        writeLine(!"My name is {s.name}")
    end
end
```

调用 "实例方法" 的方法跟调用 "一般方法" 一样，只不过需要把数据实例作为第一个参数传入而已。

示例：

```js
让 s = 新建 学生 (123, "foo")
学生::显示姓名 (s)
```

```js
let s = new Student (123, "foo")
Student::showName (s)
```

注意：

* 实例方法也允许有多个参数，但 `本型` 类型必须放在第 1 位；
* 实例方法一般不提供柯里化重载；
* 如果某个数据类型方法刚好只有一个参数，且其类型刚好是 `本型`，那么它既是 "一般方法" 也是 "实例方法"，其实无论是那种类型的方法，都是普通函数，只不过是我们约定俗成地按照某种特征为它们分类而已。

#### 使用点号调用实例方法

对于实例方法，除了可以使用 "一般方法" 的格式来调用之外，还支持使用 "点号调用" 方式。格式是：

`数据实例 .方法名称 (参数值1, 参数值2, ...)`

它其实是数据类型方法调用的语法糖，即等同于：

`数据类型名称::方法名称 (数据实例, 参数值1, 参数值2, ...)`

习惯性将方法名称之前的点号跟数据实例连在一起写，即中间不加空格，比如：

`数据实例.方法名称 (参数值1, 参数值2, ...)`

因为使用点号调用格式可以省略书写数据类型名称，且显得该方法跟数据紧密相关（就像是这个数据的成员一样），所以一般使用 "点号调用" 方式来调用实例方法。

示例：

```js
让 s = 新建 学生 (123, "foo")
s .显示姓名 ()
s.显示姓名 ()
```

```js
let s = new Student (123, "foo")
s .showName ()
s.showName ()
```

#### 引用实例方法

<!--
当我们使用 "点号调用" 的格式实行 "方法引用" 而非 "方法调用" 时，比如把它赋值给一个变量，或者作为参数传递给另外一个函数，运行环境会自动把它转换为一个绑定了数据实例的匿名函数。
-->

虽然点号 "." 同时也用来访问表示数据类型的成员，比如 `学生实例.姓名` 表示 `学生` 这个结构体的 `姓名` 成员，但点号调用当中的点号并非表示数据类型的成员，比如语句 `学生实例.显示姓名` 是错误的，它无法代表 `学生::显示姓名` 函数。

示例：

<!--
```js
让 s = 新建 学生 (123, "foo")
让 f = s.显示姓名

# 调用引用的方法
f()
```

```js
let s = new Student (123, "foo")
let f = s.showName

# invoke the referenced method
f()
```

在这个例子里，变量 `f` 的值实际是：

* `匿名函数 () = 学生::显示姓名(s)`
* `fn () = Student::showName(s)`
-->

```js
让 s = 学生 (123, "foo")
让 f = s.显示姓名
```

上面代码的第二句会引起语法错误（注意在某些编程语言里这样的写法是允许的，比如 JavaScript）。如果有时确实需要引用某个数据类型的方法（无论是普通方法还是实例方法），只能以数据类型方法的完整形式书写，即 `让 f = 数据类型名称::方法名称`。

#### 方法名称前置调用实例方法

除了使用 "一般方法调用风格" 和 "点号调用风格"，XiaoXuan 还支持使用 "方法名称前置" 这种格式来调用实例方法。

格式是在方法名称后面前面加上单引号（`'`），然后使用像自由函数方式书写调用语句。

比如 `学生::显示姓名 (s)` 语句，可以直接省略 `学生` 这个数据类型直接写成 `!显示姓名(s)`。

所以下面的 3 行语句是等效的：

```js
01  学生::显示姓名(s)
03  s.显示姓名()
02  !显示姓名(s)
```

```js
01  Student::showName(s)
03  s.showName()
02  !showName(s)
```

显然实例方法名称前置调用又是个语法糖，比如 `!name(s)` 语句会被解析成 `s.name()`，然后进一步解析为 `Student::name(s)`。

<!--
> 注意使用名称前置格式调用方法时，名称前面不能加上任何前缀。

隠式调用的规则是：对于代码中出现的一般函数（即在函数名称前面无双冒号或点号）调用语句，运行环境会先根据名字查找当前上下文是否存在指定的函数，如果存在则调用它。如果不存在则根据第一个参数查找该数据类型是否存在同名的实例方法（包括下面讲到的特性方法），如果存在则使用该实例方法。
-->

<!--
比如对于表达式：

`2 + 3`

根据中置函数调用原则，上面的表达式会被翻译为：

`Int::add (2, 3)`

而 `add` 函数不是自由函数，也就是说它没有默认地被导入到当前的上下文，于是运行环境查找第一个参数的数据类型，即 `Int` 是否存在 `add` 实例方法。结果它找到了 `Int::add(Self left, Int right)`，于是最后语句被翻译为：

`Int::add(2, 3)`

注意使用隐式调用实例方法存在一定的名称冲突的风险，也就是说，如果恰好当前上下文存在一个 `显示姓名` 的函数，则运行环境执行到 `显示姓名 (s)` 这一行时，会优先使用当前上下文的 `显示姓名` 函数，这可能会导致非预期的结果。

在当前上下文存在同名函数的情况，如果确实要调用实例方法，这时只能把 "隐式调用" 改成实例方法的一般的 "点号调用" 方式即可。

幸好

> XiaoXuan 标准库的大部分函数都是以实例的方法形式存在，默认情况下被导入到当前上下文的自由函数很少。
-->

#### 方法名称前置调用的意义

使用名称前置的格式调用实例方法比较接近动态脚本语言的风格。比如 `List<Real>` 和 `Matrix<Real>` 都实现了 `向上取整`（`ceil`） 方法，下面是点号方式调用和名称前置调用的比较：

```js
# 点号调用风格

让 lc = l.向上取整()
让 mc = m.向上取整()

# 方法名称前置调用风格

让 lc = !向上取整(l)
让 mc = !向上取整(m)
```

```js
# dot call style

let lc = l.ceil()
let mc = m.ceil()

# ...

let lc = !ceil(l)
let mc = !ceil(m)
```

显然，对于一般性的函数（比如数学函数）使用 "名称前置" 风格显得意义更明确。

### 方法的组织

正如前面提到，标准库很多函数都是以 "依附" 到各个数据类型当中作为数据类型的关联函数的方式而存在，通用的数据类型其方法一般会提供 "一般方法" 和 "实例方法" 两个版本。而 "一般方法" 有时还会提供柯里化的重载，方法的实现代码主要都是写在 "一般方法" 之中，而 "实例方法" 内部则仅仅是调用其相应的 "一般方法"。

示例：

```js
赋予 字符串
    # 一般方法
    @柯里化
    函数 字符串 替换(正则 r, 字符串 s, 本型 self)
        ...
    以上

    # 实例方法
    函数 字符串 替换(本型 self, 正则 r, 字符串 s)
        替换(r, s, self)
    以上
以上
```

```js
assign String
    # normal method
    @curry
    function String replace(Regex r, String s, Self self)
        ...
    end

    # instance method
    function String replace(Self self, Regex r, String s)
        replace(r, s, self)
    end
end
```

## 范型

范型（Generic）是生成代码的模板，用于避免重复写 "仅数据类型不同" 的代码，结构体、联合体、函数都支持范型。

示例，有如下两个结构体：

```js
结构体 整数点坐标
    整数 x
    整数 y
以上

结构体 浮点数点坐标
    实数 x
    实数 y
以上
```

```js
struct IntPoint
    Int x
    Int y
end

struct FloatPoint
    Real x
    Real y
end
```

它们的结构一样，仅数据类型不同，所以可以使用范型改写，代码如下：

```js
结构体 点坐标<甲型>
    甲型 x
    甲型 y
以上
```

```js
struct Point<T>
    T x
    T y
end
```

其中一对尖括号里面列出该结构体（或者联合体、函数）所有使用到的类型的代号（简称 "类型代号"）。然后把尖括号写在结构（或联合体、函数）名称之后。

类型代号中文一般使用 "甲型"、"乙型"、"丙型"、"丁型"，或者直接使用 "甲、乙、丙、丁、戊、己、庚、辛、壬、癸"，英文则使用单个大写的字母，比如 "T"、"E"、"R"、"M" 等，在语法上代号的写法无特殊的要求，只是传统上使用这样的写法。多个类型代号之间使用逗号分隔，比如 `结构体<甲, 已, 丙> 点坐标`。

### 类型具体化

在实例化带有范型的结构体时，需要用实际的数据类型替代类型代号，我们将这个过程称之为**类型具体化**。

示例：

```js
让 p1 = 新建 点坐标<整数> (10, 20)
让 p2 = 新建 点坐标<实数> (2.718, 1.618)
```

```js
let p1 = new Point<Int> (10, 20)
let p2 = new Point<Real> (2.718, 1.618)
```

> 泛型的每个具体类型都可以认为是完全不相干的类型，比如 `Point<Int>` 和 `Point<Real>` 可以认为是两个完全不同的类型；运行环境会为它们各自生成不同的代码，方法是 <!--把它们的名称当中的尖括号去掉，--> 创建一个具体类型的子命名空间，子命名空间的名称为具体类型的名称（如果有多个具体类型，则使用减号 `-` ———— 这是一个运行环境内部作为转义字符使用的符号，一个不允许用户用于定义数据类型的符号————进行连接），比如上例会生成 <!-- 数据类型的名称和具体类型的名称，则这两个类型就变成--> `Point::Point--Int` 和 `Point::Point--Real`，然后把代码都 "复制，替换，粘贴（把类型代号替换成目标类型）" 一遍。如下：

```js
struct Point--Int
    Int x
    Int y
end

struct Point--Real
    Real x
    Real y
end
```

实例化结构体时的实际代码：

```js
let p1 = Point::Point--Int::new (10, 20)
let p2 = Point::Point--Real::new (2.718, 1.618)
```

可见使用泛型可以避免大量的手动编码。

> 注意，减号是不允许出现在变量或者数据类型的名称里，所以用户是没法按照上面的格式书写代码。

如果数据类型的泛型代号有多个，则会根据实际情况生成相应的具体类型，比如 `Point<T, E>` 针对 `Point<Int, Real>` 会生成 `Point::Point-Int-Real`。

### 范型函数

范型也可以应用在函数上，跟应用到结构体类似，也是在一对尖括号列出该函数所有用到的数据类型。示例：

```js
函数 最大值<甲型>(甲型 左, 甲型 右)
    如果 左 > 右 那么
        左
    否则
        右
    以上
以上
```

```js
function max<T>(T left, T right)
    if left > right then
        left
    else
        right
    end
end
```

在调用范型函数时，将实际数据类型替代类型代号，示例：

```js
让 a = 最大值<整数> (12, 34)
让 b = 最大值<实数> (3.142, 2.718)
```

```js
let a = max<Int> (12, 34)
let b = max<Real> (3.142, 2.718)
```

跟泛型数据类型类似，当泛型函数被调用时，数据类型则会被具体化，运行环境实际上是生成多份完全不相干的函数复制。比如上例的两个 `max` 函数调用，实际上是生成如下两个函数：

```js
function max-Int(Int x, Int y)
    ...
end

function max-Real(Real x, Real y)
    ...
end
```

调用语句的实际代码：

```js
let a = max-Int(12, 34)
let b = max-Real(3.142, 2.718)
```

可见泛型函数不是方法重载。

<!--，比如：

有范型函数 "sum" 的定义如下：

```js
function T sum<T>(List<T> numbers) type
    T limit Add
    let default = T.default()
    fold(numbers, (i, sum) => i + sum, default)
end
```

当使用不同的类型调用（比如分别使用 Int 和 Real 类型调用）该函数时，范型函数的两次调用可以认为是两个不相干的函数，也可以认为是一份（函数）代码更改了类型然后复制了一份。示例：

```js
let a1 = [1,2,3,4,5]
let a2 = [1.0, 2.1, 3.2, 4.3, 5.4]

# 调用了函数 function Int sum<Int>(List<Int> numbers) ...
let s1 = sum(a1)

# 调用了函数 function Real sum<Real>(List<Real> numbers) ...
let s2 = sum(a2)
```
-->

对于范型函数，只有参数类型（而不是类型代号）不同时，才是函数重载。

示例：

```js
function T sum<T>(List<T> numbers)...
function T sum<T>(Matrix<T> numbers) ...
```

### 范型的类型自动推导

XiaoXuan 的自动类型推导机制在范型里同样有效，也就是说，在实例化范型结构体、调用范型函数时，运行环境会尽可能地推导出正确的数据类型，而在写代码时就可以省略类型了。

示例，上面的实例化结构体和调用函数可以写成如下：

```js
让 p1 = 新建 点坐标 (10, 20)
让 p2 = 新建 点坐标 (2.718, 1.618)
让 a = 最大值 (12, 34)
让 b = 最大值 (3.142, 2.718)
```

```js
let p1 = new Point (10, 20)
let p2 = new Point (2.718, 1.618)
let a = max (12, 34)
let b = max (3.142, 2.718)
```

上面的代码都省略了具体的数据类型。因为在实例化结构体（或者调用函数）时，运行环境会根据成员（参数）传入的实际数据（实参）来推导其数据类型，然后将这个数据类型替换类型代号，再使用这个类型代号应用到整个结构体（或函数），如此类推。

### `空元组` 数据类型

有时具体化一个泛型数据类型时，可能会遇到对具体类型不感兴趣的场景。比如在具体化 `Result<T, E>` 时，如果一个函数成功时无任何有意义的返回值，但希望能传回错误数据，这时可以使用 `空元组`（`Unit`） 数据类型具体化第一个泛型代号，空元型数据类型只有一个值 `空元`（`Empty`），其字面值是一对空括号 `()`，理解为空元组。

示例：

```js
function Result<Unit, std::io::Error> saySomethine()
    # do something
    if errorOccured then
        Err(someError)
    else
        Ok(Empty)  # or `Ok(())`
    end
end
```

注意 XiaoXuan 的 `Unit::Empty` 跟其他编程语言的 `Null` 不是同一个概念，其他语言 `Null` 可能表示空指针或者空对象，在 XiaoXuan 里相似的数据类型是 `Option::None`。而 XiaoXuan 的 `Unit::Empty` 只能赋值给 `Unit` 数据类型，它表示的是一个空元组（一对空括号）。

<!-- 在内置数据类型里还有一个叫 `Result<T>` 的数据类型，它是 `Result<T, std::io::Error>` 的别名，-->

### 为范型的数据赋予方法

在为具有范型的数据赋予方法时，需要注意是赋予给具体的某个数据类型，还是赋予给范型。比如上例的 `点坐标<甲型>`，现在需要添加 `显示坐标`（`showPoint`）实例方法，注意下面的两个赋予语句。

```js
赋予 点坐标<整数>
    函数 显示坐标(本型 p)
        ...
    以上
以上

赋予<甲型> 点坐标<甲型>
    函数 显示坐标(本型 p)
        ...
    以上
以上
```

```js
assign Point<Int>
    function showPoint(Self p)
        ...
    end
end

assign<T> Point<T>
    function showPoint(Self p)
        ...
    end
end
```

上面两个赋予语句非常相似，第二个仅仅在 `赋予` 关键字多了 "<甲型>"，但它们的意义完全不一样：

* 第一个赋予语句仅仅为 `点坐标<整数>` 这种整数类型点坐标赋予了 `显示坐标` 方法，`本型` 代表的是 `点坐标<整数>` 这种特定类型；
* 第二个赋予语句则为 `点坐标` 范型（即任意具体类型的点坐标）赋予 `显示坐标` 方法，`本型` 代表的是 `点坐标<甲型>` 这种范型。

注意第二个赋予语句不能写成 `赋予 点坐标<甲型>`，因为 XiaoXuan 不知道这个 `甲型` 究竟是具体数据类型的名称，还是泛型名称（即类型代号）。当然如果确实存在一个名字为 "甲型" 的数据类型，则这个赋予语句是合法的，如果不存在，则会抛出运行时错误。

如果要为结构体范型本身赋予方法，则需要在 `赋予` 关键字后面同样加上一对尖括号，然后把所有用到的类型代号列出。

### 范型数据方法当中包含其他范型

有时在方法当中会传入其他范型的数据，这些额外的范型只需在方法的类型代号列表中列出即可，而不需要在 `赋予` 关键字后面的类型代号列表中列出。

示例，现在添加 `加`（`add`）方法到 `点坐标` 结构体，该方法接受另外一个点坐标类型的参数，但不要求这个点坐标的类型跟当前点坐标类型一致，代码如下：

```js
赋予<甲型> 点坐标<甲型>
    函数 本型 加<甲型, 乙型> (本型 left, 点坐标<乙型> right)
        新建 本型 (
            left.x + right.x,
            left.y + right.y
            )
    以上
以上
```

```js
assign<T> Point<T>
    function Self showPoint<T, E> (Self left, Point<E> right)
        new Self(
            left.x + right.x,
            left.y + right.y
            )
    end
end
```

注意：

* 代码中，`赋予` 后面的类型代号列表只有 `甲型`，表明这个赋予语句是只针对 `点坐标<甲型>`，而方法名称后面的类型列表里有 `甲型` 和 `乙型`，说明这个方法将会使用到 `甲型` 和 `乙型` 两种数据类型。
* 代码中的 `新建 本型`（`new Self`）是合法的，在上例中，它代表着 `新建 点坐标<甲型>`（`new Point<T>`）。

## 特性

`特性`（`trait`）是指多个类型数据共同具有的特性、或者共同具有的行为。

比如部分数据具有一个叫做 `可显示`（`Display`） 的特性，表示这类数据可以转换为字符串并提供给诸如 `书写行`（`writeLine`）等函数使用；又比如部分数字类型数据具有一个叫做 `可排序`（`Ordered`）的特性，表示这类数据可以通过 `>`、`>=`、`<`、`<=` 等函数进行大小比较。

特性在具体实现上，就是一组函数。

### 定义特性

使用 `特性`（`trait`）关键字可以定义一个特性。

示例，假设有两个结构体 `用户`（`User`） 和 `学生`（`Student`），其都有一个名为 `姓名`（`name`）的成员。现要为它们都添加一个名为 `显示姓名`（`showName`） 的方法，则可以定义一个名字比如 `具名`（`Named`）的特性:

```js
特性 具名
    函数 显示名字(本型 s)
        书写行 (s.姓名)
    以上
以上
```

```js
trait Named
    function showName(Self s)
        writeLine (s.name)
    end
end
```

因为特性会被赋予给具体的数据类型，所以跟数据的实例方法类似，函数的第一个参数必须是其所属的数据的类型，但在定义特性时不知道它最后会被应用到哪个数据类型，所以使用 `本型`（`Self`）来代表将来会被应用到的数据类型。

> "特性的定义" 或者 "目标数据类型的定义"，两者中至少有一项必须在当前模块范围之内，才能在当前模块实现赋予方法。也就是说，如果某个特性和某个数据类型都是在其他模块，你是无法把那个特性赋予给那个数据类型的。

### 赋予数据类型以特性

示例：

赋予 `具名` 这个特性给结构体 `用户`（`User`） 和 `学生`（`Student`）：

```js
赋予 用户 特性 具名
    # 这里无代码
以上

赋予 学生 特性 具名
    # 这里无代码
以上
```

```js
assign User trait Named
    # no code here
end

assign Student trait Named
    # no code here
end
```

之后 `用户` 和 `学生` 示例都具有 `显示名字` 方法。

示例：

```js
让 u = 新建 用户(123, "foo")
让 s = 新建 学生(456, "bar")
u.显示名字()
s.显示名字()
```

```js
let u = new User(123, "foo")
let s = new Student(456, "bar")
u.showName()
s.showName()
```

需注意，可以赋予一个或多个特性给一个数据类型，换句话说，一个数据类型可以同时具有一个或多个特性。只需每个特性都使用 `赋予` 语句赋予到指定的目标数据类型即可。

> 一个特性只能赋予**一次**给一个数据类型，也就是说，当使用 `赋予` 语句赋予一个特性到一个数据类型时，需要**一次过**把所有空方法都补齐，不能分多次书写。

调用数据的特性方法时，需要把它具有的那个特性使用 `使用`（`use`）关键字导入到当前名称空间，否则使用不了。之所以有这个要求，是因为一个数据类型可能被赋予了多种不同的特性，如果这些特性刚好有重名的函数（同时参数列表相同，或者返回值不同）就会造成冲突，为了避免使用点号方式调用方法时的冲突，XiaoXuan 规定只有把数据类型所具有的特性导入到当前名称空间，则该特性的方法才可以使用。

也就是说，跟 `赋予` 语句为数据类型添加方法不同，`赋予` 数据类型的特性的方法的实现是放在 "特性的名称::数据类型名称" 的命名空间之下的，而数据方法是放在 "数据类型名称" 的命名空间之下。

所以上面例子的 `显示名字` 函数调用，实际上会被解析器转换特性的一般方法调用（即普通的函数调用）：

```js
let u = new User(123, "foo")
let s = new Student(456, "bar")

Named::User::showName(u)     #  u.showName()
Named::Student::showName(s)  #  s.showName()
```

使用特性的一般方法调用方式可以解决方法冲突的问题。比如一个数据类型被赋予了两个特性，而这两个特性刚好有 "同名、同参数、不同返回值类型" 的方法，当把这两个特性都引入到当前名称空间时，显然直接使用数据的点号方法调用会引起运行时异常（因为解析器不知道该调用哪个特性的方法），这时可以把点号方法调用改为特性的一般方法调用。

### 赋予泛型数据类型以特性

::TODO

一般需要为数据类型的泛型加上特性约束，否则会因为泛型名称（类型代号）无方法可用而变得没什么用途。

示例：

```js
assign<T> Point<T> trait Display type
    T limit Display

    function toString(Self p)
        let sx = p.x.toString()
        let sy = p.y.toString()
        "Point {x=" ++ sx ++ ", y=" ++ sy ++ "}"
    end
end
```

### `派生` 标注

当赋予一个全部方法都**非空**的特性给一个数据类型时，除了使用 `赋予` 语句，还可以简单地使用 `派生`（`derive`） 标注直接在数据类型（比如结构体）上标注，使用标注的好处是避免写一个空主体的 `赋予` 语句，下面使用标注的方法重写前面第而个例子：

```js
@派生(具名)
结构体 学生
    整数 编号
    字符串 姓名
以上
```

```js
@derive(Named)
struct Student
    Int id
    String name
end
```

如果要赋予多个特性给一个数据类型，则在 `派生` 标注内，把所有特性名称列出，并使用逗号 "," 分隔每个特性名称。

示例：

```js
@派生(具名, 可显示, 可相等比较, 可大小比较)
结构体 学生
    整数 编号
    字符串 姓名
以上
```

### 方法的覆盖（override）

当将一个特性赋予给某个数据类型时，可以在具体的 `赋予` 语句重写特性中已存在的方法。

比如在上例的 `学生` 里，我们可以覆盖方法 `显示名字`：

TODO::

### 特性中的空方法

更多的时候，我们只在特性中定义需要的方法，而具体的方法代码则由实现赋予方法时才书写。这时侯，特性更多起一种 "接口" 作用。也就是说，我们定义特性时，只需描述我们所需要的大概轮廓，而具体实现则留给后面才做。

具体来说，我们只需在特性里确定方法的名称和签名，而方法主体则留空，这种方法叫做 "空函数"（或者说 "空方法"，相当于 Java 里的抽象方法），然后等到在书写 `赋予` 过程再写函数的具体实现代码。

"空函数" 跟普通函数一样，除了：

1. 函数没有主体代码；
2. 定义函数的语句最签名添加 `空`（`empty`） 关键字。

示例，现在在上例中的 `具名` 特性中添加 `显示摘要`（`showSummary`）方法：

```js
01  特性 具名
02      函数 显示名字(本型 s)
03          书写行 (s.姓名)
04      以上
05
06      空 函数 显示摘要(本型 s)
07  以上
```

```js
01  trait Named
02      function showName(Self s)
03          writeLine (s.name)
04      end
05
06      empty function showSummary(Self s)
07  end
```

上面代码的 06 行即空方法。

> 空方法的参数只能使用 `本型` 代替目标数据类型，因为在定义特性时，我们无法得知以后会被赋予到哪个数据类型。

在赋予特性给数据类型时，需要把空方法的主体补上，示例：

```js
赋予 用户 特性 具名
    函数 显示摘要(本型 s)
        书写行 (!"我是用户，编号： {s.id}，姓名： {s.name}")
    以上
以上

赋予 学生 特性 具名
    函数 显示摘要(本型 s)
        书写行 (!"我是学生，编号： {s.id}，姓名： {s.name}")
    以上
以上
```

```js
assign User trait Named
    function showSummary(Self s)
        writeLine(!"I'm User, id: {s.id}, name: {s.name})")
    end
end

assign Student trait Named
    function showSummary(Self s)
        writeLine(!"I'm Student, id: {s.id}, name: {s.name})")
    end
end
```

### 关联类型

因为在定义特性时无法得知最终会被应用到哪个数据类型，所以需要使用 `本型` 代替将来会被赋予该特性的具体数据类型。但这样只有一个 "可变" 的数据类型，有时可能需要更多的 "可变" 数据类型待 `赋予` 时所使用。这种额外的，待将来指定为具体类型的数据类型称为 "关联类型"。

比如对于用于表示序列的特性 `序列`（`Sequence`），其中的函数 `第一个` 输出的数据类型显然不是 `本型`，而是其元素的类型，这种情况下需要在特性里定义多一个 "可变" 的数据类型。

使用 `关联`（`associate`） 关键字可以为特性定义一个或多个关联类型。

示例：

```js
特性 序列 关联 子型
    空 函数 子型 第一个(本型 s)
以上
```

```js
trait Sequence associate ItemType
    empty function ItemType first(Self s)
end
```

上面代码当中的 `子型`（`ItemType`）就是关联类型的代号，为了跟泛型的代号区分，中文一般使用 "子型" "丑型" "寅型" "卯型" 等名称，英文则使用一个描述具体作用的名称，比如 "ItemType", "TargetType", "SourceType" 等等。

在赋予带有关联类型的特性给一个具体的数据类型时，需要同时明文指出所有关联类型的实际类型。语法是 `子型名称 = 实际数据类型名称`，如果有多个关联类型，则使用逗号分隔它们。

示例：

```js
assign MyList trait Sequence associate ItemType = String
    function String first(Self s)
        "foo"
    end
end
```

需注意，具有关联类型的特性仍然只能赋予一次给同一个数据类型。不支持通过更改关联类型的实际类型来多次赋予给同一个数据类型。

示例：

```js
assign MyList trait Sequence associate ItemType = String
    ...
end

assign MyList trait Sequence associate ItemType = Int
    ...
end
```

上面的代码试图将 `Sequence` 特性赋予 2 次给 `MyList` 数据类型，所以会引起运行时异常。

如果需要在 `赋予` 语句块之外访问某个被赋予了特性的数据类型的关联类型，可以使用名称空间的方法访问。

示例：

```js

```

在定义特性的关联类型时，也可以指定其**默认数据类型**，这样在编写 `赋予` 语句时，可以省略关联类型的具体数据类型。

示例：

```js
特性 可转换 关联 子型=字符串
    ...
以上

赋予 我的数据类型 可特性 转换  # 这里可省略关联类型的实际类型
    ...
以上
```

```js
trait Convertable associate ItemType=String
    ...
end

assign MyDataType trait Convertable  # Omit the actual type of the association type here
    ...
end
```

### 泛型特性

特性也支持泛型。跟数据类型的泛型一样，特性的泛型实际上也是代码的模板，泛型参数具体化之后实际上会产生多种完全不同的特性，所以一个带有泛型的特性是可以多次赋予在同一个数据类型。

比如有一个 `可加`（`Addable`） 特性，其中有 `加`（`add`）函数：

* 其第一个参数是 `本型`；
* 为了可以跟多个其他数字数据类型相加，第二个参数定义为泛型；
* 当第一个和第二个参数的数据类型确定后，加法的结果其数据类型是确定的，但很有可能跟第一个和第二个数据类型都不一样。因为结果的数据类型是唯一的，所以函数的返回值数据类型必须定义为关联类型。

```js
特性 可加<甲型> 关联类型 子型
    空 函数 子型 加 (本型 left, 甲型 right)
以上
```

```js
trait Addable<R> associate OutputType
    empty function OutputType add(Self left, R right)
end
```

比如现有一个 `MyNumber` 数据类型准备支持跟整数和实数相加，则大致的代码如下：

```js
assign MyNumber trait Addable<MyNumber> associate ItemType = MyNumber
    function MyNumber add(Self left, MyNumber right)
        ...
    end
end

assign MyNumber trait Addable<Int> associate ItemType = MyNumber
    function MyNumber add(Self left, Int right)
        ...
    end
end

assign MyNumber trait Addable<Real> associate ItemType = MyNumber
    function MyNumber add(Self left, Real right)
        ...
    end
end
```

由此可见，使用泛型特性配合关联类型，可以实现 "多数据类型输入，单数据类型输出" 的目的。

需要注意：

* 并不是输入参数就得定义为泛型，而输出值就得定义为关联类型，有些场合无论是输入参数还是输出值，都可以定义为泛型、或者都定义为关联类型。似乎具体情况而定。但上例不能把加法的第二个参数和函数返回值都定义为泛型，如果都定义为泛型，则表示当第一个、第二个数据类型确定后，返回值的数据类型可以有多个，显然这不符合算术加法的原则。
* 正如上面章节所描述，在调用数据类型具有的特性的方法时，需要事先把该特性导入到当前名称空间方可使用，所以为了使用上面示例代码当中的 `add` 方法，需要添加诸如 `use someNameSpace::Addable<Real>` 的语句。

跟关联类型一样，泛型特性的类型代号也可以指定默认的数据类型，这样在赋予该特性给某些数据类型时，可以省略指定泛型的具体数据类型。

示例：

```js
trait Addable<R=Self> associate OutputType
    empty function OutputType add(Self left, R right)
end
```

上面的 `R=Self` 即为泛型的默认数据类型。假设有如下 `赋予` 语句：

```js
assign MyNumber trait Add associate OutputType = MyNumber
    # ...
end
```

实际的代码将会是：

```js
assign MyNumber trait Add<MyNumber> associate OutputType = MyNumber
    # ...
end
```

#### 赋予泛型特性到泛型数据类型

::TODO

示例：

```js
struct Point<T>
    Int x
    Int y
end

assign<T> Point<T> trait Add<Self> associate OutputType = Self type
    T limit Add<T> associate OutputType = T

    function Self add(Self left, Self right)
        let x = left.x + right.x
        let y = left.y + right.y
        Self (x, y)
    end
end
```

### 内置特性

有一些运行环境内置的特性，比如 `可显示`（`Display`）、`可转字符串`（`ToString`）、`可相等比较`（`Equal`）等，当赋予一个结构体时，如果该结构体里的所有成员也被赋予了这些特性，则该结构体也会自动获得这些特性（而不需要手动写具体的实现代码）。

## 特性约束

### 为范型函数添加特性约束

特性不是数据类型，所以无法将变量、函数的参数等数据类型声明为特性，但在添加特性约束到范型中。

比如要实现一个 "最大值"（"max"）函数，该函数传入两个参数，需要支持整数、浮点数等数据类型，我们很自然会想到把这个函数定义为范型函数，主要代码如下：

```js
函数 最大值<甲型> (甲型 left, 甲型 right)
    如果 left > right 那么 left 否则 right
以上
```

```js
function max<T> (T left, T right)
    if left > right then left else right
end
```

不过用户在调用这个函数时有可能会传入一些不支持大小比较的数据，比如逻辑型数据。可以在定义范型时加入约束，仅让具有指定的一个或多个特性的数据通过。

示例：

```js
函数 最大值<甲型> (甲型 left, 甲型 right) 类型
    甲型 限制 可大小比较
    如果 left > right 那么 left 否则 right
以上
```

```js
function max<T> (T left, T right) type
    T limit Ordered
    if left > right then left else right
end
```

如上例所示，通过在函数的参数列表后面添加 `类型`（`type`）关键字，然后列出需要约束的类型代号，以及 `限制`（`limit`）关键字，再加上特性的名称即可。

如果需要限制多个特性，则在 `限制` 关键字后面使用元组把多个特性名称列出，示例：

```js
函数 最大值<甲型> (甲型 left, 甲型 right) 类型
    甲型 限制 (可显示, 可大小比较)
    如果 left > right 那么 left 否则 right
以上
```

```js
function max<T> (T left, T right) type
    T limit (Display, Ordered)
    if left > right then left else right
end
```

注意，`类型` 关键字后面除了用于列出范型的约束，同时也是用于列出 "类型简写" 的地方，如果需要约束多个范型或者需要声明多个类型，需要在它们之间使用逗号分隔，否则在第一个约束或声明之后的语句会被视为函数主体。详见 [变量-函数的类型简写](variables.md#类型简写)

如果约束的特性是泛型特性，则还需把特性的泛型、关联数据类型都列出。

示例：

```js
addPoint<T>(Point<T> left, Point<T> right) type
    T limit Add<T> associate OutputType = T

    let x = left.x + right.x
    let y = left.y + right.y
    Point<T> (x, y)
end
```

### 为范型数据类型添加特性约束

除了可以为范型函数添加特性约束，还可以为范型数据方法添加特性约束。

比如为上例的 `点坐标` 添加 `显示摘要`（`showSummary`）方法：

```js
赋予<甲型> 点坐标<甲型> 类型
    甲型 限制 可显示
    函数 显示坐标(本型 p)
        ...
    以上
以上
```

```js
assign<T> Point<T> type
    T limit Display
    function showPoint(Self p)
        ...
    end
end
```

这样只有具有 `可显示` 的数据类型才能用于类型具体化 `点坐标` 结构体。

### 为特性添加特性约束

即一个特性要求另外一个特性必须先存在，类似面向对象编程的 "继承"，比如 `HtmlDisplay` 继承 `Display`。

::TODO

## 特性作为数据类型使用

::TODO

特性可以作为数据类型使用。