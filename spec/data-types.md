# 基本数据类型

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [基本数据类型](#基本数据类型)
  - [整数](#整数)
  - [自然数](#自然数)
  - [实数](#实数)
  - [有理数](#有理数)
  - [复数](#复数)
  - [逻辑](#逻辑)
  - [字符](#字符)
  - [字符串](#字符串)
    - [模板字符串](#模板字符串)
    - [原始字符串（Raw String）](#原始字符串raw-string)
    - [多行字符串](#多行字符串)
  - [二进制](#二进制)
  - [符号](#符号)
  - [正则](#正则)

<!-- /code_chunk_output -->

## 整数

整数的数据类型有：

* `整数64`（`Int64`）
* `整数32`（`Int32`）
* `整数16`（`Int16`）
* `整数8`（`Int8`）
* `整数`（`Int`），为 `整数64` 的别名。

类型后面的数字表示位宽，位宽决定能存储数字的范围，整数类型的比特（bit）最高有效位（MSB）用于表示符号（正负号），所以有一半用于表示负数，有一半表示正数。另外所有位全 1 表示 -1，所以负数的个数会比整数多 1 个，另外所有位全 0 表示 0 一般会跟正数一起用于表达无符号整数（即自然数）。

比如 8 位整数 `整数8` 能表示：

* \(-2^7\) 到 \(-1\) 共 128 个数；
* \(0\) 到 \(+2^7 - 1\) 共 128 个数。

加在一起总共能表示 \(2^8\) 即 256 个数。

## 自然数

除了能表示正负数的整数类型（即有符号整数），还有只能表示正整数和零的，这种类型叫做无符号整数（Unsigned Integer），为简单起见 XiaoXuan 把该数据类型命名为 `自然数`（`Natural`）：

* `自然数64`（`Natural64`）
* `自然数32`（`Natural32`）
* `自然数16`（`Natural16`）
* `自然数8`（`Natural8`）
* `自然数`（`Natural`），为 `自然数64` 的别名。

自然数的所有比特位都用于表示数值，所以能表示 \(2^N\) （N 为位宽） 个数字。比如 8 位自然数 `自然数8` 能表示 0 到 \(2^8\) 即 256 共 256 个数字。

整数的字面量（即直接写在源码里的数据，硬编码数据）如 `123`，`1000` 等，默认类型为 `整数`，也就是 `整数64`。

<!-- 不支持 -- 可以在字面量前面添加括号和类型名称以指定数据的类型，比如 `(Natural32)321` 表示 `自然数32` 类型。 -->

XiaoXuan 支持下列整数字面量的写法：

* 支持在**数字之间**任意位置或者**末尾**插入任意数量下划线以表示分组，如 `123_000`，`4_56_7`，`12_34__56___` 等都是有效的整数字面量，但 `_123` 不是有效的整数字面量。
* 支持添加前缀 `0x`, `0b`，分别表示 16 进制和 2 进制，如 `0xff0011`，`0b1010`，`0b0000_1111`、`0x_a__b___c`。

## 实数

在 XiaoXuan 中，实数是指一定有小数部分的实数，一般也称为浮点数（Float）。实数的数据类型有：

* `实数64`（`Real64`）
* `实数32`（`Real32`）
* `实数`（`Real`） （为 `实数64` 的别名）。

实数字面量如 `3.14159`、`2.71828`、`123.4`、`1.23e4`、`-1.23e4`、`1.23e-4`，默认类型为 `实数`，即 `实数64`。

可以在字面量前面添加括号和类型名称以指定数据的类型，比如 `(Real32)321` 表示 `实数32` 类型。

XiaoXuan 支持下列实数字面量的写法：

* 支持在**数字之间**任意位置或者**末尾**插入任意数量下划线以表示分组，如 `1_234.56`、`12_.34__` 都是有效的实数字面量，但 `_12.34`、`12._34` 都不是有效的实数字面量。
* 支持 [IEEE 745-2008 标准](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)，实数包含正无穷、负无穷、正零、负零、还有一个 NaN（非数字）。正无穷 == 正无穷，负无穷 == 负无穷，NaN 跟任何数比较都不相等，包括跟自己比较也是不相等，即 NaN != NaN，而 (NaN != x) 总是返回 true。详细见 [IEEE 745](https://en.wikipedia.org/wiki/IEEE_754) 和 [NaN](https://en.wikipedia.org/wiki/NaN)。

## 有理数

有理数的数据类型是 `有理数`（`Rational`）。字面量使用符号 `//` 分隔分子和分母，分子和分母必须是整数（对应 XiaoXuan 的 `整数` 和 `自然数` 这两种类型）。

示例：

```julia
让 i = 2 // 3
让 j = 1 // 2
让 k = i + j        # k == 7 // 6
```

```julia
let i = 2 // 3
let j = 1 // 2
let k = i + j        # k == 7 // 6
```

符号 `//` 前后的空格可有可无。

有理数也可以使用构造函数构建：

```julia
让 i = 有理数(2, 3)  # 2//3
让 j = 有理数(1, 2)  # 1//2
让 k = i + j        # k == 7//6
```

```julia
let i = Rational(2, 3)  # 2//3
let j = Rational(1, 2)  # 1//2
let k = i + j        # k == 7//6
```

为了避免分子分母跟表达式的其他数据混淆，可以使用一对括号把有理数包围起来。

示例：

`let i = (2//3) / 2`

实际上符号 `//` 是运算符，所以该符号前后可以是字面量，也可以是变量。

示例：

```julia
let i = 123
let j = 456
let k = i // j  # k == 123//456
```

## 复数

复数的数据类型是 `复数`（`Complex`），字面量使用格式 `X + Yi` 的格式表示，其中的 `+` 和 `i` 是固定格式，`X` 和 `Y` 是实数，分别表示复数的实部和虚部，对于 XiaoXuan 来说，`X` 和 `Y` 可以是 `整数`、`自然数` 或者 `实数` 的字面量。

示例：

```julia
let i = 3+4i
let j = 1+4i
let k = i+j     # k == 4+8i
```

其中实部可以省略，表示实部为 0 的纯虚数。

示例：

```julia
let i = 4i
let j = 3.45i
```

需要注意的是，复数字面量当中的符号 `+` 不表示加法，而是固定的格式，也就是说实部和虚部的数字都必须是字面量，而不能是变量。

示例：

```julia
let n = 123
let i = n + 4i  # `+` 号前面不是数字字面量
let j = 4 + ni  # `i` 前面不是数字字面量
```

上面例子都无法构建出复数。

复数也可以使用构造函数构建。

示例：

```julia
let i = Complex(3, 4) # 3+4i
let j = Complex(1, 4) # 1+4i
let k = i+j           # k == 4+8i
```

为了避免复数的实部跟表达式的其他数据混淆，可以使用一对括号把复数字面量包围起来。

示例：

`let i = 2 * (3+4i)`

注意复数只能作相等比较而不能作大小比较，参见[复数的介绍](https://en.wikipedia.org/wiki/Complex_number)。

## 逻辑

逻辑数据只有两个值：`真`（`true`）和 `假`（`false`），逻辑数据的数据类型是 `逻辑`（`Boolean`）。逻辑数据一般用在条件语句，用于判断条件是否成立。

XiaoXuan 不支持逻辑数据跟数字（整数、自然数、实数等）相互转换，也不支持跟字符、字符串、列表等等任何数据类型相互转换。有些编程语言用 0 表示 `假`，用非 0 表示 `真`，或者空字符串、空列表表示 `假`，非空字符串、非空列表表示 `真` 等等，XiaoXuan 皆不支持，也就是说条件语句只接受逻辑类型的值。

示例：

```julia
让 i = 123
如果 i 那么 # 这行会引起运行时错误
    ...
以上
```

## 字符

字符是用于显示的单个字母、数字或者汉字等，字符的数据类型是 `字符`（`Char`），字符字面量使用单引号（'）包围一个字符，比如 'a', '8', '中' 等。

有些字符无法用直接字面量表示，需要使用特殊的方式来表示，具体来说是使用一个反斜杠加一个字符的方式来转义。这些字符有：

* `'\t'`：制表符 ASCII 9
* `'\n'`：换行符 ASCII 10
* `'\r'`：回车符 ASCII 13
* `'\\'`：反斜杠
* `'\''`：单引号

字符字面量也支持使用 16 进制的 Unicode 码点表示，有两种格式：

* `'\xHH'`：用于表示从 U+0000 到 U+007F 之间的字符；
* `'u{HHHHHH}'`：用于表示从 U+0000 到 U+D7FF 以及从 U+E0000 到 U+10FFFF 之间的字符。

有一些常用的但较难输入的字符，比如希腊字母可以通过常量 `希腊字母`（`GreekLetter`），比如 `GreekLetter.alpha` 的值为 \(\alpha\)，即字符 'α'，`GreekLetter.omega` 的值为 \(\omega\)，即字符 'ω'。详细可以参见[希腊字母列表](https://en.wikipedia.org/wiki/Greek_alphabet)，以及希腊字母对应的[中文读音](https://zh.wikipedia.org/zh-cn/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D)。

字符在运行环境内部使用 `自然数32`（`Natural32`） 来存储。但字符类型不能跟 `自然数32` 或者其他整数类型直接相互转换，因为部分整数不是有效的 Unicode。

## 字符串

字符串即一串字符，字符串类型为 `字符串`（`String`），字符串字面量使用双引号（"）包围一串字符，如 `"abc"`，`"你好"`。

在字符串字面量里，有些字符也是需要转义，这些字符有：

* `"\t"`：制表符
* `"\n"`：换行符
* `"\r"`：回车符
* `"\\"`：反斜杠
* `"\""`：双引号

在运行环境内部，`字符串` 是 `数组<字符>`（`Array<Char>`）类型的别名。

### 模板字符串

模板字符串是指允许在字符串中间插入其他数据的字符串，模板字符串同样使用双引号包围，但需要在第一个双引号之前添加一个感叹号。

示例：

* `!"你好, {名字}"`
* `!"hello, {name}"`

其中 `{...}` 为模板字符串占位符，占位符里面可以是其他数据的字面量，可以是一个变量，也可以是一个表达式，甚至可以是一段有返回值的语句。

模板占位符支持格式化，在数据之后添加一个冒号 `:`，然后加上格式表达式。

示例：

* `{name:15}`：name 是一个字符串变量，表示字符串最小宽度为 15 个字符（不足 15 个字符会在右侧补空格）；
* `{name:.6}`：name 是一个字符串变量，表示限制字符串最大宽度为 6 个字符，超出 6 个的字符直接被截断。

XiaoXuan 使用跟 Rust 一样的字符串格式化表示方式，可以参考《Programming Rust》 P337 "格式化值" 一节。

### 原始字符串（Raw String）

原始字符串即原样表示的字符串，在源码当中原始字符串是怎样的呈现，其值就是怎样。即原始字符串不会对其中的内容进行转义。

原始字符串字面量使用三个双引号包围一串字符。

示例：

* `"""你好\😄/"""`
* `"""hello\😄/"""`

在书写正则表达式时，使用原始字符串能避免频繁转义表达式内部的特殊字符。

示例：

```js
01  # 为了匹配类似 `\"123"/` 这样的字符串
02  let s1 = Regex("^\\\\\\"\\d{3}\\"\/$")
03  let s2 = Regex("""^\\"\d{3}"\/$""")
```

上面例子中 02 行使用普通字符串格式，03 行使用原始字符串格式，它们的值相同。

### 多行字符串

使用三个双引号还能用于表示多行字符串的字面量。

示例：

```js
01  """
02  世界
03    你好
04  """
```

```js
01  """
02  hello
03    world
04  """
```

其中首尾两行（即 01 行和 04 行）为固定格式，"首行的末尾" 和 "尾行的前面" 不能有其它字符，或者只有空白字符。尾行必须单独一行。

首尾两行之间为正文部分。正文部分的第一行（即上面例子的 02 行）的第一个非空白字符表示正文的开始，正文部分其他行的前缀空白字符会根据正文部分第一行的前缀空白个数**自动截除**（空白字符不足的话会抛出运行时异常）。正文部分最后一行的末尾换行符不会被纳入正文。所以上面示例的字符串的值为 `世界\n🈳🈳你好`（`"hello\n🈳🈳world"`）。

示例：

```js
let text = """
    hello
      world
    """
```

上例中正文部分的第一行前面有 4 个空格，这部分不会被纳入正文，正文部分的第二行开始，会自动被裁剪 4 个空格，所以这个字符串的值跟前一例子一样，都是 `"hello\n🈳🈳world"`。

多行字符串格式不会对其中的字符进行转义，只要遇到单独一行 3 个连续双引号（不管前后是否有空白）即表示字符串结束。

## 二进制

二进制数据类型是 `二进制`（`Binary`），跟整数的二进制字面量不一样，`二进制` 是单独的一种类型，而不是整数。`二进制` 字面量使用 `位宽 + ' + 数制符号 + 数值` 的格式表示。

示例：

```js
let a = 8'b0000_1111
let b = 8'h0F
let c = 8'd15
let d = 8'15
```

二进制值可以使用范围值读取其中的部分值，示例：

```js
let a = 8'b0000_1111
let b = a[3:6]
```

上例中的 `[3:6]` 表示从第 3 位开始（二进制数字字面量最右边为第 1 位，即最低有效位，从 1 开始数），取 6 位比特，结果变量 `b` 的值为 `6'000011`。

## 符号

`符号`（`Symbol`）类型的数据用于生成一个代号，代号可以用作代数的变量。符号类型数据没有字面量，只能通过构造函数构建。

示例：

```js
让 x = 符号('x')
让 x_alt = 符号("x'")
让 x1 = 符号("x1")
让 y = 符号('y')
```

```js
let x = Symbol('x')
let x_alt = Symbol("x'")
let x1 = Symbol("x1")
let y = Symbol('y')
```

`符号` 构造函数接受一个字符或者一个字符串，上面代码分别生成了符号 \(x\)，\(x'\)，\(x1\) 和 \(y\)。

常数 `希腊字母符号`（`GreekLetterSymbol`） 列出了从 α 到 ω 的 `符号` 实例。比如 `GreekLetterSymbol.beta` 的值为 `Symbol('β')`。

符号实例可以通过 `下标`（`subscript`）方法添加下标。

示例：

```js
let a = Symbol('a')
let a1 = a.subscript('1')
```

变量 `a1` 的值就是 \(a_1\)，注意它的值跟由字符串 `a1` 构成的符号实例是不相同的。

构造时传入相同的字符或者字符串而产生的两个符号数据的值相等，符号数据的值可以用其包含的字符串表示，但不能跟字符串直接比较，也无法排序。

符号数据可以用于产生算式对象。

示例：

```js
let z = x^2 + 2*x*y + y^2
```

上面例子的变量 `z` 的值为一个算式，其值为：

$$
z = x^2 + 2xy + y^2
$$

示例：

```js
let x = Symbol('x')
let N = 100
let y = sum([1..N].map(fn (n) x ^ n / n))
```

上面的代码会产生如下算式：

$$
y = \frac{x^1}{1} + \frac{x^2}{2} + \frac{x^3}{3} + \cdots + \frac{x^n}{n}
$$

算式对象可以用于计算值，也可以用于解方程，求微分和积分等，可以参考 [SymPy 函数库](https://www.sympy.org/en/)。

## 正则

字面量格式 `/正则表达式/选项`

```js
let r1 = /[a-zA-Z]+/i
let m1 = r1.match("hello world");
```

正则构造函数 `Regex(String, Options)`

// TODO::
