# 基本数据类型

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [基本数据类型](#基本数据类型)
  - [整数数字](#整数数字)
  - [浮点数字](#浮点数字)
  - [有理数](#有理数)
  - [复数](#复数)
  - [逻辑](#逻辑)
  - [字符](#字符)
  - [字符串](#字符串)
    - [模板字符串](#模板字符串)
    - [原始字符串（Raw String）](#原始字符串raw-string)
    - [多行字符串](#多行字符串)
  - [二进制](#二进制)
  - [符号](#符号)

<!-- /code_chunk_output -->

## 整数数字

类型名称有：

* `整数64`（`Int64`）
* `整数32`（`Int32`）
* `整数16`（`Int16`）
* `整数8`（`Int8`）
* `整数`（`Int`），为 `整数64` 的别名

另外有无符号整数型（Unsigned Integer）：

* `无符号整数64`（`UInt64`）
* `无符号整数32`（`UInt32`）
* `无符号整数16`（`UInt16`）
* `无符号整数8`（`UInt8`）
* `无符号整数`（`UInt`），为 `无符号整数64` 的别名

字面量（即直接写在源码里的数据，也叫做硬编码数据）如 `123`，`1000` 等，默认类型为 `整数`，也就是 `整数64`。

* 支持在数字之间插入下划线以表示分组，如 `123_000`，`4_23_4` 等。
* 支持添加前缀 `0x`, `0b` 分别表示 16 进制和 2 进制，如 `0xff0011`，`0b0000_1111`，

## 浮点数字

类型名称有：

* `浮点数64`（`Float64`）
* `浮点数32`（`Float32`）
* `浮点数`（`Float`） （为 `浮点数64` 的别名）

字面量如 `3.14159`，`2.71828`， `123.45654`，`1.23e4`，`345.6e-22`，默认类型为 `浮点数`，即 `浮点数64`。

* 支持在数字之间插入下划线以表示分组，如 `1_234.56`。
* 支持 IEEE 745-2008 标准，即包含正负无穷、区分正负零、还有一个NaN。（见 Programming Rust P40）

## 有理数

类型名称是 `有理数`（`Ratio`）。字面量使用 "//" 分隔分子和分母。

示例：

```julia
let i = 2 // 3
let j = 1 // 2
let k = i + j        # k == 7 // 6
```

也可以使用构造函数构建：

```julia
let i = Ratio(2, 3)  # 2//3
let j = Ratio(1, 2)  # 1//2
let k = i + j        # k == 7//6
```

为了避免分子分母跟表达式的其他数据混淆，可以使用一对括号把有理数包围起来，例如：

`let i = (2//3) / 2`

## 复数

类型名称是 `复数`（`Complex`），字面量使用 `a + bim` 的格式表示。

示例：

```julia
let i = 3+4im
let j = 1+4im
let k = i+j     # k == 4+8im
```

也可以使用构造函数构建：

```julia
let i = Complex(3, 4) # 3+4im
let j = Complex(1, 4) # 1+4im
let k = i+j           # k == 4+8im
```

为了避免复数的实部跟表达式的其他数据混淆，可以使用一对括号把复数包围起来，例如：

`let i = 2 * (3+4im)`

## 逻辑

类型名称是 `逻辑`（`Boolean`），该类型只有两个值 `真` （`true`）和 `假`（`false`）。

逻辑数据用于条件语句。不支持逻辑跟整数（浮点数、字符、字符串、列表等等其他类型数据）直接相互转换，也就是说条件语句只接受逻辑型的值，下面的语句会引起运行时错误：

```js
让 i = 123
如果 i 那么
    ...
以上
```

## 字符

类型名称为 `字符`（`Char`），字符字面量使用单引号（'）包围一个文字，如 'a', '8', '中' 等。

需要转义的字符：

* '\''：单引号
* '\\'：反斜杠
* '\n'：换行符
* '\r'：回车符
* '\t'：制表符

支持使用 16 进制的 Unicode 码点表示法：

* '\xHH'：表示从 U+0000 到 U+007F 之间的字符
* 'u{HHHHHH}'：表示从 U+0000 到 U+D7FF 以及从 U+E0000 到 U+10FFFF 之间的字符。

每个字符内部使用 `无符号整数32`（`UInt32`） 存储。但字符型跟整数型不能直接相互转换（因为部分整数不是有效的 Unicode）。

## 字符串

类型名为 `字符串`（`String`），字符串字面量使用双引号（"）包围，如 "abc"，"你好" 等。字符串是 `数组<字符>`（`Array<Char>`） 类型的别名。

在字符串字面量内需要转义的字符：

* "\""：双引号
* "\\"：反斜杠
* "\n"：换行符
* "\r"：回车符
* "\t"：制表符

### 模板字符串

模板字符串同样使用双引号包围，但在第一个双引号之前添加一个感叹号，如：

* `!"你好, {名字}"`
* `!"hello, {name}"`

其中 "{...}" 为模板字符串占位符，占位符的内容一般是模板字符串所在作用域之内的有效变量的名称，也可以是一个有效的表达式。

模板占位符支持格式化，使用 ":" 符号（一个冒号）分隔值表达式和格式表达式。

比如 "{name:15}" 表示字符串最小宽度为 15 个字符（不足 15 个字符会在右侧补空格），"{name:.6}" 表示限制字符串最大宽度为 6 个字符，超出 6 个的字符直接被截断。详细格式化列表参考 “格式化值” 一节。（也可参考 《Programming Rust》 P337）

### 原始字符串（Raw String）

原始字符串使用三个双引号包围字面量，如：

* `"""你好😄"""`
* `"""hello😄"""`

原始字符串不支持转义字符（同时也意味着不能在原始字符串里表示 3 个连续双引号）。

在书写正则表达式时，使用原始字符串能避免表达式特殊字符的频繁转义。

### 多行字符串

多行字符串使用三个双引号包围字面量，如：

```js
01  """
02  世界
03    你好
04  """
```

```js
01  """
02  hello
03    world
04  """
```

其中首尾两行为固定格式，"首行的末尾" 和 "尾行的前面" 不能有其它非空白字符。

首尾两行之间的为正文。正文的第一行（即上面示例的 "02" 行）的第一个非空白字符表示正文的开始，正文其他行的**前缀空白字符**会根据正文第一行的前缀空白个数**自动截除**。正文最后一行的末尾换行符会被自动截除。所以上面示例的字符串的值为 `世界\n🈳🈳你好`（`"hello\n🈳🈳world"`）。

多行字符串格式不会对其中的字符进行转义，只要遇到单独一行 3 个连续双引号（不管前后是否有空白）即表示字符串结束。

## 二进制

`二进制`（`Binary`）二进制是一种数据类型（跟整数的二进制字面量不一样，后者是整数类型）。二进制字面量使用 `位宽 + ' + 数制符号 + 数值` 的方法表示。

示例：

```js
let a = 8'b0000_1111
let b = 8'h0F
let c = 8'd15
let d = 8'15
```

二进制数据可以使用范围值读取部分值，示例：

```js
let a = 8'b0000_1111
let b = a[3:6]
```

上例中的 `[3:6]` 表示从第 3 位开始（二进制数字最右边为第一位，即最低位，最左边为最高位），取 6 位比特，结果 `b` 的值为 `6'000011`。

## 符号

`符号`（`Symbol`）用于生成一个代号，代号可以用作代数的变量。

示例：

```js
let x = Symbol('x')
let y = Symbol('y')
let z = x^2 + 2*x*y * y^2
```

上面例子的变量 `z` 的值为一个算式，其值为：

$$
z = x^2 + 2xy + y^2
$$

示例：

```js
let x = Symbol('x')
let N = 100
let y = sum([1..N].map(fn (n) x ^ n / n))
```

上面的代码会产生如下算式：

$$
y = \frac{x^1}{1} + \frac{x^2}{2} + \frac{x^3}{3} + \cdots + \frac{x^n}{n}
$$

算式对象可以用于传入参数（使用实际数据代替符号），也可以用于解方程等。
