# 共性

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [共性](#共性)
  - [数据的方法](#数据的方法)
    - [静态方法](#静态方法)
      - [构造函数](#构造函数)
    - [实例方法](#实例方法)
    - [使用点号调用实例方法](#使用点号调用实例方法)
  - [范型](#范型)
    - [类型具体化](#类型具体化)
    - [范型函数](#范型函数)
    - [范型的类型自动推导](#范型的类型自动推导)
    - [范型数据的方法](#范型数据的方法)
    - [范型数据方法当中包含其他范型](#范型数据方法当中包含其他范型)
  - [共性](#共性-1)
    - [定义共性](#定义共性)
    - [赋予共性给数据类型](#赋予共性给数据类型)
    - [共性中的空方法](#共性中的空方法)
    - [`派生` 标注](#派生-标注)
    - [内置共性](#内置共性)
    - [为范型函数添加共性约束](#为范型函数添加共性约束)
      - [为范型数据方法添加共性约束](#为范型数据方法添加共性约束)

<!-- /code_chunk_output -->

## 数据的方法

除了一般用途的函数（即在模块范围内定义的函数），还有一些函数是专门为某些数据类型所使用的。即某个函数跟某个数据类型紧密相关，而跟其他数据类型则关系不大。XiaoXuan 称这种函数为 "数据的关联方法"（"Data association method"），或者简称 `方法`（`method`）。

使用 `赋予`（`assign`）语句可以为指定的数据类型添加方法，方法又可以分为 "静态方法" 和 "实例方法" 两种。

### 静态方法

为数据类型添加静态方法的语法是：

```js
赋予 类型名称
    函数 返回值数据类型 函数名称 (数据类型1 参数1, 数据类型2 参数2, ...)
        ...
    以上
以上
```

```js
assign DataTypeName
    function ReturnDataType functionName (DataType1 param1, DataType2 parsm2)
        ...
    end
end
```

静态方法就是一般的函数，对函数的名称、参数列表、返回值的数据类型都**没有**特殊的要求，仅要求定义在数据类型的 `赋予` 语句范围内；同时要求在调用这类函数时，需要添加其所属的数据类型的名称。调用静态方法的语法是：

* `数据类型名称.方法名称 (参数值1, 参数值2, ...)`
* `DataTypeName.functionName (value1, value2, ...)`

示例：

现有结构体 `学生`（`Student`），要添加一个静态方法 `转换自`(`convertFrom`)，以实现从 `用户`（`User`） 类型数据转换到 `学生` 类型。代码如下：

```js
结构体 学生
    整数 编号
    字符串 姓名
以上

赋予 学生
    函数 学生 转换自 (用户 u)
        新建 学生 (u.编号, u.姓名)
    以上
以上
```

```js
struct Student
    Int id
    String name
end

assign Student
    function Student convertFrom (User u)
        new Student (u.id, u.name)
    end
end
```

调用该方法的代码如下：

* `让 s1 = 学生.转换自(u1)`
* `let s1 = Student.convertFrom(u1)`

#### 构造函数

在结构体一章提到，其实构造函数就是数据类型的静态方法，其名称为 `新建`（`new`），运行环境会自动为每个构造体生成一个默认的构造函数。比如上例的 `学生` 结构体，其自动生成的构造函数如下：

```js
赋予 学生
    学生 新建 (整数 编号, 字符串 姓名)
        // 运行环境的内部代码
    以上
以上
```

```js
assign Student
    Student new (Int id, String name)
        // the runtime internal code here
    end
end
```

实例化一个结构体的代码如下：

* `让 s = 学生.新建 (123, "foo")`
* `let s = Student.new (123, "foo")`

XiaoXuan 提供了一个语法糖，可以使用 `新建`（`new`）关键字来调用与 数据关联的 `新建` 方法：

* `让 s = new 学生 (123, "foo")`
* `let s = new Student(123, "foo")`

### 实例方法

实例方法跟静态方法类似，只是要求函数的**第一个参数**的数据类型为其所属的数据类型。为了避免重复写数据类型，XiaoXuan 使用一个专门的数据类型名称 `自我`（`Self`）代表实例方法所属的数据类型。

比如要在上例的 `学生` 结构体里添加一个 `显示姓名`（`showName`）的实例方法，用于显示学生的姓名，则代码如下：

```js
赋予 学生
    函数 空型 显示姓名 (自我 s)
        输出行 (""我的名字是 {s.name}"")
    以上
以上
```

```js
assign Student
    function Void showName(Self s)
        writeLine(""My name is {s.name}"")
    end
end
```

调用实例的方法也跟静态方法类似，只需把数据实例作为第一个参数传入方法即可。

示例：

```js
让 s = 新建 学生 (123, "foo")
学生.显示姓名 (s)
```

```js
let s = new Student (123, "foo")
Student.showName (s)
```

需注意：

* 虽然上例的方法只有一个参数，而实际上实例方法跟普通的方法一样，是允许有多个参数的，只需第一个参数的数据类型为其所属的数据类型即可。
* 上例中的 `自我`（`Self`）代表着 `Student` 这个数据类型，虽然作用和意义完全一样，但为了统一起见，XiaoXuan 推荐使用 `自我` 代替所有自身数据类型，而不建议直接写具体的数据类型（比如 `Student`）。

### 使用点号调用实例方法

对于实例方法，除了可以使用 `数据类型名称.方法名称 (数据实例, 参数值1, ...)` 这种常规的调用格式之外，还支持使用 `数据实例.方法名称 (参数值1, ...)` 这种点号调用格式。

因为使用点号调用格式更简洁，所以一般情况下优先考虑使用。

示例，下面的两个语句是等同的。

```js
01  学生.显示姓名 (s)
02  s.显示姓名 ()
```

```js
01  Student.showName (s)
02  s.showName ()
```

## 范型

范型（Generic）用于减少仅数据类型不同的重复代码，可以在结构体、联合体、函数上应用范型。

示例，有如下两个结构体：

```js
结构体 整数点坐标
    整数 x
    整数 y
以上

结构体 浮点数点坐标
    浮点数 x
    浮点数 y
以上
```

```js
struct IntPoint
    Int x
    Int y
end

struct FloatPoint
    Float x
    Float y
end
```

它们的结构一样，仅数据类型不同，可以使用范型改写，代码如下：

```js
结构体 点坐标<甲型>
    甲型 x
    甲型 y
以上
```

```js
struct Point<T>
    T x
    T y
end
```

其中一对尖括号里面列出该结构体（或者联合体、函数）所有使用到的类型的代号（简称 "类型代号"）。然后把尖括号写在结构（或联合体、函数）名称之后。

类型代号中文一般使用 "甲型"、"乙型"、"丙型"、"丁型"，或者直接使用 "甲、乙、丙、丁、戊、己、庚、辛、壬、癸"，英文则使用单个大写的字母，比如 "T"、"E"、"R"、"M" 等，在语法上代号的写法无特殊的要求，只是传统上使用这样的写法。多个类型代号之间使用逗号分隔，比如 `结构体<甲, 已, 丙> 点坐标`。

### 类型具体化

在实例化带有范型的结构体时，将实际的数据类型替代类型代号，我们将这个过程称之为**类型具体化**。

示例：

```js
让 p1 = 新建 点坐标<整数> (10, 20)
让 p2 = 新建 点坐标<浮点数> (2.718, 1.618)
```

```js
let p1 = new Point<Int> (10, 20)
let p2 = new Point<Float> (2.718, 1.618)
```

### 范型函数

范型也可以应用在函数上，跟应用到结构体类似，也是在一对尖括号列出该函数所有用到的数据类型。示例：

```js
函数 最大值<甲型>(甲型 左, 甲型 右)
    如果 左 > 右 那么
        左
    否则
        右
    以上
以上
```

```js
function max<T>(T left, T right)
    if left > right then
        left
    else
        right
    end
end
```

在调用范型函数时，将实际数据类型替代类型代号，示例：

```js
让 a = 最大值<整数> (12, 34)
让 b = 最大值<浮点数> (3.142, 2.718)
```

```js
let a = max<Int> (12, 34)
let b = max<Float> (3.142, 2.718)
```

### 范型的类型自动推导

XiaoXuan 的自动类型推导机制在范型里同样有效，也就是说，在实例化范型结构体、调用范型函数时，运行环境会尽可能地推导出正确的数据类型，而在写代码时就可以省略类型了。

示例，上面的实例化结构体和调用函数可以写成如下：

```js
让 p1 = 新建 点坐标 (10, 20)
让 p2 = 新建 点坐标 (2.718, 1.618)
让 a = 最大值 (12, 34)
让 b = 最大值 (3.142, 2.718)
```

```js
let p1 = new Point (10, 20)
let p2 = new Point (2.718, 1.618)
let a = max (12, 34)
let b = max (3.142, 2.718)
```

上面的代码都省略了具体的数据类型。因为在实例化结构体（或者调用函数）时，运行环境会根据成员（参数）传入的实际数据（实参）来推导其数据类型，然后将这个数据类型替换类型代号，再使用这个类型代号应用到整个结构体（或函数），如此类推。

### 范型数据的方法

在为具有范型的数据赋予方法时，需要注意是赋予给具体的某个数据类型，还是赋予给范型。比如上例的 `点坐标<甲型>`，现在需要添加 `显示坐标`（`showPoint`）实例方法，注意下面的两个赋予语句。

```js
赋予 点坐标<整数>
    函数 显示坐标(自我 p)
        ...
    以上
以上

赋予<甲型> 点坐标<甲型>
    函数 显示坐标(自我 p)
        ...
    以上
以上
```

```js
assign Point<Int>
    function showPoint(Self p)
        ...
    end
end

assign<T> Point<T>
    function showPoint(Self p)
        ...
    end
end
```

上面两个赋予语句非常相似，第二个仅仅在 `赋予` 关键字多了 "<甲型>"，但它们的意义完全不一样：

* 第一个赋予语句仅仅为 `点坐标<整数>` 这种整数类型点坐标赋予了 `显示坐标` 方法，`自我` 代表的是 `点坐标<整数>` 这种特定类型；
* 第二个赋予语句则为 `点坐标` 范型（即任意具体类型的点坐标）赋予 `显示坐标` 方法，`自我` 代表的是 `点坐标<甲型>` 这种范型。

也就是说，如果要为结构体范型赋予方法，则需要在 `赋予` 关键字后面同样加上一对尖括号，然后把所有用到的类型代号列出。

注意第一个赋予语句不能写成 `赋予 点坐标<甲型>`，因为 XiaoXuan 不知道这个 `甲型` 究竟是具体数据类型的名称，还是类型代号。如果确实存在一个名字为 "甲型" 的数据类型，则这个赋予语句是合法的，如果不存在，则会抛出运行时错误。

### 范型数据方法当中包含其他范型

有时在方法当中会传入其他范型的数据，这些额外的范型只需在方法的类型代号列表中列出即可，而不需要在 `赋予` 关键字后面的类型代号列表中列出。

示例，现在添加 `加`（`add`）方法到 `点坐标` 结构体，该方法接受另外一个点坐标类型的参数，但不要求这个点坐标的类型跟当前点坐标类型一致，代码如下：

```js
赋予<甲型> 点坐标<甲型>
    函数 自我 加<甲型, 乙型> (自我 left, 点坐标<乙型> right)
        新建 自我 (
            left.x + right.x,
            left.y + right.y
            )
    以上
以上
```

```js
assign<T> Point<T>
    function Self showPoint<T, E> (Self left, Point<E> right)
        new Self(
            left.x + right.x,
            left.y + right.y
            )
    end
end
```

注意：

* 代码中，`赋予` 后面的类型代号列表只有 `甲型`，表明这个赋予语句是只针对 `点坐标<甲型>`，而方法名称后面的类型列表里有 `甲型` 和 `乙型`，说明这个方法将会使用到 `甲型` 和 `乙型` 两种数据类型。
* 代码中的 `新建 自我`（`new Self`）是合法的，在上例中，它代表着 `新建 点坐标<甲型>`（`new Point<T>`）。

## 共性

`共性`（`trait`）是指多个类型数据共同具有的特性、或者共同具有的行为。

比如部分数据具有一个叫做 `可显示`（`Display`） 的共性，表示这类数据可以转换为字符串并提供给诸如 `输出行`（`writeLine`）等函数使用；又比如部分数字类型数据具有一个叫做 `可排序`（`Ordered`）的共性，表示这类数据可以通过 `>`、`>=`、`<`、`<=` 等函数进行大小比较。

共性在具体实现上，就是一组函数。

### 定义共性

使用 `共性`（`trait`）关键字可以定义一个共性。

示例，假设有两个结构体 `用户`（`User`） 和 `学生`（`Student`），其都有一个名为 `姓名`（`name`）的成员。现要为它们都添加一个名为 `显示姓名`（`showName`） 的方法，则可以定义一个名字比如 `具名`（`Named`）的共性:

```js
共性 具名
    函数 显示名字(自我 s)
        输出行 (s.姓名)
    以上
以上
```

```js
trait Named
    function showName(Self s)
        writeLine (s.name)
    end
end
```

因为共性会被赋予给具体的数据类型，所以跟数据的实例方法类似，函数的第一个参数必须是其所属的数据的类型，但在定义共性时不知道它最后会被应用到哪个数据类型，所以使用 `自我`（`Self`）来代表将来会被应用到的数据类型。

需注意：共性或者目标数据类型的定义，至少有一项必须在当前模块范围之内。也就是说，如果某个共性和某个数据类型都是在其他模块，你是无法把那个共性赋予给那个数据类型的。

### 赋予共性给数据类型

示例：

赋予 `具名` 这个共性给结构体 `用户`（`User`） 和 `学生`（`Student`）：

```js
赋予 具名 到 用户
    // 这里无代码
以上

赋予 具名 到 学生
    // 这里无代码
以上
```

```js
assign Named to User
    // no code here
end

assign Named to Student
    // no code here
end
```

之后 `用户` 和 `学生` 示例都具有 `显示名字` 方法。

示例：

```js
让 u = 新建 用户(123, "foo")
让 s = 新建 学生(456, "bar")
u.显示名字()
s.显示名字()
```

```js
let u = new User(123, "foo")
let s = new Student(456, "bar")
u.showName()
s.showName()
```

需注意，可以赋予一个或多个共性给一个数据类型，换句话说，一个数据类型可以具有一个或多个共性。但每个共性都要使用 `赋予` 语句赋予到指定的数据类型。

### 共性中的空方法

有时我们可以确定共性的方法签名，但暂时还无法确定函数主体的具体实现代码，这时可以在共性里定义 "空函数"（或者说 "空方法"），然后等到在赋予共性给数据类型的过程再写函数的具体实现代码。

"空函数" 跟普通函数一样，除了：

1. 函数没有主体代码；
2. 定义函数的语句最签名添加 `空`（`empty`） 关键字。

示例，现在在上例中的 `具名` 共性中添加 `显示摘要`（`showSummary`）方法：

```js
01  共性 具名
02      函数 显示名字(自我 s)
03          输出行 (s.姓名)
04      以上
05
06      空 函数 显示摘要(自我 s)
07  以上
```

```js
01  trait Named
02      function showName(Self s)
03          writeLine (s.name)
04      end
05
06      empty function showSummary(Self s)
07  end
```

上面代码的 06 行即空方法。

在赋予共性给数据类型时，需要把空方法的主体补上，示例：

```js
赋予 具名 到 用户
    函数 显示摘要(自我 s)
        输出行 (""我是用户，编号： {s.id}，姓名： {s.name}"")
    以上
以上

赋予 具名 到 学生
    函数 显示摘要(自我 s)
        输出行 (""我是学生，编号： {s.id}，姓名： {s.name}"")
    以上
以上
```

```js
assign Named to User
    function showSummary(Self s)
        writeLine(""I'm User, id: {s.id}, name: {s.name})"")
    end
end

assign Named to Student
    function showSummary(Self s)
        writeLine(""I'm Student, id: {s.id}, name: {s.name})"")
    end
end
```

### `派生` 标注

当赋予一个全部方法都**非空**的共性给一个数据类型时，除了使用 `赋予` 语句，还可以简单地使用 `派生`（`derive`） 标注直接在数据类型（比如结构体）上标注，使用标注的好处是避免写一个空主体的 `赋予` 语句，下面使用标注的方法重写前面第而个例子：

```js
@派生(具名)
结构体 学生
    整数 编号
    字符串 姓名
以上
```

```js
@derive(Named)
struct Student
    Int id
    String name
end
```

如果要赋予多个共性给一个数据类型，则在 `派生` 标注内，把所有共性名称列出，并使用逗号 "," 分隔每个共性名称。

示例：

```js
@派生(具名, 可显示, 可相等比较, 可大小比较)
结构体 学生
    整数 编号
    字符串 姓名
以上
```

### 内置共性

有一些运行环境内置的共性，比如 `可显示`（`Display`）、`可转字符串`（`ToString`）、`可相等比较`（`Equal`）等，当赋予一个结构体时，如果该结构体里的所有成员也被赋予了这些共性，则该结构体也会自动获得这些共性（而不需要手动写具体的实现代码）。

### 为范型函数添加共性约束

共性不是数据类型，所以无法将变量、函数的参数等数据类型声明为共性，但在添加共性约束到范型中。

比如要实现一个 "最大值"（"max"）函数，该函数传入两个参数，需要支持整数、浮点数等数据类型，我们很自然会想到把这个函数定义为范型函数，主要代码如下：

```js
函数 最大值<甲型> (甲型 left, 甲型 right)
    如果 left > right 那么 left 否则 right
以上
```

```js
function max<T> (T left, T right)
    if left > right then left else right
end
```

不过用户在调用这个函数时有可能会传入一些不支持大小比较的数据，比如逻辑型数据。可以在定义范型时加入约束，仅让具有指定的一个或多个共性的数据通过。

示例：

```js
函数 最大值<甲型> (甲型 left, 甲型 right) 其中
    甲型 限制 可大小比较
    如果 left > right 那么 left 否则 right
以上
```

```js
function max<T> (T left, T right) where
    T limit Ordered
    if left > right then left else right
end
```

如上例所示，通过在函数的参数列表后面添加 `其中`（`where`）关键字，然后列出需要约束的类型代号，以及 `限制`（`limit`）关键字，再加上共性的名称即可。

如果需要限制多个共性，则在 `限制` 关键字后面使用元组把多个共性名称列出，示例：

```js
函数 最大值<甲型> (甲型 left, 甲型 right) 其中
    甲型 限制 (可显示, 可大小比较)
    如果 left > right 那么 left 否则 right
以上
```

```js
function max<T> (T left, T right) where
    T limit (Display, Ordered)
    if left > right then left else right
end
```

注意，`其中` 关键字后面除了用于列出范型的约束，同时也是用于列出类型简写的地方，详见 [变量-函数的类型简写](variables.md#类型简写)

#### 为范型数据方法添加共性约束

除了可以为范型函数添加共性约束，还可以为范型数据方法添加共性约束。

比如为上例的 `点坐标` 添加 `显示摘要`（`showSummary`）方法：

```js
赋予<甲型> 点坐标<甲型> 其中
    甲型 限制 可显示
    函数 显示坐标(自我 p)
        ...
    以上
以上
```

```js
assign<T> Point<T> where
    T limit Display
    function showPoint(Self p)
        ...
    end
end
```

这样只有具有 `可显示` 的数据类型才能用于类型具体化 `点坐标` 结构体。
